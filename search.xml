<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>sout<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"辣鸡"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> test<span class="token punctuation">:</span>    lallala<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token comment">// 事务操作示例</span><span class="token keyword">func</span> <span class="token function">transactionDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>tx<span class="token punctuation">,</span> err <span class="token operator">:=</span> sqlxDB<span class="token punctuation">.</span><span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 开启事务</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">if</span> tx <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"begin trans failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>sqlStr1 <span class="token operator">:=</span> <span class="token string">"Update t_go_study_user set name = '张三' where id=?"</span>ret1<span class="token punctuation">,</span> err <span class="token operator">:=</span> tx<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>sqlStr1<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"exec sql1 failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>affRow1<span class="token punctuation">,</span> err <span class="token operator">:=</span> ret1<span class="token punctuation">.</span><span class="token function">RowsAffected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"exec ret1.RowsAffected() failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>sqlStr2 <span class="token operator">:=</span> <span class="token string">"Update t_go_study_user set name = '张三' where id=?"</span>ret2<span class="token punctuation">,</span> err <span class="token operator">:=</span> tx<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>sqlStr2<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"exec sql2 failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>affRow2<span class="token punctuation">,</span> err <span class="token operator">:=</span> ret2<span class="token punctuation">.</span><span class="token function">RowsAffected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"exec ret1.RowsAffected() failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>affRow1<span class="token punctuation">,</span> affRow2<span class="token punctuation">)</span><span class="token keyword">if</span> affRow1 <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> affRow2 <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"事务提交啦..."</span><span class="token punctuation">)</span>tx<span class="token punctuation">.</span><span class="token function">Commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 提交事务</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"事务回滚啦..."</span><span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"exec trans success!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 紅色</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 綠色</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 黃色</div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>5 Netty核心组件</title>
      <link href="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
      <url>/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-核心组件概述"><a href="#5-1-核心组件概述" class="headerlink" title="5.1 核心组件概述:"></a>5.1 核心组件概述:</h2><ol><li>Channel:<br><code>Channel</code>是NIO 三大核心组件之一, Channel是输入输出硬件设备与内存之间的一个通道的抽象,channel当做是 数据传输的载体,因此 channel可以被打开或者关闭,<br>可以连接或者断开连接.</li><li>ByteBuf:<br><code>ByteBuf</code>是Netty在Nio的ByteBuffer基础上的扩展,Netty的核心数据容器.</li><li>ChannelHandler和ChannelPipeline:<br><code>ChannelPipeline</code>: channel包裹的数据处理链,本质是个双向链表,结点元素是ChannelHandlerContext.而ChannelHandlerContext又与数据处理器<br><code>ChannelHandler</code>关联.<br><code>ChannelHandler</code>: 数据处理器,对数据的处理逻辑都在这个对象中完成.</li><li>EventLoopGroup和EventLoop:<br><code>EventLoopGroup</code>事件循环组: 本质是一个线程池,里面的线程与<code>EventLoop</code>事件循环相关联.</li><li>Future和Promise:<br><code>回调</code>: 本质是一个方法,一个指向已经被提供给其他方法的方法的引用<br><code>Future</code>: future可以看做是一个异步操作结果的占位符,future会在未来的某一个时刻完成,并提供对一步操作结果访问的途径.<br><code>Promise</code>: promise是对future的扩展,future本身是不提供对异步操作结果设置的途径,promise则提供了对异步操作设置结果的途径.</li></ol><h2 id="5-2-Channel"><a href="#5-2-Channel" class="headerlink" title="5.2 Channel:"></a>5.2 Channel:</h2><h3 id="5-2-1-Channel概述"><a href="#5-2-1-Channel概述" class="headerlink" title="5.2.1 Channel概述:"></a>5.2.1 Channel概述:</h3><ol><li><p>基本的I/O操作(bind,connect,read,write)依赖于底层网络传输提供的原语(Socket).Netty提供了自己的Channel及其子类,大大的降低了直接使用socket的复杂性.</p></li><li><p>通过channel可以获得当前网络连接的通道的状态</p></li><li><p>通过channel可以获得当前网络连接的配置参数(比如: 接口缓冲区的大小等)</p></li><li><p>channel提供异步的网络I/O操作(建立连接,读写,绑定端口等),异步调用意味着任何I/O都将立即返回,并且不保证在调用结束时所有的I/O操作已经完成</p></li><li><p>channel支持关联I/O操作与对应的处理程序(即handler)</p></li><li><p>不同的协议,不同阻塞类型的连接都有不同的channel与之对应,常见的Channel类型<code>不仅限与下列实现类</code>为:  </p><table><thead><tr><th align="left">Channel实现类</th><th>解释</th></tr></thead><tbody><tr><td align="left">NioSocketChannel</td><td>异步的客户端TCP连接</td></tr><tr><td align="left">NioServerSocketChannel</td><td>异步的服务端TCP连接</td></tr><tr><td align="left">NioDatagramChannel</td><td>异步udp连接</td></tr><tr><td align="left">NioSctpChannel</td><td>异步客户端Sctp连接</td></tr><tr><td align="left">NioSctpServerChannel</td><td>异步服务端Sctp连接</td></tr><tr><td align="left">OioSocketChannel</td><td>阻塞的客户端tcp连接</td></tr><tr><td align="left">EmbeddedChannel</td><td>内置的channel 用于测试channel</td></tr></tbody></table></li></ol><h3 id="5-2-2-Channel的层次结构、常用方法"><a href="#5-2-2-Channel的层次结构、常用方法" class="headerlink" title="5.2.2 Channel的层次结构、常用方法:"></a>5.2.2 Channel的层次结构、常用方法:</h3><h4 id="5-2-2-1-层次结构"><a href="#5-2-2-1-层次结构" class="headerlink" title="5.2.2.1 层次结构:"></a>5.2.2.1 层次结构:</h4>   <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Channel</span> <span class="token keyword">extends</span> <span class="token class-name">AttributeMap</span><span class="token punctuation">,</span> <span class="token class-name">ChannelOutboundInvoker</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Channel</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/channel%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="channel的层次结构"><br>   说明:  </p><pre><code>  1. 每一个Channel在初始化的时候都将会被分配一个ChannelPipeLine和ChannelConfig.  2. 每一个Channel都是独一无二的,Channel实现了java.lang.Comparable接口,从而保证了Channel的顺序.  3. ChannelConfig包含了该channel的所有设置,并且支持了更新,可以通过`实现ChannelConfig的子类来给Channel设置某些特殊的设置`    4. ChannelPipeLine是实现Channel只执行I/O操作所有逻辑的容器,里面包含了许多 实际处理数据的handler了, 本质是一个 双向链表,表头表位分别表示入站出站的起点.  5. Netty的Channel是线程安全的,所以可以使用多线程对channel进行操作  6. 通过Channel.write()操作,数据将从链表表尾开始向链表表头移动,通过ChannelHandlerContext.write()是将数据传递给下一个ChannelHandler开始沿着链表移动.  </code></pre><h4 id="5-2-2-2-常见方法"><a href="#5-2-2-2-常见方法" class="headerlink" title="5.2.2.2 常见方法"></a>5.2.2.2 常见方法</h4><ol><li><p><code>Channel read()</code>: 从当前Channel中读取数据到第一个inbound缓冲区,如果数据读取成功,触发<code>ChannelHandler.channelRead(ChannelHandlerContext ctx, Object msg)事件</code>.<code>read()操作</code>完毕之后,紧接着触发<code>ChannelHandler.channelReadComplete(ChannelHandlerContext ctx)事件</code>.<br>如果该channel读请求被挂起,后续的读操作会被忽略.</p></li><li><p><code>ChannelFuture write(Object msg)</code>: 请求将当前的msg通过ChannelPipeLine(<code>从pipeline的链表尾开始流动</code>)写入到Channel中.</p><blockquote><p>注意: write只是将数据存放于channel的缓冲区中,并不会将数据发送出去.要发送数据必须使用flush()方法  </p></blockquote></li><li><p><code>ChannelFuture write(Object msg, ChannelPromise promise)</code>: 与 <code>方法2</code> 作用相同,参数 <code>promise</code>是用来写入 <code>write方法</code>的执行结果.  </p></li><li><p><code>ChannelFuture writeAndFlush(Object msg)</code>: 与 <code>方法2</code> 作用类似, 不过 <code>会立即将msg发送出去</code>  </p></li><li><p><code>ChannelFuture writeAndFlush(Object msg, ChannelPromise promise)</code>: 与 <code>方法4</code> 作用相同, 参数 <code>promise</code>是用来写入 <code>write方法</code>的执行结果.</p></li><li><p><code>ChannelOutboundInvoker flush()</code>: 将所有带发送的数据(<code>存放于channel缓冲区中的数据</code>),发送出去</p></li><li><p><code>ChannelFuture close()</code>: 关闭<code>channel</code>无论 <code>close</code>操作是成功还是失败,都会通知一次<code>channelFuture对象</code>(即触发ChannelFuture.<br>operationComplete方法). <code>close操作</code>会级联触发该channel关联的<code>channePipeLine</code>中所有 <code>出站handler(继承了xxxOutBoundHandler)的close方法</code>.</p><blockquote><p>注意: 一旦channel 被关闭之后,就无法再使用了</p></blockquote></li><li><p><code>ChannelFuture disconnect()</code>: 断开与远程通信对端的连接. <code>disconnect方法</code>会级联触发该channel关联的<code>channePipeLine</code>中所有 <code>出站handler(继承了xxxOutBoundHandler)的close方法</code></p></li><li><p><code>ChannelFuture disconnect(ChannelPromise promise)</code>: 断开与远程通信对端的连接,并级联触发所有出站handler的<code>disconnect方法</code>,参数<code>promise</code>用于设置<br><code>diaconnect方法</code>的执行结果.  </p></li><li><p><code>ChannelFuture connect(SocketAddress remoteAddress)</code>: 客户端使用指定的服务端地址remoteAddress发起连接请求,如果连接因为应答超时而失败,<br>ChannelFuture中的 <code>connect方法</code>执行结果就是<code>ConnectTimeoutException</code>,连接被拒绝就是<code>ConnectException</code>.<br><code>connection方法</code>会级联触发该channel关联的<code>pipeline</code>中所有<code>出站handler</code>中的<code>connect方法</code>.  </p><blockquote><p>connect方法有很多的重载方法,可以既连接远程,又绑定本地地址等…  </p></blockquote></li><li><p><code>ChannelFuture bind(SocketAddress localAddress)</code>: 绑定本地的socket地址,并级联触发所有<code>出站handler</code>中的<code>bind (ChannelHandlerContext, SocketAddress, ChannelPromise)方法</code>  </p><blockquote><p>重载方法多了一个参数 <code>promise</code>,支持对bind操作执行结果的设置  </p></blockquote></li><li><p>channel信息获取方法:  </p></li></ol>   <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ChannelConfig</span> <span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 获取channel的配置信息,如: 连接超时时间</span><span class="token class-name">ChannelMetadata</span> <span class="token function">metadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 获取channel的元数据描述信息,如TCP配置信息等</span><span class="token keyword">boolean</span> <span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// channel是否已经打开</span><span class="token keyword">boolean</span> <span class="token function">isRegistered</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// channel 是否已经注册到EventLoop中</span><span class="token keyword">boolean</span> <span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// channel是否已经处于激活状态</span><span class="token keyword">boolean</span> <span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// channel是否可写</span><span class="token class-name">SocketAddress</span> <span class="token function">localAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// channel本地绑定地址</span><span class="token class-name">SocketAddress</span> <span class="token function">remoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// channel 远程通信的远程地址</span><span class="token class-name">ChannelPipeline</span> <span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取channel关联的pipeline  </span><span class="token class-name">ByteBufAllocator</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取channel缓冲区的分配对象,用于分配缓冲区大小  </span><span class="token class-name">EventLoop</span> <span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取channel绑定的eventLoop(唯一分配一个I/O事件的处理线程)</span><span class="token class-name">ChannelId</span> <span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取channel的唯一标识</span><span class="token class-name">Channel</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// serverChannel.parent()返回null,socketChannel返回serverSocketChannel </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-3-Channel的源码分析"><a href="#5-2-3-Channel的源码分析" class="headerlink" title="5.2.3 Channel的源码分析:"></a>5.2.3 Channel的源码分析:</h3><p>   TODO</p><h2 id="5-3-ByteBuf"><a href="#5-3-ByteBuf" class="headerlink" title="5.3 ByteBuf:"></a>5.3 ByteBuf:</h2><h3 id="5-3-1-ByteBuf概述"><a href="#5-3-1-ByteBuf概述" class="headerlink" title="5.3.1 ByteBuf概述:"></a>5.3.1 ByteBuf概述:</h3><ol><li><p>ByteBuf优化:<br>NIO中ByteBuffer的缺点:  </p><ul><li><code>长度固定</code>: 一旦ByteBuffer分配完成,其容量就不能动态扩展或者收缩, 容易出现数组越界异常.</li><li><code>操作繁琐</code>: ByteBuffer所有的读写操作都是基于<code>position</code>作为定位指针进行操作,读写操作切换的时候需要使用<code>flip()</code>或者<code>rewind()</code>方法</li><li><code>功能有限</code>: ByteBuffer的API功能有限, 一些高级和实用的特性不支持,需要手动实现  </li></ul><p>Netty中ByteBuf的优点:  </p><ul><li>可以被用户自定义的缓冲区类型扩展</li><li>通过内置的复合缓冲区实现了透明的零拷贝  </li><li>容量可以按需增长(类似于StringBuilder)  </li><li>读写操作使用不同的索引,读写都有专门的api无需来回切换</li><li>支持方法的链式调用  </li><li>支持引用计数</li><li>支持池化  </li></ul></li></ol><h3 id="5-3-2-ByteBuf工作原理"><a href="#5-3-2-ByteBuf工作原理" class="headerlink" title="5.3.2 ByteBuf工作原理:"></a>5.3.2 ByteBuf工作原理:</h3><ol><li><p>ByteBuf的数据结构:  </p><ul><li><code>初始化时</code>:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/ByteBuf%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="ByteBuf数据结构">  </li><li><code>写入部分数据之后</code>:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E8%AF%BB%E5%86%99%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E4%B9%8B%E5%90%8E.png" alt="ByteBuf数据结构"><br>说明:  <ul><li>ByteBuf维护了两个不同的指针: 一个用于读(readerIndex),一个用于写(writeIndex).</li><li>ReadIndex 和 WriteIndex 的起始位置都是数组下标为0的位置. </li><li>凡是 <code>read</code> 或者 <code>write</code>开头的api都会让 <code>readerIndex</code> 或者 <code>writeIndex</code>递增,而 <code>get</code> 或者 <code>set</code>开头的api不会.</li><li>ByteBuf有默认的最大长度限制 <code>Integter.MAX_VALUE</code>.在这个范围之内可以定义ByteBuf的最大容量,通过<code>capacity(int) </code>或者<code>ensureWritable(int)</code>方法扩容如果超出最大容量会抛出异常.</li><li>试图读 <code>writeIndex</code>之后的数据,或者视图在<code>最大容量</code>之外写数据,会发生数组越界异常  </li></ul></li></ul></li><li><p>ByteBuf的使用模式:  </p><ul><li><p><code>堆缓冲区</code>:<br>最常用模式,将数据存放在JVM的对空间里面.这种模式又被称为是 <code>支撑数组</code>.<br><code>优点</code>: 能够在没有使用 <code>池化</code> 的情况下提供快速的分配和释放.<code>非常适合有遗留数据需要处理的情况</code><br><code>缺点</code>: 当需要发送堆缓冲区的数据时,JVM需要在内部把 <code>堆缓冲区</code> 中的数据复制到 <code>直接缓冲区</code>中.<br>使用示例:  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 通过netty提供的工具类Unpooled获取Netty的数据容器,ByteBuf</span><span class="token class-name">ByteBuf</span> byteBuf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">copiedBuffer</span><span class="token punctuation">(</span><span class="token string">"hello netty"</span><span class="token punctuation">,</span> <span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 相关方法</span><span class="token comment">// public abstract boolean hasArray();判断ByteBuf的使用模式(hasArray判断的是 byteBuf是否在堆空间有一个支撑数组),</span><span class="token comment">// 即数据存放的位置在哪儿 堆/直接缓存区/复合缓冲区</span><span class="token keyword">if</span> <span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">hasArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//  获取byteBuf的支撑数组</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> byteBuf<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 把字节数组转换成字符串</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 获取支撑数组的一些信息:</span>    <span class="token comment">// 获取支撑数组的偏移量</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">arrayOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取支撑数组的可读索引位置</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取支撑数组的可写索引位置</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">writerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取支撑数组的容量</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获取支撑数组中剩余可读元素占多少个字节,这个的大小是相对于readerIndex位置的,</span>    <span class="token comment">// 比如下面这个读取方法会导致readerIndex的移动,从而导致readableBytes()变化</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">readByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 但是getByte方法是不会造成readerIndex移动的</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>直接缓冲区</code>:<br><code>网络数据传输最理想的选择</code>,直接缓冲区中的数据是常驻在常规会被JVM进行垃圾回收的堆空间之外.<br>优点: 由于数据是存储在JVM堆空间之外的直接内存中,在进行网络传输的时候,无需把数据从堆空间复制到直接内存中,提高网络传输时的性能.<br>缺点: 1.分配和释放的开销都十分昂贵;2.如果数据不仅仅是用作网络传输的数据,在服务端还可能对齐进行访问的话,必须要将数据从<code>直接内存</code>复制到<code>堆空间中</code>来.</p><blockquote><p>建议: 如果缓冲区中的数据,需要被访问的话,堆缓冲区是更好的选择.</p></blockquote><p>使用示例:  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ByteBuf</span> directBuf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">directBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// public abstract boolean hasArray();判断ByteBuf的使用模式(hasArray判断的是 byteBuf是否在堆空间有一个支撑数组),</span><span class="token comment">// 如果不是那么就是直接缓冲区</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>directBuf<span class="token punctuation">.</span><span class="token function">hasArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> directBuf<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>    directBuf<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>directBuf<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 业务逻辑处理</span>    <span class="token function">handleArray</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>复合缓冲区</code>:<br><code>多个ByteBuf的聚合视图</code>,可以根据需要添加或者删除ByteBuf实例.Netty通过ByteBuf子类 — <code>CompositeByteBuf</code>实现<code>复合缓冲区模式</code>,<br>其提供一个将多个缓冲区表示为单个合并缓冲区的虚拟表示.</p><blockquote><p>ps:  <code>CompositeByteBuf</code>中的byteBuf实例可能同时包含 <code>直接缓冲区</code>或者<code>非直接缓冲区</code>,此时<code>hasArray()</code>方法在只有一个实例的时候,回去判断该实例是否有支撑数组,<br>存在多个实例的时候<code>hasArray方法</code>总是返回<code>false</code></p></blockquote><p>使用示例:  模拟一个HTTP协议传输的消息,包含两部分 头部和主题,分别由不同的模块生成,在发送数据的时候进行组装.如图:<code>可以使用CompositeByteBuf来消除每条消息都重复创建这两个缓冲区</code><br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/CompositeByteBuf%E7%A4%BA%E4%BE%8B.png" alt="Composite实例"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//  -------------------------------  构造 复合缓冲区  -----------------------------</span><span class="token class-name">CompositeByteBuf</span> composited <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">compositeBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 也可以是堆缓冲区</span><span class="token class-name">ByteBuf</span> headerBuf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">directBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 也可以是直接缓冲区,buffer()返回的是一个堆缓冲区</span><span class="token class-name">ByteBuf</span> bodyBuf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 添加缓冲区到复合缓冲区</span>composited<span class="token punctuation">.</span><span class="token function">addComponents</span><span class="token punctuation">(</span>headerBuf<span class="token punctuation">,</span>bodyBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//  .... 业务逻辑</span>          <span class="token comment">// 删除某个buf,按照添加的顺序,在本例子中,0为headBuf</span>composited<span class="token punctuation">.</span><span class="token function">removeComponent</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 遍历获取每一个buf</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuf</span> buf <span class="token operator">:</span> composited<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>             <span class="token comment">// ------------------------------  访问复合缓冲区  --------------------------------</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">byteBufCompositeArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">CompositeByteBuf</span> compBuf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">compositeBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//获得可读字节数</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> compBuf<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//分配一个具有可读字节数长度的新数组</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//将字节读到该数组中</span>    compBuf<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>compBuf<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//使用偏移量和长度作为参数使用该数组</span>    <span class="token function">handleArray</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h3 id="5-3-3-字节级别操作"><a href="#5-3-3-字节级别操作" class="headerlink" title="5.3.3 字节级别操作:"></a>5.3.3 字节级别操作:</h3><p>工作时通常ByteBuf的数据结构图:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E8%AF%BB%E5%86%99%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E4%B9%8B%E5%90%8E.png" alt="ByteBuf数据结构"></p><h4 id="5-3-3-1-几种不同的字节区间"><a href="#5-3-3-1-几种不同的字节区间" class="headerlink" title="5.3.3.1 几种不同的字节区间:"></a>5.3.3.1 几种不同的字节区间:</h4><ol><li><p><code>可丢弃字节区间</code>:<br>在ByteBuf中,已经被读取过的字节都会被视为是 <code>可丢弃的字节</code>, <code>0</code>到 <code>readerIndex</code>之间就是 <code>可丢弃区间</code>,通过<code>discardReadBytes()</code>可以丢弃他们并回收空间.<br><code>discardReadBytes()</code>方法会将 <code>readerIndex</code>重新指向 <code>byteBuf</code>数组开始元素的位置,<code>writerIndex</code>会减少相应的数量.<br><code>discardReadBytes()</code>调用之后的数据结构:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/discardReadBytes%E8%B0%83%E7%94%A8%E4%B9%8B%E5%90%8E.png" alt="ByteBuf数据结构"></p><blockquote><p>注意:</p><ol><li>由于<code>discardReadBytes()</code>方法只是移动了<code>writerIndex</code>和<code>可读字节</code>,但是没有对其他数组空间进行数据擦除,所以可写部分的数据是<code>没有任何保证的</code>.</li><li>在非必要时刻(内存极低紧张)的时候,不要使用 <code>discardReadBytes()</code>将<code>可丢弃字节区间</code>转化为<code>可写区间</code>,因为该方法必须将<code>可读区间</code>中的数据转移到数组开始位置去,这个操作很有可能会发生<code>内存复制</code></li></ol></blockquote></li><li><p><code>可读字节区间</code>:<br>ByteBuf的可读字节是存储实际数据的区间.<code>新分配</code>、<code>包装</code>、<code>复制</code>的缓冲区默认的<code>readerIndex</code>为<code>0</code>.<br>任何 <code>read</code> 或者 <code>skip</code> 开头的方法都会将造成<code>readerIndex</code>增加已读字节. 如果 <code>readBytes(ByteBuf dest)</code>读取并写入到<code>dest</code>会造成 <code>dest</code>的<code>writerIndex</code><br>增加相应的数量.</p><blockquote><p>读取 <code>writerIndex</code>之外的数据将造成数组越界异常</p></blockquote></li><li><p><code>可写字节区间</code>:<br>可写字节区间是指一个拥有未定义内容的,写入就绪的内存区域.<code>新分配</code>的缓冲区默认的<code>readerIndex</code>为<code>0</code>.<br>任何以 <code>write</code> 开头的方法都会造成 <code>writerIndex</code>增加以写入字节数.<br>如果 <code>writeBytes(Bytes dest)</code>读取并写入到<code>dest</code> 会造成 <code>调用</code> 这个方法的缓冲区的 <code>readerIndex</code>增加相应的数量.</p></li></ol><h4 id="5-3-3-2-索引管理"><a href="#5-3-3-2-索引管理" class="headerlink" title="5.3.3.2 索引管理:"></a>5.3.3.2 索引管理:</h4><ol><li><p><code>随机访问索引</code>: <code>get或者set</code>开头的方法来随机<code>访问或者写入</code>数据 ByteBuf与普通数组一样,索引总是从 <code>0</code>开始,到<code>capacity - 1</code>截至.</p><blockquote><p>注意:</p><ol><li><code>get或者set</code>开头的方法不会造成读写索引的移动</li><li>通过<code>需要索引值为入参</code>的方法来访问缓冲区,同样不会造成读写索引的移动</li><li>在需要的时候可以通过 readerIndex(index) 或者 writerIndex(index) 来移动读写索引</li></ol></blockquote></li><li><p><code>顺序访问索引</code>: <code>read()或者write()</code>方法来顺序 <code>读取或者写入</code> 数据</p></li><li><p><code>索引管理</code>:<br>调用 <code>markReaderIndex()</code>, <code>markWriterIndex()</code> 来标记读写索引<br>调用 <code>resetWriterIndex()</code>, <code>resetReaderIndex()</code> 来重置读写索引到标记的位置<br>调用 <code>readerIndex(index)</code>, <code>writerIndex(index</code> 来指定读写索引的位置<br>调用 <code>clear()</code> 将读写索引重新指向 <code>数组起始位置</code>  </p><blockquote><ol><li><code>clear()</code>方法仅仅是重置读写索引为0,不会对buf中的数据进行清除  </li><li>相对于 <code>discardReadBytes()</code>方法,<code>clear()</code>方法更为效率,因为它只是将读写索引重置为了0,不会引发任何的数据复制.</li></ol></blockquote></li></ol><h4 id="5-3-3-3-派生缓冲区"><a href="#5-3-3-3-派生缓冲区" class="headerlink" title="5.3.3.3 派生缓冲区:"></a>5.3.3.3 派生缓冲区:</h4><p>派生缓冲区为ByteBuf提供以专门的方式呈现 <code>缓冲区数据</code> 的视图,常见方法为:  </p><ul><li><code>duplicate()</code>: 返回一个与调用<code>duplicate()</code>的缓冲区<code>共享所有空间</code>的缓冲区  </li><li><code>slice()</code>: 返回调用<code>slice()</code>的缓冲区<code>整个可读字节区间</code>的切片  </li><li><code>slice(int,int)</code>: 返回调用<code>slice()</code>的缓冲区<code>部分可读字节区间</code>的切片</li><li><code>readSlice(int length)</code>: 返回调用<code>slice()</code>的缓冲区<code>可读字节区间中 readerIndex + length</code>的切片,会将<code>readerIndex</code>增加length长度.</li><li><code>order(ByteOrder)</code>:  </li><li><code>Unpooled.unmofifiableBuffer(..)</code>:  </li></ul><blockquote><p>注意:</p><ol><li>上面的方法只是将数据展示出来了,但是与原buffer使用的是同一份数据,修改派生缓冲区的数据也会改变原缓冲区的数据.(<code>如同ArrayList.subList</code>)</li><li>如果想要复制一份独立的数据副本,请使用<code>copy()</code>,<code>copy(int,int)</code>  </li></ol></blockquote><p>测试:  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// ----------------------   非共享  -----------------------------------------</span><span class="token class-name">Charset</span> utf8 <span class="token operator">=</span> <span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建 ByteBuf 以保存所提供的字符串的字节</span><span class="token class-name">ByteBuf</span> buf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">copiedBuffer</span><span class="token punctuation">(</span><span class="token string">"Netty in Action rocks!"</span><span class="token punctuation">,</span> utf8<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建该 ByteBuf 从索引 0 开始到索引 15 结束的分段的副本</span><span class="token class-name">ByteBuf</span> copy <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将打印"Netty in Action"</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>copy<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>utf8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//更新索引 0 处的字节</span>buf<span class="token punctuation">.</span><span class="token function">setByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token string">'J'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将会成功，因为数据不是共享的</span><span class="token keyword">assert</span> buf<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> copy<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// ----------------------   共享  -----------------------------------------</span><span class="token comment">//创建一个用于保存给定字符串的字节的 ByteBuf</span><span class="token class-name">ByteBuf</span> bufForSlice <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">copiedBuffer</span><span class="token punctuation">(</span><span class="token string">"Netty in Action rocks!"</span><span class="token punctuation">,</span> utf8<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建该 ByteBuf 从索引 0 开始到索引 15 结束的一个新切片</span><span class="token class-name">ByteBuf</span> sliced <span class="token operator">=</span> bufForSlice<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将打印"Netty in Action"</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sliced<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>utf8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//更新索引 0 处的字节</span>bufForSlice<span class="token punctuation">.</span><span class="token function">setByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token string">'J'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将会成功，因为数据是共享的，对其中一个所做的更改对另外一个也是可见的</span><span class="token keyword">assert</span> bufForSlice<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> sliced<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-3-4-查找字节所在的位置"><a href="#5-3-3-4-查找字节所在的位置" class="headerlink" title="5.3.3.4 查找字节所在的位置:"></a>5.3.3.4 查找字节所在的位置:</h4><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C.png" alt="1"><br>一般的字节可以通过 <code>indexOf()</code> 方法来查找指定的字节,或者通过传入 <code>ByteProcessor参数</code> 设定<code>中止字符</code>来配合<code>forEachByte()方法</code>帮助查找.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Aborts on a {@code NUL (0x00)}. */</span><span class="token class-name">ByteProcessor</span> FIND_NUL <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexOfProcessor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * Aborts on a non-{@code NUL (0x00)}. */</span><span class="token class-name">ByteProcessor</span> FIND_NON_NUL <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexNotOfProcessor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * Aborts on a {@code CR ('\r')}. */</span><span class="token class-name">ByteProcessor</span> FIND_CR <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexOfProcessor</span><span class="token punctuation">(</span>CARRIAGE_RETURN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * Aborts on a non-{@code CR ('\r')}. */</span><span class="token class-name">ByteProcessor</span> FIND_NON_CR <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexNotOfProcessor</span><span class="token punctuation">(</span>CARRIAGE_RETURN<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * Aborts on a {@code LF ('\n')}. */</span><span class="token class-name">ByteProcessor</span> FIND_LF <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexOfProcessor</span><span class="token punctuation">(</span>LINE_FEED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * Aborts on a non-{@code LF ('\n')}. */</span><span class="token class-name">ByteProcessor</span> FIND_NON_LF <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexNotOfProcessor</span><span class="token punctuation">(</span>LINE_FEED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * Aborts on a semicolon {@code (';')}. */</span><span class="token class-name">ByteProcessor</span> FIND_SEMI_COLON <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexOfProcessor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * Aborts on a comma {@code (',')}. */</span><span class="token class-name">ByteProcessor</span> FIND_COMMA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexOfProcessor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * Aborts on a ascii space character ({@code ' '}). */</span><span class="token class-name">ByteProcessor</span> FIND_ASCII_SPACE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexOfProcessor</span><span class="token punctuation">(</span>SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/** * Aborts on a {@code CR ('\r')} or a {@code LF ('\n')}. */</span><span class="token class-name">ByteProcessor</span> FIND_CRLF <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">byte</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value <span class="token operator">!=</span> CARRIAGE_RETURN <span class="token operator">&amp;&amp;</span> value <span class="token operator">!=</span> LINE_FEED<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">/** * Aborts on a byte which is neither a {@code CR ('\r')} nor a {@code LF ('\n')}. */</span><span class="token class-name">ByteProcessor</span> FIND_NON_CRLF <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">byte</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value <span class="token operator">==</span> CARRIAGE_RETURN <span class="token operator">||</span> value <span class="token operator">==</span> LINE_FEED<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">/** * Aborts on a linear whitespace (a ({@code ' '} or a {@code '\t'}). */</span><span class="token class-name">ByteProcessor</span> FIND_LINEAR_WHITESPACE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">byte</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value <span class="token operator">!=</span> SPACE <span class="token operator">&amp;&amp;</span> value <span class="token operator">!=</span> HTAB<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">/** * Aborts on a byte which is not a linear whitespace (neither {@code ' '} nor {@code '\t'}). */</span><span class="token class-name">ByteProcessor</span> FIND_NON_LINEAR_WHITESPACE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">byte</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value <span class="token operator">==</span> SPACE <span class="token operator">||</span> value <span class="token operator">==</span> HTAB<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-4-ByteBuf常见API总结"><a href="#5-3-4-ByteBuf常见API总结" class="headerlink" title="5.3.4 ByteBuf常见API总结:"></a>5.3.4 ByteBuf常见API总结:</h3><h4 id="5-3-4-1-顺序读操作"><a href="#5-3-4-1-顺序读操作" class="headerlink" title="5.3.4.1 顺序读操作:"></a>5.3.4.1 顺序读操作:</h4><p>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%93%8D%E4%BD%9C1.png" alt="1"><br>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%93%8D%E4%BD%9C2.png" alt="1"><br>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%93%8D%E4%BD%9C3.png" alt="1"><br>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%93%8D%E4%BD%9C4.png" alt="1">   </p><h4 id="5-3-4-2-顺序写操作"><a href="#5-3-4-2-顺序写操作" class="headerlink" title="5.3.4.2 顺序写操作:"></a>5.3.4.2 顺序写操作:</h4><p>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E5%86%99%E6%93%8D%E4%BD%9C1.png" alt="1"><br>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E5%86%99%E6%93%8D%E4%BD%9C2.png" alt="1"><br>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E5%86%99%E6%93%8D%E4%BD%9C3.png" alt="1"><br>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E5%86%99%E6%93%8D%E4%BD%9C4.png" alt="1">  </p><h4 id="5-3-4-3-随机写操作"><a href="#5-3-4-3-随机写操作" class="headerlink" title="5.3.4.3 随机写操作:"></a>5.3.4.3 随机写操作:</h4><p>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%9A%8F%E6%9C%BA%E5%86%99%E6%93%8D%E4%BD%9C.png" alt="1">  </p><h4 id="5-3-4-4-随机读操作"><a href="#5-3-4-4-随机读操作" class="headerlink" title="5.3.4.4 随机读操作:"></a>5.3.4.4 随机读操作:</h4><p>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%9A%8F%E6%9C%BA%E8%AF%BB%E6%93%8D%E4%BD%9C.png" alt="1"></p><h4 id="5-3-4-5-其他操作"><a href="#5-3-4-5-其他操作" class="headerlink" title="5.3.4.5 其他操作:"></a>5.3.4.5 其他操作:</h4><p>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C.png" alt="1"></p><h3 id="5-3-5-ByteBuf辅助工具类"><a href="#5-3-5-ByteBuf辅助工具类" class="headerlink" title="5.3.5 ByteBuf辅助工具类:"></a>5.3.5 ByteBuf辅助工具类:</h3><h4 id="5-3-5-1-ByteBufHolder接口"><a href="#5-3-5-1-ByteBufHolder接口" class="headerlink" title="5.3.5.1 ByteBufHolder接口:"></a>5.3.5.1 ByteBufHolder接口:</h4><p><code>ByteBufHolder</code>是<code>ByteBuf</code>的容器,除了实际数据装载之外,我们还需要存储各种属性值.比如HTTP的请求和响应都可以携带消息体,在Netty中消息体就是用<code>ByteBuf</code>来表示;<br>但是由于不同的协议之间会包含不同的协议字段和功能,这部分数据并不适合写在实际数据中,所以Netty抽象出了一个 <code>ByteBufHolder接口</code>持有一个<code>ByteBuf</code>用以装载实际数据,<br>同时携带不同协议的协议字段和功能. (ByteBufHolder的实现类实现不同协议的协议字段和功能描述).<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E4%B8%8D%E5%90%8C%E5%8D%8F%E8%AE%AE%E7%9A%84ByteBufHolder%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt="1"><br>说明:  </p><ul><li><code>ByteBufHolder</code>为Netty的高级特性提供了支持,比如缓冲区池化,其中可以从池中借用ByteBuf,并且在需要时自动释放.  </li><li><code>通常用作需要存储实际数据的消息对象接口</code></li><li><code>常用方法</code>:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/ByteBufHolder%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="1">  </li></ul><h4 id="5-3-5-2-ByteBuf内存空间分配"><a href="#5-3-5-2-ByteBuf内存空间分配" class="headerlink" title="5.3.5.2 ByteBuf内存空间分配:"></a>5.3.5.2 ByteBuf内存空间分配:</h4><ol><li><p><code>按需分配 --- ByteBufAllocator接口</code>:  </p><ol><li><p>为了降低分配和释放的内存开销,Netty通过<code>interface ByteBufAllocator</code>实现了缓冲区池化,<code>ByteBufAllocator</code>可以用来分配我们所描述过得任意类型的ByteBuf实例.<br><code>池化</code>不会改变<code>ByteBuf</code>api 的语义,只是新的数据需要使用ByteBuf来存储的时候,可以从缓冲池中取出一个 <code>ByteBuf实例</code> 来存储数据.</p></li><li><p>常用方法:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/ByteBufAllocator%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="1">  </p></li><li><p>说明:  </p><ul><li><p>可以通过 <code>channel</code>(每个都可以有一个不同的ByteBufAllocator实例) 或者 绑定到<br><code>channelHandler</code>的<code>ChannelHandlerContext</code>获取到一个<code>ByteBufAllocator</code>的引用.  </p></li><li><p>Netty提供了  ByteBufAllocator 的实现:<br><code>PooledByteBufAllocator</code>:  池化ByteBuf实例,提高性能并最大限度的减少内存碎片.使用的是jemalloc技术实现的内存分配.<br><code>UnpooledByteBufAllocator</code>:  非池化ByteBuf实例分配,每一次调用都会返回一个新的byteBuf实例.  </p><blockquote><ol><li>netty4.1版本默认使用的是 <code>PooledByteBufAllocator</code>, 4.0版本默认使用的则是 <code>UnpooledByteBufAllocator</code>.</li><li>可以通过<code>ChannelConfig</code>或者<code>Bootstrap</code>配置 使用什么类型的 <code>ByteBufAllocator</code>.</li></ol></blockquote></li><li><p><code>ioBuffer()</code>: 这个方法在使用的时候,如果当前运行环境有 sun.misc.Unsafe 支持的时候, 返回的是 <code>Direct ByteBuf</code>,否则返回的是 <code>Heap ByteBuf</code>.<br>当使用 <code>PreferHeapByteBufAllocator</code>的时候, 只会返回 <code>Heap ByteBuf</code>.</p></li></ul></li></ol></li><li><p><code>Unpooled缓冲区</code>:<br>在某些情况下,如果未能获取到一个 <code>ByteBufAllocator</code>的引用.可以通过工具类 <code>Unpooled</code> 来创建未池化的 <code>ByteBuf实例</code>.<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/Unpooled%E5%B7%A5%E5%85%B7%E7%B1%BB.png" alt="1">  </p></li><li><p><code>ByteBufUtil类</code>:<br><code>ByteBufUtil</code> 提供了用于操作 <code>ByteBuf</code> 的静态的辅助方法。因为这个API是通用的，并且和池化无关，所以这些方法已然在分配类的外部实现。<br>这些静态方法中最有价值的可能就是 hexdump()方法，它以十六进制的表示形式输出<code>ByteBuf</code> 的内容。这在各种情况下都很有用，例如，出于调试的目的记录 <code>ByteBuf</code> 的内容。十<br>六进制的表示通常会提供一个比字节值的直接表示形式更加有用的日志条目，此外，十六进制的版本还可以很容易地转换回实际的字节表示。<br>另一个有用的方法是 <code>boolean equals(ByteBuf, ByteBuf)</code>，它被用来判断两个 <code>ByteBuf</code>实例的相等性。</p></li></ol><h3 id="5-3-6-引用计数"><a href="#5-3-6-引用计数" class="headerlink" title="5.3.6 引用计数:"></a>5.3.6 引用计数:</h3><ul><li><p><code>引用计数</code>: 一种通过在某个对象所持有的资源不再被其他对象引用时,释放该对象所持有的资源来优化内存使用和性能的技术.(<code>类似于JVM的引用计数算法</code>)  </p></li><li><p>Netty 在第 4 版中为 <code>ByteBuf</code> 和 <code>ByteBufHolder</code> 引入了引用计数技术，它们都实现了 <code>interface ReferenceCounted</code>.  </p></li><li><p><code>引用计数实现的大致思路</code>: 它主要涉及跟踪到某个特定对象的活动引用的数量。一个 <code>ReferenceCounted</code> 实现的实例将通常以活动的引用计数为 <code>1</code>作为开始。只要<code>引用计 数</code>大于 <code>0</code>，就能保证对象不会被释放。当活动引用的数量减少到 0 时，该实例就会被释放。</p><blockquote><p>注意: 虽然释放的确切语义可能是特定于实现的，但是至少已经释放的对象应该不可再用了。</p></blockquote></li><li><p><code>引用计数</code>对于 <code>池化实现</code>（如 PooledByteBufAllocator）来说是至关重要的，它降低了内存分配的开销。</p></li><li><p>试图访问一个已经被<code>释放(或者说是 引用计数为 0)</code>的引用计数的对象，将会导致一个 <code>IllegalReferenceCountException</code>。  </p></li><li><p><code>谁来释放</code>: 一般是由 最后访问资源的一方 来负责释放 资源.  </p></li></ul><blockquote><p>一个特定的（ReferenceCounted 的实现）类，可以用它自己的独特方式来定义它的引用计数规则。例如，我们可以设想一个类，其 <code>release()</code> 方法的实现总是将引用计数设为<br>零，而不用关心它的当前值，从而一次性地使所有的活动引用都失效。  </p></blockquote><h3 id="5-3-7-ByteBuf源码分析"><a href="#5-3-7-ByteBuf源码分析" class="headerlink" title="5.3.7 ByteBuf源码分析:"></a>5.3.7 ByteBuf源码分析:</h3><p>TODO</p><h2 id="5-4-ChannelHandler和ChannelPipeline"><a href="#5-4-ChannelHandler和ChannelPipeline" class="headerlink" title="5.4 ChannelHandler和ChannelPipeline:"></a>5.4 ChannelHandler和ChannelPipeline:</h2><h3 id="5-4-1-ChannelHandler和ChannelPipeline的概述"><a href="#5-4-1-ChannelHandler和ChannelPipeline的概述" class="headerlink" title="5.4.1 ChannelHandler和ChannelPipeline的概述:"></a>5.4.1 ChannelHandler和ChannelPipeline的概述:</h3><p><code>Channel,ChannelPipeline,ChannelContext,ChannelHandler之间的关系</code>:  </p><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/channelhandler%E5%85%B3%E7%B3%BB.png" alt="关系图"></p><p>Netty的ChannelPipeline和ChannelHandler机制类似于Servlet和Filter过滤器,这类拦截器实际上是责任链模式的一种变形,主要是为了方便事件的拦截和用户业务逻辑的定制.<br><code>ChannelHandler</code>: 从应用程序开发人员的角度来看,Netty的主要组件是ChannelHandler,它充当了所有处理入站和出站数据的应用程序逻辑的容器,ChannelHandler可以适用于任何逻辑操作.<br><code>ChannelPipeline</code>: Netty将Channel的数据管道抽象为 <code>ChannelPipeline</code>,消息在 <code>ChannelPipeline</code>中流动和传递.<br><code>ChannelPipeline</code>持有I/O事件拦截器<code>ChannelHandler</code>的链表, 由 <code>ChannelHandler</code> 对I/O事件进行拦截和处理,可以方便的通过增删handler来实现不同业务逻辑的定制,不需要对已有<br>handler修改,就能实现对修改封闭和对扩展的支持.<br><code>ChannelHandlerContext</code>: 当<code>ChannelHandler</code>每一次被分配到一个<code>ChannelPipeline</code>的时候,都会创建一个新的<code>ChannelHandlerContext</code>与<code>ChannelHandler</code>关联起来,<br>其表示<code>ChannelHandler</code>与<code>ChannelPipeline</code>的绑定关系.</p><h3 id="5-4-2-ChannelHandler"><a href="#5-4-2-ChannelHandler" class="headerlink" title="5.4.2 ChannelHandler:"></a>5.4.2 ChannelHandler:</h3><h4 id="5-4-2-1-Channel的生命周期"><a href="#5-4-2-1-Channel的生命周期" class="headerlink" title="5.4.2.1 Channel的生命周期:"></a>5.4.2.1 Channel的生命周期:</h4><p><code>Channel</code>接口定义了一组和 <code>ChannelInBoundHandler</code>api 密切相关的简单但是功能强大的状态模型.<code>Channel的4个状态</code> :<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/Channel%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="channel生命周期"><br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/CHANNEL%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="channel状态模型"><br>说明:  </p><ul><li>只要<code>Channel</code>没有关闭,<code>Channel</code>就可以再次被注册到<code>EventLoop</code>组件上.</li><li>当图片中的状态一旦发生改变的时候,就会生成对应的事件,这些事件会被转发给 <code>ChannelPipeline</code> 中的 <code>ChannelHandler</code>处理.  </li></ul><h4 id="5-4-2-2-ChannelHandler的生命周期"><a href="#5-4-2-2-ChannelHandler的生命周期" class="headerlink" title="5.4.2.2 ChannelHandler的生命周期:"></a>5.4.2.2 ChannelHandler的生命周期:</h4><p><code>ChannelHandler</code>定义的生命周期操作,<code>ChannelHandler</code>被添加到<code>channelPipeline</code>或者从<code>channelPipeline</code>中移除的时候会触发这些操作.<br>每个方法都会接收一个<code>ChannelHandlerContext</code>作为参数<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/handler%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="ChannelHandler生命周期"><br><code>channelHandler</code>两个重要的子接口:  </p><ul><li><code>ChannelInboundHandler</code> : 处理入栈数据以及各种状态变化</li><li><code>ChannelOutboundHandler</code> : 处理出站数据并且允许拦截所有的操作</li></ul><h4 id="5-4-2-3-ChannelInboundHandler接口"><a href="#5-4-2-3-ChannelInboundHandler接口" class="headerlink" title="5.4.2.3 ChannelInboundHandler接口:"></a>5.4.2.3 <code>ChannelInboundHandler</code>接口:</h4><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/inboundHandler%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="ChannelInboundHandler"><br>说明:  </p><ul><li>上面是 <code>ChannelInboundHandler</code>的生命周期方法,channel中的<code>数据被读取</code>或者<code>channel状态发生变化</code>的时候被调用.</li><li>当 <code>ChannelInboundHandler</code>的子类类重写了<code>channelRead()</code>方法的时候,需要手动通过 <code>ReferenceCountUtil.release()</code>来手动释放与<code>池化ByteBuf有关的内存 (即参数msg)</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Sharable</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DiscardHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span><span class="token class-name">Object</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 如果不手动释放,Netty会通过日志的形式记录msg未释放的实例</span>        <span class="token class-name">ReferenceCountUtil</span><span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>也可以通过 <code>SimpleChannelInboundHandler</code>来自动释放资源,ps: 不要试图把 <code>SimpleChannelInboundHandler</code>中的数据存放起来,以便后期使用.</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Sharable</span>         <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DiscardHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span><span class="token punctuation">{</span>             <span class="token annotation punctuation">@Override</span>             <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span><span class="token class-name">Object</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token comment">// 在这里就不需要手动释放msg所占用的byteBuf空间了             }           }</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-4-2-3-ChannelOutboundHandler接口"><a href="#5-4-2-3-ChannelOutboundHandler接口" class="headerlink" title="5.4.2.3 ChannelOutboundHandler接口:"></a>5.4.2.3 <code>ChannelOutboundHandler</code>接口:</h4><p>出站操作和数据将由 <code>ChannelOutboundHandler</code>处理.<code>ChannelOutboundHandler</code>的方法将会被 <code>Channel</code> , <code>ChannelPipeline</code> ,以及<br><code>ChannelHandlerContext</code> 调用.<br><code>ChannelOutboundHandler</code> 可以按照需要<code>推迟操作</code> 或者 <code>推迟事件</code>, 这可以通过一些复杂的方法来处理请求.<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/outbound%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="ChannelOutboundHandler">  </p><h4 id="5-4-2-4-ChannelHandlerAadptor"><a href="#5-4-2-4-ChannelHandlerAadptor" class="headerlink" title="5.4.2.4 ChannelHandlerAadptor:"></a>5.4.2.4 <code>ChannelHandlerAadptor</code>:</h4><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/adaptor%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="ChannelHandlerAdaptor"><br>说明:  </p><ul><li><code>ChannelInboundHandlerAdapter</code> 和 <code>ChannelOutboundHandlerAdapter</code> 类分别提供了 <code>ChannelInboundHandler</code>和 <code>ChannelOutboundHandler</code><br>的基本实现。通过扩展抽象类 <code>ChannelHandlerAdapter</code>，它们获得了它们共同的超接口 ChannelHandler 的方法。  </li><li><code>ChannelHandlerAdapter</code> 还提供了实用方法 <code>isSharable()</code>。如果其对应的实现被标注为 <code>@Sharable</code>，那么这个方法将返回 <code>true</code>，表示它可以被添加到多个<br><code>ChannelPipeline</code>中.</li><li>在 <code>ChannelInboundHandlerAdapter</code> 和 <code>ChannelOutboundHandlerAdapter</code> 中所提供的方法体调用了其相关联的 <code>ChannelHandlerContext</code> 上的等效方法(<br>fireXXX())， 从而将事件转发到了 <code>ChannelPipeline</code> 中的下一个 <code>ChannelHandler</code> 中。</li></ul><h4 id="5-4-2-5-防止内存泄露"><a href="#5-4-2-5-防止内存泄露" class="headerlink" title="5.4.2.5 防止内存泄露:"></a>5.4.2.5 防止内存泄露:</h4><ul><li><p>每当通过调用 <code>ChannelInboundHandler.channelRead()</code>或者 <code>ChannelOutboundHandler.write()</code>方法来处理数据时，都需要保证不会出现资源泄漏(buf没有释放)。<br>Netty 使用引用计数来处理池化的 ByteBuf。所以在完全使用完某个 ByteBuf 后，调整其引用计数是很重要的。  </p></li><li><p>Netty提供了class ResourceLeakDetector ， 它将对你应用程序的缓冲区分配做大约 1%的采样来检测内存泄露。<br>Netty定义的4种<code>泄漏检测级别</code>:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B%E7%BA%A7%E5%88%AB.png" alt="netty内存检测级别"></p><blockquote><p>可以通过启动命令: <code>java -Dio.netty.leakDetectionLevel=ADVANCED</code> 来设置内存检测级别</p></blockquote><p>检测结果: <code>存在内存泄漏</code>如图<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C.png" alt="netty内存检测结果"></p></li></ul><h3 id="5-4-3-ChannelPipeline"><a href="#5-4-3-ChannelPipeline" class="headerlink" title="5.4.3 ChannelPipeline:"></a>5.4.3 ChannelPipeline:</h3><ul><li><p><code>ChannelPipeline</code> : 是一个流经Channel的入站和出站事件的ChannelHandler实例双向链表.</p></li><li><p><code>ChannelPipeline</code>在<code>Channel</code>创建的时候,就会分配给<code>Channel</code>并与之关联,直到<code>Channel</code>关闭.在<code>Channel</code>整个生命周期中,<code>ChannelPipeline</code>都是唯一与之绑定的,<br>既不能 <code>新增pipeline</code>也不能<code>分离pipeline</code>.  </p></li><li><p>根据事件的类型,事件将会被 <code>ChannelInboundHandler</code>或者<code>ChannelOutboundHandler</code>处理.<code>ChannelHandler</code>之间通过上下文对象<code>ChannelHandlerContext</code>交互.</p></li><li><p><code>ChannelHandlerContext</code>可以让<code>ChannelHandler</code>之间进行交互,也可以动态的修改 <code>ChannelPipeline</code>中 handler的顺序.</p></li><li><p>入站口总是 <code>处理入站事件</code>的 <code>ChannelInboundHandler</code>(即链表的head总是指向<code>能够</code>处理入站事件的处理器),出站口总是 <code>处理出站事件</code>的<code>ChannelOutboundHandler</code>(即<br>链表的tail总是指向<code>能够</code>处理出站事件的处理器)</p></li><li><p><code>ChannelHandler</code>在<code>ChannelPipeline</code>执行顺序是根据<code>handler</code>被加入到双向链表中的顺序而决定的</p><blockquote><p>一个处理器,可能同时实现 <code>ChannelInboundHandler</code> 和 <code>ChannelOutboundHandler</code>.在<code>Netty</code>中事件流经pipeline的时候通过标志位判断当前处理器能不能处理该事件,直到找到一个<br>能够处理该事件的handler为止.</p></blockquote></li></ul><h4 id="5-4-3-1-获取pipeline"><a href="#5-4-3-1-获取pipeline" class="headerlink" title="5.4.3.1 获取pipeline:"></a>5.4.3.1 获取pipeline:</h4><ul><li>通过Channel获取</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>clientGroup<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>        <span class="token comment">// 这里实现的是中途断线重连,断线换成netty术语就是channel不活跃了        .handler(new ChannelInitializer&lt;SocketChannel&gt;() {            @Override            protected void initChannel(SocketChannel ch) {                // ch.pipeline就是获取pipeline                ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {                    // channel在运行过程中中断,就会触发这个(channelInactive)方法,然后通过这个方法去重新连接                    @Override                    public void channelInactive(ChannelHandlerContext ctx) throws Exception {                        ctx.channel().eventLoop().schedule(()-&gt; doConnect(),2, TimeUnit.SECONDS);                    }                });            }        });</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>通过ChannelHandlerContext获取: </li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handlerAdded</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">Channel</span> curChannel <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// 获取pipeline        ChannelPipeline pipeline = ctx.pipeline();    }</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-4-3-2-处理ChannelPipeline中的handler"><a href="#5-4-3-2-处理ChannelPipeline中的handler" class="headerlink" title="5.4.3.2 处理ChannelPipeline中的handler:"></a>5.4.3.2 处理ChannelPipeline中的handler:</h4><ol><li><code>ChannelPipeline</code>的修改,实际上是修改双向链表上的handler,<code>ChannelPipeline</code>提供了一些对handler进行crud的方法:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E4%BF%AE%E6%94%B9pipeline%E4%B8%AD%E7%9A%84handler.png" alt="修改pipeline中ChannelHandler">  </li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ChannelPipeline</span> pipeline <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token comment">// 通过channel或者channelHandlerContext可以获取pipelineFirstHandler firstHandler = new FirstHandler(); pipeline.addLast("handler1", firstHandler); // 加入pipeline.addFirst("handler2", new SecondHandler()); 加入pipeline.addLast("handler3", new ThirdHandler()); 加入        // 此时pipeline中的顺序为 handler2 -&gt; handler1 -&gt; handler3...pipeline.remove("handler3");pipeline.remove(firstHandler);pipeline.replace("handler2", "handler4", new ForthHandler());// 此时pipeline中仅剩 handler4</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>由于整个pipeline中的channelHandler都是由与channel绑定的eventLoop来执行的,所以如果要在handler中使用阻塞api,为了不降低整体的I/O性能,在<code>添加handler</code>的时候,<br>可以使用pipeline中带有EventExecutorGroup的add()方法,<code>将handler交给ExecutorGroup中的线程去执行而不是有eventLoop线程执行</code>.</p><ol start="2"><li>访问handler:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E8%AE%BF%E9%97%AEhandler.png" alt="访问handler">  </li></ol></blockquote><h4 id="5-4-3-3-事件的传递"><a href="#5-4-3-3-事件的传递" class="headerlink" title="5.4.3.3 事件的传递:"></a>5.4.3.3 事件的传递:</h4><p><code>入站操作</code>:  实际上就是通知pipeline中下一个handler调用对应的接口:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/ChannelPipeline%E4%BC%A0%E9%80%92%E4%BA%8B%E4%BB%B6.png" alt="访问handler"></p><blockquote><p>调用channel或者pipeline对象的上述方法,会将整个事件沿着pipeline进行传播,但是通过handlerContext中的上述方法只会将事件传递给pipeline中下一个能够处理该事件的handler.</p></blockquote><p><code>出站操作</code>:  许多方法会造成底层套接字上发生一些列的动作<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/pipeline%E7%9A%84%E5%87%BA%E7%AB%99%E6%93%8D%E4%BD%9C.png" alt="访问handler"></p><h3 id="5-4-4-ChannelHandlerContext"><a href="#5-4-4-ChannelHandlerContext" class="headerlink" title="5.4.4 ChannelHandlerContext:"></a>5.4.4 ChannelHandlerContext:</h3><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/context%E4%B8%8Ehandler%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="访问handler"></p><ul><li><p><code>ChannelHandlerContext</code>代表 <code>handler</code> 和 <code>pipeline</code>之间的关联关系,只要有 <code>handler</code>分配到<code>pipeline</code>中来,就创建一个<code>context</code>与<code>handler关联</code>.</p></li><li><p><code>ChannelHandlerContext</code>主要作用是 用来与<code>context</code>关联的<code>handler</code>和其他<code>同一个pipeline中的handler</code>之间的交互 — 将消息传递给下一个能够处理该消息的handler</p></li><li><p><code>ChannelHandlerContext</code>与<code>handler</code>的关联关系是永远不会改变的,缓存Context的引用是线程安全的.</p></li><li><p><code>ChannelHandlerContext</code>常用方法总结:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/context%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="context常用方法"></p></li><li><p><code>ChannelHandlerContext</code>与其他用同名方法的组件相比,产生的事件流更短,可以利用这个特性来获取最大的性能,<code>特性使用场景如下:</code></p><ul><li>为了减少将事件传经对它不感兴趣的handler所带来的开销</li><li>为了避免将事件传经那些可能会对他感兴趣的handler</li></ul></li><li><p><code>ChannelHandlerContext</code>只能于一个handler绑定,但是handler可以绑定多个context实例.</p><ul><li>正确示例: </li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@sharable</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SharableHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span><span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> meg<span class="token punctuation">)</span><span class="token punctuation">{</span>             ctx<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>             <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>错误示例:</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@sharable</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SharableHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> meg<span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token comment">// 对共享资源不保证线程安全的修改操作,会导致问题            count++;            ctx.fireChannelRead(msg);        }             }</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>handler必须添加@Shareble注解,并且handler必须要是线程安全的.</p></blockquote></li><li><p><code>ChannelHandlerContext</code>特殊用法:<br>保存<code>ChannelHandlerContext</code>在其他channel中使用或者以供稍后使用,完成一些特殊的操作</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WriteHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelHandlerAdapter</span> <span class="token punctuation">{</span>         <span class="token keyword">private</span> <span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handlerAdded</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>ctx <span class="token operator">=</span> ctx<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ctx<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="5-4-5-异常处理"><a href="#5-4-5-异常处理" class="headerlink" title="5.4.5 异常处理:"></a>5.4.5 异常处理:</h3><h4 id="5-4-5-1-入站异常处理"><a href="#5-4-5-1-入站异常处理" class="headerlink" title="5.4.5.1 入站异常处理:"></a>5.4.5.1 入站异常处理:</h4><p>如果在处理入站事件的过程中,发生了异常,那么异常将会从当前handler开始在pipeline中的<code>InboundHandler</code>传递下去.</p><ul><li><p>实现异常处理: 通过重写exceptionCaught方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EchoServerHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>            cause<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ctx<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>注意事项:  </p><ol><li>默认的exceptionCaught()方法只是简单的将当前异常转发给了pipeline中的handler</li><li>如果异常到达了pipeline的尾部仍然没有处理,netty会在日志这种记录该异常为未处理异常, <code>通常为了所有异常都会被处理,pipeline的最后都会存在一个实现了示例代码的handler</code></li><li>通过重写exceptionCaught()来自定义自己的异常处理方法.  </li></ol></li></ul><h4 id="5-4-5-2-出站异常处理"><a href="#5-4-5-2-出站异常处理" class="headerlink" title="5.4.5.2 出站异常处理:"></a>5.4.5.2 出站异常处理:</h4><p>通过异步通知机制,来处理出站异常:  </p><ul><li><p>每个出站操作都会返回一个ChannelFuture.注册到ChannelFuture的ChannelFutureListener将在操作完成的时候通知该操作是否成功</p></li><li><p>几乎所有的ChannelOutboundHandler上的方法都会传入一个ChannelPromise的实例.channelPromise是channelFuture的子类,可以用于异步通知也可以用于立即通知的可写方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ChannelPromise</span> <span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">ChannelPromise</span> <span class="token function">setFailure</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>处理异常示例:<br>方法1: 通过向出站操作返回的ChannelFuture中添加具体的监听器</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ChannelFuture</span> future <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>someMessage<span class="token punctuation">)</span>    future<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChanelFutureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span><span class="token class-name">ChannelFuture</span> f<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                f<span class="token punctuation">.</span><span class="token function">cause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                f<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><font color="red"><strong>启动重连的示例</strong></font></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 注意这里一定不要调用sync()    ChannelFuture connectFuture = bootstrap.connect(new InetSocketAddress(remoteHost, port));    // 添加链接事件的监听器,当连接事件触发的时候就会调用监听器里面的operationComplete方法    connectFuture.addListener((ChannelFutureListener) future -&gt; {        if (future.isSuccess()){            System.out.println(" 连接成功........");        }else{            System.out.println(String.format(" 连接失败,正在尝试重连 ..... 当前为 第 %s 次重连",retryTime.intValue()));            future.channel().eventLoop().schedule(()-&gt;doConnect(),1,TimeUnit.SECONDS);        }    });</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法2: 给出站操作的参数 promise添加listener.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutboundExceptionHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelOutboundHandlerAdapter</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>            promise<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelFutureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span><span class="token class-name">ChannelFuture</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        f<span class="token punctuation">.</span><span class="token function">cause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        f<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                 <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>两种方法如何选择: 不同出站事件的细节异常处理使用<code>方法一</code>更好, <code>方法二</code>更适合于一般的异常处理</p></blockquote></li></ul><h2 id="5-5-EventLoopGroup和EventLoop"><a href="#5-5-EventLoopGroup和EventLoop" class="headerlink" title="5.5 EventLoopGroup和EventLoop:"></a>5.5 EventLoopGroup和EventLoop:</h2><p><strong>继承结构</strong><br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/NioEventLoop%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" alt="NioEventLoop继承结构">  </p><h3 id="5-5-1-EventLoop"><a href="#5-5-1-EventLoop" class="headerlink" title="5.5.1 EventLoop:"></a>5.5.1 EventLoop:</h3><h4 id="5-5-1-1-概述"><a href="#5-5-1-1-概述" class="headerlink" title="5.5.1.1 概述:"></a>5.5.1.1 概述:</h4><p>运行任务来处理在连接的生命周期内发生的事件是任何网络框架的基本功能.这种功能在编程上的构造称为<code>事件循环</code>,Netty使用<code>EventLoop</code>表示.<br>事件循环的大致思路:  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 只要线程没有被关闭,就一直循环执行    while (!terminated) {        // 阻塞获取就绪事件        List&lt;Runnable&gt; readyEvents = blockUntilEventsReady();        // 遍历就绪事件,逐一执行        for (Runnable event : readEvents) {            ev.run();        }    }</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>在Netty所提供的线程模型中 <code>EventLoop</code> 将由一个永远不会改变的 线程 驱动(即由这个线程来处理<code>EventLoop</code>中就绪的事件).   </li><li>任务可以直接提交给<code>EventLoop的实现类</code>,根据具体需求直接直接执行或者调度执行.  <code>EventLoop</code>继承了JUC中的延迟任务线程池<code>ScheduledExecutorService</code>,但是<br>只定义了一个用来返回 <code>EventLoop</code>属于哪一个<code>EventLoopGroup</code>的方法(<code>parent()</code>)</li><li>根据配置和cpu核心数量不同,可能会创建多个EventLoop实例来优化资源的使用率,当个 <code>EventLoop</code>可以被分配给多个 <code>Channel</code>.  </li></ol><h4 id="5-5-1-2-I-O事件处理"><a href="#5-5-1-2-I-O事件处理" class="headerlink" title="5.5.1.2 I/O事件处理:"></a>5.5.1.2 I/O事件处理:</h4><ol><li><p>Netty3 中的I/O事件处理:</p><ul><li>Netty3 中使用的线程模型只保证了入站事件会在I/O线程(Netty4中的<code>EventLoop</code>)中执行.但是出站事件都是由调用线程处理,该线程可以能是<code>EventLoop</code>或者其他线程,这样一来<br>handler中执行的代码就有可能被多个线程并发执行,就需要在handler中处理线程安全问题.<br>比如: 在不同的线程中调用Channel.write(),同一个Channel中同时触发了出站事件.</li><li>Netty3 模型中如果出站事件触发了入站事件,可能造成一次额外的线程上下文切换.<br>比如: Channel.write()方法造成异常的时候,需要生成并触发一个exceptionCaught事件.在Netty3 模型中 exceptionCaught是一个入站事件,需要在调用线程中执行,然后将事件<br>交给I/O线程处理,造成依次不必要的线程上下文切换.</li></ul></li><li><p>Netty4 中的I/O事件处理:  </p><ul><li>所有的I/O操作和事件都交给 驱动<code>EventLoop</code>永远不会改变的线程处理.解决了 <code>handler需要注意线程安全的问题</code> 和 <code>不必要的线程切换</code></li></ul></li></ol><h4 id="5-5-1-3-I-O事件处理"><a href="#5-5-1-3-I-O事件处理" class="headerlink" title="5.5.1.3 I/O事件处理:"></a>5.5.1.3 I/O事件处理:</h4><ol><li><p>JDK的任务调度API:  通过 <code>ScheduledExecutorService</code>来完成</p></li><li><p><code>EventLoop</code>来调度任务:  </p><ul><li>延迟多少时间后执行一次:  </li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Channel</span> ch <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token comment">// 60 秒之后执行一次,之后不再执行     ScheduledFuture&lt;?&gt; future = ch.eventLoop().schedule( new Runnable() {             @Override             public void run() {                 System.out.println("60 seconds later");             }     }, 60, TimeUnit.SECONDS);</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>定时任务:  </li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Channel</span> ch <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token comment">// 60秒后,执行第一次,之后每60秒执行一次.     ScheduledFuture&lt;?&gt; future = ch.eventLoop().scheduleAtFixedRate(         new Runnable() {             @Override             public void run() {             System.out.println("Run every 60 seconds");         }     }, 60, 60, TimeUnit.Seconds);</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>任务的取消: 通过future来取消或者检查任务的执行状态  </li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Some other code that runs...     // 任务的取消     boolean mayInterruptIfRunning = false;     future.cancel(mayInterruptIfRunning);</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>说明:</p><ol><li>netty的任务调度是否立即执行是取决于调用任务的线程是否是 与<code>EventLoop</code>绑定的线程,即<code>负责处理</code>该channel事件的线程.如果是那么将会立即执行,如果不是那么将会把任务放入延时队列中,<br>在 <code>EventLoop</code> 下次处理它的事件的时候,会去处理这些任务.<code>保证了任务不会被多个线程同时执行</code>.  </li><li><code>EventLoop</code>的任务队列,是 <code>EventLoop独有的</code>,独立于其他EventLoop.</li><li>调度任务执行的逻辑:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/../../../../MyInterviewSummary/docs/_media/chapter13_Netty/5_netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/eventLoop%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%9A%84%E9%80%BB%E8%BE%91.png" alt="调度任务执行逻辑"></li></ol></li></ol><h3 id="5-5-2-EventLoopGroup"><a href="#5-5-2-EventLoopGroup" class="headerlink" title="5.5.2 EventLoopGroup:"></a>5.5.2 EventLoopGroup:</h3><p>从上面的继承结构图中可以看出 <code>EventLoopGroup</code>实际上就是一个 <code>ScheduledExecutorService</code> 延时任务线程池.<br><code>EventLoopGroup</code>主要功能:  </p><ol><li>作为一个线程池管理 <code>EventLoop实例</code></li><li>将channel注册到eventLoop的selector上</li><li></li></ol><h2 id="5-6-Future和Promise"><a href="#5-6-Future和Promise" class="headerlink" title="5.6 Future和Promise:"></a>5.6 Future和Promise:</h2><p>TODO</p>]]></content>
      
      
      <categories>
          
          <category> netty实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4 Netty线程模型</title>
      <link href="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="4-1-前置知识"><a href="#4-1-前置知识" class="headerlink" title="4.1 前置知识:"></a>4.1 前置知识:</h2><h3 id="4-1-1-中断简介"><a href="#4-1-1-中断简介" class="headerlink" title="4.1.1 中断简介:"></a>4.1.1 中断简介:</h3><ol><li><p>引导故事: 小明在打游戏的时候饿了,于是点了外卖,然后一边打游戏一边等外卖.过了一会外卖到了,给小明打电话让他下去取外卖,小明将正在玩儿的3A游戏存档,然后去取外卖, 拿到外卖后开始吃外卖.</p><ul><li>外卖小哥给小明打电话让他下去取外卖, 就是操作系统中的 <code>中断请求</code></li><li>小明接到电话后,<code>停下打游戏,将游戏存档</code>, 就是在执行 <code>中断处理程序</code></li><li>小明在等外卖的时候,如果把 <code>吃外卖</code> 看做是一个进程, 此时 <code>吃外卖</code>进程就是处于 <code>休眠状态</code>; 拿到外卖之后,开始吃外卖,此时 <code>吃外卖</code>进程就处于 <code>运行状态</code></li></ul></li><li><p>什么是中断:</p><ul><li><code>中断</code>: 指处理器在处理程序运行过程中出现的紧急事件的整个过程.程序运行过程中,系统外部,系统内部或者现行程序若出现紧急事件,处理器立即中止现行程序的运行, 自动转入响应紧急事件的程序(<code>中断处理程序</code>)<br>,在处理完成后,在返回原来的程序继续运行.这整个过程就是 <code>中断</code></li><li><code>硬件中断</code>: 由与系统相连的外设(键盘,鼠标,硬盘,网卡等)自动产生的.每个设备或者设备集都有其自己的IRQ(中断请求),基于IRQ,cpu可以将相应的中断请求分发到具 体的硬件设备上.<br>意义: 硬件中断是一个 <code>异步信号</code>,表明需要注意,或者改变正在执行的一个同步事件</li><li><code>软件中断</code>: 由当前运行程序产生,通常是一些对I/O的请求,软中断仅仅于内核联系,而内核主要负责对需要运行的任何其他进程进行调度.<code>软中断不会直接中断cpu,也只 有正待运行的代码(进程)才会产生软中断</code><br>.软中断是一种需要内核为正在运行的进程去做一些事情(比如网络I/O)的请求.有一个特殊的软中断<code>yield调用</code>,他的作用是请 求内核调度器去查看是否有其他的进程可以运行.</li></ul></li><li><p>中断是如何工作的: <code>以网卡为例子</code><br>当网卡接收到网络中的数据后,会通过DMA技术将数据拷贝到内存中对应的数据缓冲区,<code>假设此时cpu正在执行进程c</code>,网卡在数据拷贝完成之后,会向cpu发起中断请求,cpu接<br>接收到中断请求后,将正在执行中的进程c相关信息保存到 <code>进程描述符</code> 中,然后从用户态切换到用户态中,然后开始执行网卡的中断程序,待中断程序执行完成之后,通过之前 保存的进程描述符恢复进程c的运行</p></li></ol><h3 id="4-1-2-I-O多路复用技术"><a href="#4-1-2-I-O多路复用技术" class="headerlink" title="4.1.2 I/O多路复用技术:"></a>4.1.2 I/O多路复用技术:</h3><p>I/O多路复用简单来讲就是使用一个线程去处理多个I/O请求,在不同的时间段对不同的i/o请求做出响应.下面是两种操作系统实现I/O多路复用的原理:</p><h4 id="4-1-2-1-select-函数"><a href="#4-1-2-1-select-函数" class="headerlink" title="4.1.2.1 select()函数:"></a>4.1.2.1 select()函数:</h4><ul><li><p>本质: 用三个bitmap分别表示读事件,写事件,异常事件,在bitmap中,下标表示socket对应的文件描述符(唯一对应),元素值表示是否关心该bitmap代表的事件,<code>1表示关 心,0表示不关心</code><br>,然后在操作系统准备好数据之后,直接改写具体事件的bitmap上的元素值,<code>1表示该位置对应的文件描述符需要的数据准备好了,0表示没有.</code><br>在程序运行中会不断循环的去调用select函数,每调用一次select函数就会去遍历bitmap,数据准备好之后也会去遍历bitmap然后直接修改.然后通过 <code>FD_ISSET</code>方法去 判断是否有数据准备好了.</p></li><li><p>select函数代码:</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;sys/select.h&gt;int select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset, struct timeval *timeout)  // 调用的时候,示例: 表示只关心读事件select(max + 1, &amp;readset, null, null, null);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明:</p><ul><li><code>maxfdp1</code>: 表示bitmap最大有效位数,即<code>maxfdp1</code>之后都是没有数据的,减少不必要的遍历</li><li><code>timeout</code>: 表示本次select函数等待的时间<ul><li>timeout == null: 一直阻塞</li><li>timeout-&gt;tv_sec == 0 || timeout-&gt;tv_usec = 0: 不阻塞直接返回</li><li>timeout-&gt;tv_sec != 0 || timeout-&gt;tv_usec != 0: 阻塞指定时间</li></ul></li><li><code>fd_set</code>: 就是一个bitmap,最大长度为1024,用类型表示某个事件,然后将socket对应的文件描述符映射到<code>fd_set</code>上面,值为1表示对 <code>fd_set</code>代表的事件关心<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/select%E7%9A%84bitmap%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="bitmap示意图"><ul><li>操作这三个 <code>fd_set</code>的方法:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/%E6%93%8D%E4%BD%9Cbitmap%E7%9A%84%E6%96%B9%E6%B3%95.png" alt="操作fd_set"></li></ul></li></ul></li><li><p>select函数的优缺点:</p><ul><li>优点: 通过一次系统调用将所有文件描述符传递给内核,内核进行遍历,这种遍历减少了BIO的措辞系统调用的开销</li><li>缺点:<ul><li>由于socket对应描述符是否对该事件关心,该事件是否准备就绪,都是在同一个bitmap上直接进行操作,所以导致每次select循环都需要重新设置文件描述符关心的 事件,然后内核设置事件是否准备就绪,造成了一些重复操作</li><li>每一次select都会对bitmap进行遍历</li><li>每次调用select函数都需要将bitmap在内核态和用户态之间来回复制</li></ul></li></ul></li></ul><h4 id="4-1-2-2-epoll函数"><a href="#4-1-2-2-epoll函数" class="headerlink" title="4.1.2.2 epoll函数:"></a>4.1.2.2 epoll函数:</h4><ul><li><p>本质: 使用一个 epoll空间结构(有一个文件描述符来表示这个空间)来管理socket对应的文件描述符,在epoll空间中 有一个<code>红黑树</code>,用于存放文件描述 符以及其关心的事件, 还有一个<code>链表</code><br>用于存放关心事件准备就绪的文件描述符.每一次事件轮询都是从这个链表这种获取准备就绪的事件描述符</p></li><li><p>epoll大致流程:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/epoll%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B.png" alt="epoll大致流程"></p></li><li><p>epoll 相关函数:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/epoll%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0.png" alt="epoll相关函数"><br>说明:</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数会在内存中开辟一块空间(这宗空间可能有很多个),通过一个文件描述符来引用这块地址,并将该文件描述符返回给调用方.<br>size表示 该空间一共能管理多少个文件描述符</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数是对epoll空间进行管理的函数,对文件描述感兴趣的事件进行注册.<br>该函数是一个 <code>非阻塞函数</code>,作用是对epoll空间中fd信息进行crud<br><code>与select不同的是</code>: select函数在调用的时候需要指定文件描述符和关心事件,epoll则是将文件描述符关心的事件注册到epoll空间内.<br>参数:  </p><ul><li><code>epfd</code>: epoll空间的文件描述符,用于定位epoll空间</li><li><code>op</code>: 表示当前请求的类型,值通常是由三个宏定义<ul><li><code>EPOLL_CTL_ADD</code>: 注册新的fd到epfd中</li><li><code>EPOLL_CTL_MOD</code>: 修改已经注册的fd监听事件</li><li><code>EPOLL_CTL_DEL</code>: 删除epfd中某个fd</li></ul></li><li><code>fd</code>: 需要操作的fd.通常是socket_fd</li><li><code>event</code>: 参数<code>fd</code>关注的事件<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/event%E7%BB%93%E6%9E%84%E4%BD%93.png" alt="event结构体"><br>events属性是以下几个类型的集合:<br><code>EPOLLIN</code>(可读),<code>EPOLLOUT</code>(可写),<code>EPOLLPRI</code>(),<code>EPOLLHUB</code>(挂断),<code>EPOLLET</code>(边缘触发),<code>EPOLLONESHOT</code>(只监听一次, 事件触发之后会清除该fd)    </li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">,</span><span class="token keyword">int</span> maxevents<span class="token punctuation">,</span><span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数是用来获取数据,从就绪列表里面读取fd(也就是epoll大致流程图中的链表)<br>参数:  </p><ul><li><code>epfd</code>: epoll空间的文件描述符</li><li><code>events</code>: 关注的事件,是个数组,有数据的时候会将数据拷贝到这个数组里面去</li><li><code>maxevents</code>: 设置events数组的长度</li><li><code>timeout</code>: epoll_wait方法的时间<ul><li>timeout == 0 : 表示epoll_wait方法非阻塞立即返回结果</li><li>timeout == -1 : 一直阻塞,直到有数据</li><li>timeout &gt; 0: 如果没有数据,epoll_wait会阻塞timeout时间,这期间有数据就返回</li></ul></li></ul></li><li><p>epoll的工作模式:</p><ul><li><code>LT(水平触发)</code>: 事件准备就绪之后,用户可以选择处理或者不处理数据,如果本次调用未处理,操作系统会保留这个数据,在下次调用epoll_wait函数的时候仍然会将数据打包返回 </li><li><code>ET(边缘触发)</code>: 事件准备就绪后,无论用户处不处理数据,操作系统都会将数据删除,而不是保留该数据</li></ul></li></ul><h2 id="4-2-常见线程模型概述"><a href="#4-2-常见线程模型概述" class="headerlink" title="4.2 常见线程模型概述:"></a>4.2 常见线程模型概述:</h2><h3 id="4-1-传统阻塞I-O线程模型"><a href="#4-1-传统阻塞I-O线程模型" class="headerlink" title="4.1 传统阻塞I/O线程模型:"></a>4.1 传统阻塞I/O线程模型:</h3><p>一句话总结: [一个线程处理整个I/0请求流程]<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/%E4%BC%A0%E7%BB%9Fio%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="传统i/o单线程模型"><br>模型特点:</p><ul><li>采用阻塞i/o模式获取输入数据</li><li>每个连接都需要一个独立的线程,完成数据的输入,业务处理,结果数据的返回</li></ul><p>问题:</p><ul><li>并发数量很大的话,创建的线程过多,容易造成服务端资源压力</li><li>由于采用的是阻塞式i/o,在没有数据可读的时候,线程会阻塞在read方法中,导致线程资源浪费</li></ul><h3 id="4-2-Reactor模型-别名-反应器模型-分发器模型-通知者模型"><a href="#4-2-Reactor模型-别名-反应器模型-分发器模型-通知者模型" class="headerlink" title="4.2 Reactor模型: 别名(反应器模型,分发器模型,通知者模型)"></a>4.2 Reactor模型: 别名(反应器模型,分发器模型,通知者模型)</h3><h4 id="4-2-1-Reactor模型简介"><a href="#4-2-1-Reactor模型简介" class="headerlink" title="4.2.1 Reactor模型简介:"></a>4.2.1 Reactor模型简介:</h4><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/reactor%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0.png" alt="reactor模型"></p><ol><li>核心思想: i/o复用 + 线程复用<ul><li><code>i/o复用</code>: 多个连接共用一个阻塞对象,应用程序只需要在一个阻塞对象(一个线程)等待,不需要阻塞等待所有连接.当某个连接有数据可以处理的时候(事件准备就绪),操作系统通知应用程序, 线程从阻塞状态返回,开始进行业务处理.</li><li><code>线程复用</code>: 不再为每个连接都创建独立的线程,使用一个专门的线程来处理客户端的连接请求,连接成功后的业务处理任务分配给线程池中的线程来处理,一个线程可以处理多个连接的业务</li></ul></li><li>核心组件: reactor(分发器) + handler(打工仔)<ul><li><code>reactor</code>: reactor在一个单独的线程中运行,负责监听客户端的连接请求,以及任务的分发,将任务分配给适当的处理线程来对i/o事件做出反应.好比 <code>产品经理</code>. </li><li><code>handler</code>: handler是实际的业务处理人,处理具体的i/o事件,reactor通过调度适当的处理线程来响应i/o事件. 好比 <code>开发人员</code>.</li></ul></li><li>说明:<ul><li>服务端程序处理传入的多个请求,并将他们分发到相应的处理线程,dispatcher模式别名的由来 - reactor模式,通过一个或者多个输入同时传递给服务处理的模式(基于事件驱动)</li><li>reactor模式使用i/o复用监听事件,收到事件之后分发给相应的处理线程,这就是网络服务高并发处理的关键</li></ul></li></ol><h4 id="4-2-2-Reactor模型的分类"><a href="#4-2-2-Reactor模型的分类" class="headerlink" title="4.2.2 Reactor模型的分类:"></a>4.2.2 Reactor模型的分类:</h4><p>按照reactor的数量和处理资源池线程数量的不同分为以下几种</p><h4 id="4-2-2-1-单Reactor单线程"><a href="#4-2-2-1-单Reactor单线程" class="headerlink" title="4.2.2.1 单Reactor单线程:"></a>4.2.2.1 单Reactor单线程:</h4><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B.png" alt="单Reactor单线程"></p><ol><li>说明:<ul><li><code>reactor</code>通过<code>select</code>监听客户端请求事件,然后通过<code>dispatch</code>将事件分发</li><li><code>select</code>就是前面i/o复用模型介绍的标准网络api,通过<code>select</code>实现应用程序通过<code>一个阻塞对象(线程)监听多路连接请求</code></li><li>如果是<code>建立连接请求</code>事件,则由<code>acceptor</code>通过<code>accept</code>方法处理连接请求,然后创建一个<code>handler</code>对象处理连接完成之后的具体业务处理</li><li>如果不是 <code>建立连接请求</code>事件,则 <code>Reacotr</code>会分发调用<code>handler</code>来处理该事件并响应.</li><li><code>handler</code> 会完成 整套业务逻辑处理流程 (<code>read</code> -&gt; <code>业务处理逻辑</code> -&gt; <code>send</code>).</li></ul></li><li>优缺点:<ul><li>优点: 模型简单,没有多线程、进程通信、竞争的问题,全部都在一个线程中完成</li><li>缺点: 性能问题,只有一个线程,无法完全发挥多核 <code>cpu</code>的性能.<code>handler</code>在处理某个客户端连接的业务时,整个进程无法处理其他客户端连接的事件,容易造成性能瓶颈</li><li>缺点: 可靠性问题,线程以外终止,或者进入死循环,会导致整个系统通信模块无法使用,不能接收和处理外部消息,造成结点故障</li></ul></li><li>使用场景:<ul><li>客户端数量有限,业务处理非常快速,比如<code>Redis</code>在业务处理的<code>时间复杂度 O(1)</code> 的情况</li></ul></li><li>模型示例: 见NIO网络编程 <a href="../../../netty-demo/java-io/src/main/java/cn/pounds/nio/NioNetWorkServer.java">NIO复习</a></li></ol><h4 id="4-2-2-2-单Reactor多线程"><a href="#4-2-2-2-单Reactor多线程" class="headerlink" title="4.2.2.2 单Reactor多线程:"></a>4.2.2.2 单Reactor多线程:</h4><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="单Reactor多线程">  </p><ol><li><p>说明:  </p><ul><li><code>Reactor</code>通过<code>select</code>监听事件请求,完成i/o多路复用的目的,连接请求给<code>acceptor</code>,其他请求转发给<code>handler</code></li><li><code>handler</code>只进行 <code>read</code>和<code>send</code>操作,不进行业务处理,业务操作会分发给线程池中线程来处理,达到线程的复用</li><li>由 <code>worker</code> 线程池分配线程来进行业务处理,并将结果返回给<code>handler</code>,由 <code>handler</code>通过<code>send</code>方法返回结果给<code>dispatcher</code>.</li></ul></li><li><p>优缺点:  </p><ul><li>优点: 实现i/o复用 和 线程的复用,节约资源提高性能.</li><li>缺点: 多线程存在的问题他都有了, <code>reactor</code>处理所有的事件监听和响应,并且<code>reactor</code>是在单线程中运行的,高并发场景下可能会存在性能瓶颈</li></ul></li></ol><h4 id="4-2-2-3-主从Reactor多线程"><a href="#4-2-2-3-主从Reactor多线程" class="headerlink" title="4.2.2.3 主从Reactor多线程:"></a>4.2.2.3 主从Reactor多线程:</h4><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/%E5%A4%9AReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png" alt="多Reactor多线程"><br><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/%E5%A4%9AReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B1.png" alt="多Reactor多线程"></p><ol><li><p>说明:  </p><ul><li>主 <code>reactor</code>[即<code>mainReactor</code>]: 同样通过select监听有事件发生的i/o,收到事件之后,通过<code>Acceptor</code>处理<code>连接事件</code></li><li><code>Acceptor</code>处理完成<code>连接事件</code>后,<code>MainReactor</code>将连接分配给<code>SubReactor</code></li><li>从<code>reactor</code>[即<code>subReactor</code>]: 将连接加入到连接队列进行监听,并创建<code>handler</code>进行各种事件的处理  </li><li>当有新事件准备就绪时, <code>subReactor</code>就会调用对应<code>handler</code>处理  </li><li><code>handler</code>通过 <code>read方法</code>读取数据,分发给后面的 <code>worker</code>进行业务处理,并将结果返回给 <code>handker</code>  </li><li><code>handler</code>接收到相应之后,再通过<code>send方法</code>将结果返回给Client  </li><li><code>Reactor</code>主线程可以对应多个 <code>Reactor</code>子线程,即 <code>mainReactor</code>可以对应多个 <code>subReactor</code>  </li></ul></li><li><p>优缺点:  </p><ul><li>优点: 父线程与子线程的数据交互责任明确,父线程accept,子线程处理读写任务</li><li>优点: 数据交互简单,只需要传递原始数据,响应结果</li><li>缺点: 编程复杂度高</li></ul></li></ol><h2 id="4-3-netty线程模型"><a href="#4-3-netty线程模型" class="headerlink" title="4.3 netty线程模型:"></a>4.3 netty线程模型:</h2><ol><li><p>Netty在<code>主从Reactor多线程</code>模型的基础上,进行了一定的改动:<br>简单版:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%AE%80%E5%8D%95%E7%89%88.png" alt="netty线程模型"><br>说明:</p><ul><li><code>BossGroup</code> 线程维护 <code>Selector</code>，只关注 <code>Accept</code></li><li>当接收到 <code>Accept</code> 事件，获取到对应的 <code>SocketChannel</code>，封装成 <code>NIOSocketChannel</code> 并注册到 <code>Worker 线程（事件循环）</code>，并进行维护</li><li>当 <code>Worker</code> 线程监听到 <code>Selector</code> 中通道发生自己感兴趣的事件后，就进行处理（就由 handler），注意 <code>handler</code> 已经加入到通道</li></ul><p>进阶版:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%BF%9B%E9%98%B6%E7%89%88.png" alt="netty线程模型"></p><p>完整版:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="netty线程模型"><br><strong><font color="#ff4500">EventLoop和channel、线程之间的对应关系: </font></strong><br><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/EventLoop%E3%80%81channal%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB.png" alt="loop,channel,thread"><br><strong><font color="#ff4500">i/o操作大致执行原理: </font></strong><br><img src="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86.png" alt="大致执行原理"><br>说明:</p><ol><li><code>Netty</code>抽象出两组线程池 <code>BossGroup专门负责客户端连接</code>和<code>WorkerGroup专门负责网络的读写</code></li><li><code>BossGroup</code>和<code>WorkerGroup</code>的类型 都是<code>NioEventLoopGroup</code>.<ul><li><code>NioEventLoop</code>表示一个不断循环执行处理任务的线程,每个<code>NioEventLoop</code>都关联了一个<code>Selector</code>,用于监听注册在<code>NioEventLoop</code>上的网络通信</li><li><code>NioEventLoopGroup</code>(事件循环组,其实是个<code>线程池</code>),里面包含很多 <code>NioEventLoop</code>(事件循环,<code>唯一</code>绑定一个<code>线程</code>)</li></ul></li><li>每个 <code>BossNioEventLoop</code>循环执行的步骤有3步:<ul><li>轮询<code>accept</code>事件</li><li>处理 <code>accept</code>事件,与 <code>client</code>建立连接,生成 <code>NioSocketChannel</code>,并将其注册到 <code>workerNioEventLoop</code>的<code>selector</code>上</li><li>处理任务队列任务, 即 <code>runAllTasks</code></li></ul></li><li>每个 <code>worker NioEventLoop</code>循环执行的步骤:<ul><li>轮询 read，write 事件</li><li>处理 I/O 事件，即 read，write 事件，在对应 NioSocketChannel 处理</li><li>处理任务队列的任务，即 runAllTasks</li></ul></li><li>每个 <code>worker NioEventloop</code>处理业务的时候,会使用<code>pipeline</code>(管道),[管道实际上是一个处理器链,上面维护了许多i/o处理器]</li></ol></li></ol><h2 id="4-4-Netty快速入门实例"><a href="#4-4-Netty快速入门实例" class="headerlink" title="4.4 Netty快速入门实例:"></a>4.4 Netty快速入门实例:</h2><ol><li><p>实例要求：使用 IDEA 创建 Netty 项目</p><ul><li>Netty 服务器在 6668 端口监听，客户端能发送消息给服务器”hello,服务器~”</li><li>服务器可以回复消息给客户端”hello,客户端~”</li><li>目的：对 Netty 线程模型有一个初步认识，便于理解 Netty 模型理论</li><li>看老师代码演示 5.1 编写服务端 5.2 编写客户端 5.3 对 netty 程序进行分析，看看 netty 模型特点 说明：创建 Maven 项目，并引入 Netty 包  </li></ul></li></ol><p>代码如下:  </p><ul><li>服务端</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>pounds<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>simple</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>bootstrap<span class="token punctuation">.</span></span><span class="token class-name">ServerBootstrap</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span></span><span class="token class-name">ChannelFuture</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span></span><span class="token class-name">ChannelFutureListener</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span></span><span class="token class-name">ChannelInitializer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span></span><span class="token class-name">ChannelOption</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>socket<span class="token punctuation">.</span></span><span class="token class-name">SocketChannel</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>socket<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">;</span><span class="token comment">/** * @Date 2021/5/9 18:08 * @Author by pounds * @Description netty入门教程: * 1. 服务端端口号 6668, 接受客户端的消息,并返回消息"hello,客户端" * 2. 客户端连接服务端,发送消息"hello,服务端" */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NettyServer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1. 创建两个NioEventLoopGroup,分别作为Boss Group 和  Worker Group</span>        <span class="token comment">// 两个Group的实际子线程NioEventLoop的个数为: 实际核心数 * 2</span>        <span class="token class-name">NioEventLoopGroup</span> bossGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">NioEventLoopGroup</span> workerGroup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment">// 2.创建netty服务器的启动对象,主要是用来配置参数</span>            <span class="token class-name">ServerBootstrap</span> bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 3. 配置参数</span>            bootstrap                    <span class="token comment">// 设置parent group,child group</span>                    <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>bossGroup<span class="token punctuation">,</span>workerGroup<span class="token punctuation">)</span>                    <span class="token comment">// 设置服务端通道,如同Nio中的serverSocketChannel</span>                    <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                    <span class="token comment">// 设置服务端channel等待连接队列的容量</span>                    <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span>SO_BACKLOG<span class="token punctuation">,</span><span class="token number">128</span><span class="token punctuation">)</span>                    <span class="token comment">// 设置保持活动连接状态,因该是设置workerGroup的属性</span>                    <span class="token punctuation">.</span><span class="token function">childOption</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span>SO_KEEPALIVE<span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span>                    <span class="token comment">// 设置真正执行业务逻辑的handler</span>                    <span class="token punctuation">.</span><span class="token function">childHandler</span><span class="token punctuation">(</span>                            <span class="token comment">// 创建通道初始化对象,初始化的是socketChannel</span>                            <span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">/**                         * 给pipeline设置一个handler                         * @param ch --- SocketChannel                         * @throws Exception                         */</span>                        <span class="token annotation punctuation">@Override</span>                        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>                            <span class="token comment">// 入门案例的演示</span>                            <span class="token comment">// ch.pipeline().addLast(new NettyServerHandler());</span>                            <span class="token comment">// task使用方式的演示</span>                            ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NettyServerTaskQueueHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" ..........  server is ready ............"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 4. 将服务器绑定一个端口,并同步监听:  真正的启动服务器操作</span>            <span class="token class-name">ChannelFuture</span> channelFuture <span class="token operator">=</span> bootstrap<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token number">6668</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// future-listener机制举个栗子,给端口绑定事件添加一个监听器:</span>            <span class="token comment">// 操作(端口绑定事件)完成触发</span>            channelFuture<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ChannelFutureListener</span><span class="token punctuation">)</span> future <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>channelFuture<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"绑定成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"绑定端口失败."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 5.  监听服务器channel关闭事件</span>            channelFuture<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>            bossGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            workerGroup<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>pounds<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>simple</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>buffer<span class="token punctuation">.</span></span><span class="token class-name">ByteBuf</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>buffer<span class="token punctuation">.</span></span><span class="token class-name">Unpooled</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span></span><span class="token class-name">ChannelHandlerContext</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span></span><span class="token class-name">ChannelInboundHandlerAdapter</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">CharsetUtil</span><span class="token punctuation">;</span><span class="token comment">/** * @Date 2021/5/9 18:47 * @Author by pounds * @Description netty服务器端真正业务处理类 * 几点说明: * 1. 我们自定义的handler 需要继承netty规定好的某个HandlerAdapter,比如下面继承这个 * 2. 这是自定义handler的方式,也可以使用netty自带的handler * 3. 需要重写一些方法 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NettyServerHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * handler的read 方法,处理read事件的方法     * @param ctx ---  上下文对象,包含 pipeline,通道,地址     * @param msg --- 客户端的数据     * @throws Exception     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"server ctx= "</span> <span class="token operator">+</span> ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 将msg转换成netty提供的 ByteBuf ,功能与nio ByteBuffer差不多,但是性能更好</span>        <span class="token class-name">ByteBuf</span> byteBuf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuf</span><span class="token punctuation">)</span> msg<span class="token punctuation">;</span>        <span class="token comment">// 读取数据展示,附带解码流程</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"客户端发送消息是: "</span><span class="token operator">+</span>byteBuf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token class-name">CharsetUtil</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"客户端地址: "</span><span class="token operator">+</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * handler的write方法,会在数据读完之后触发,也就是read处理完之后触发     * @param ctx --- 上下文对象     * @throws Exception     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelReadComplete</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token comment">// 写入缓存并发送出去,返回的数据需要进行编码</span>        ctx<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span><span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">copiedBuffer</span><span class="token punctuation">(</span><span class="token string">"hello 客户端~ "</span><span class="token punctuation">,</span><span class="token class-name">CharsetUtil</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 异常处理     * @param ctx --- 上下文对象     * @param cause --- 异常     * @throws Exception     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        ctx<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>客户端:  </li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>pounds<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>simple</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>bootstrap<span class="token punctuation">.</span></span><span class="token class-name">Bootstrap</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span></span><span class="token class-name">ChannelFuture</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span></span><span class="token class-name">ChannelInitializer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>socket<span class="token punctuation">.</span></span><span class="token class-name">SocketChannel</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>socket<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token class-name">NioSocketChannel</span><span class="token punctuation">;</span><span class="token comment">/** * @Date 2021/5/9 19:10 * @Author by pounds * @Description netty入门教程 客户端 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NettyClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 1. 创建客户端事件循环组</span>        <span class="token class-name">NioEventLoopGroup</span> eventExecutors <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment">// 2. 创建启动对象,注意: 要使用netty的包,并且不是的ServerBootStrap</span>            <span class="token class-name">Bootstrap</span> bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 3. 设置属性</span>            bootstrap                    <span class="token comment">// 设置事件组</span>                    <span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>eventExecutors<span class="token punctuation">)</span>                    <span class="token comment">// 设置通道</span>                    <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                    <span class="token comment">// 设置handler</span>                    <span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token annotation punctuation">@Override</span>                        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>                            ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NettyClientHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" 客户端准备完毕 ......"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 4. 启动客户端,并同步监听</span>            <span class="token class-name">ChannelFuture</span> channelFuture <span class="token operator">=</span> bootstrap<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6668</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 5. 同步监听socketChannel 关闭</span>            channelFuture<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span><span class="token punctuation">{</span>            eventExecutors<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * @Date 2021/5/9 19:24 * @Author by pounds * @Description 跟NettyServerHandler 一回事 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NettyClientHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token comment">/**     * channel准备就绪就会触发这个方法,向服务端发送消息     * @param ctx     * @throws Exception     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelActive</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"client: "</span> <span class="token operator">+</span> ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span><span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">copiedBuffer</span><span class="token punctuation">(</span><span class="token string">"hello server: 我是netty客户端"</span><span class="token punctuation">,</span> <span class="token class-name">CharsetUtil</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 读事件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ByteBuf</span> byteBuf <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuf</span><span class="token punctuation">)</span> msg<span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务器回复的消息: "</span> <span class="token operator">+</span> byteBuf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token class-name">CharsetUtil</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"服务器地址: "</span> <span class="token operator">+</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 异常处理     * @param ctx     * @param cause     * @throws Exception     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"出现了异常 [%s] : %s"</span><span class="token punctuation">,</span>cause<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>cause<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ctx<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> netty实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3 Netty简介</title>
      <link href="/Netty/netty%E5%AE%9E%E6%88%98/3_Netty%E7%AE%80%E4%BB%8B/"/>
      <url>/Netty/netty%E5%AE%9E%E6%88%98/3_Netty%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介:"></a>1. 简介:</h2><ol><li>Netty是由JBoss提供的一个java网络开源框架</li><li>Netty是一个异步的,基于事件驱动的网络框架,用来快速开发高性能,高可用的IO程序</li><li>Netty主要是针对tcp协议下,面向Clients端的高并发应用程序,或者是Peer-To-Peer场景下的大量数据传输应用</li><li>Netty本质就是java的NIO框架,在NIO的基础上进行了大量的封装,让开发者将精力集中于业务代码而不是网络通信,多使用于服务器通信相关的多种场景</li></ol><h2 id="2-Netty架构"><a href="#2-Netty架构" class="headerlink" title="2. Netty架构:"></a>2. Netty架构:</h2><p>  <img src="/Netty/netty%E5%AE%9E%E6%88%98/3_Netty%E7%AE%80%E4%BB%8B/Netty%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="netty架构图"></p><h2 id="3-Netty特性"><a href="#3-Netty特性" class="headerlink" title="3. Netty特性:"></a>3. Netty特性:</h2><ol><li>NIO的弊端:<ul><li>NIO类库和api繁杂,使用麻烦,需要开发人员熟练掌握NIO技术</li><li>需要具备其他额外的技能,否则无法写出高性能的NIO程序,比如: reactor模式就需要多线程技术实现.</li><li>开发工作量和难度都非常大</li><li>NIO有bug: 比如 epoll bug,会到这selector轮空,打满cpu.</li></ul></li><li>优点:  <ul><li><code>设计</code>: 统一的API,支持多种传输类型,支持阻塞与非阻塞I/O模式,简单而强大的线程模型,支持真正的无连接数据报套接字,链接逻辑组件以支持复用</li><li><code>易用性</code>: 大量的javadoc文档和大量的示例集,不需要超过jdk1.6+的依赖</li><li><code>性能</code>: 拥有比java的核心api更高的吞吐量以及更低的延迟; 得益于池化和复用,拥有更低的资源消耗;更少的内存复制</li><li><code>健壮性</code>: 不会因为慢速,快速或者超载的链接导致OOM;消除在高速网络NIO应用程序常见的不公平读写比率</li><li><code>安全性</code>: 支持完整的SSL/TLS以及startTLS;可用于受限环境下,比如 APPLET 和 OSGI</li><li><code>社区驱动</code>: 社区活跃,发布快速而频繁</li></ul></li></ol><h2 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景:"></a>4. 应用场景:</h2><ul><li>互联网行业: 分布式系统,服务与服务之间的rpc远程调用的底层,通常就是netty这种异步高可用通信框架,比如: <code>DUBBO</code></li><li>游戏行业: 使用netty作为聊天系统的通信组件</li><li>等</li></ul>]]></content>
      
      
      <categories>
          
          <category> netty实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2 零拷贝</title>
      <link href="/Netty/netty%E5%AE%9E%E6%88%98/2_%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
      <url>/Netty/netty%E5%AE%9E%E6%88%98/2_%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-NIO-与-零拷贝"><a href="#1-NIO-与-零拷贝" class="headerlink" title="1. NIO 与 零拷贝:"></a>1. NIO 与 零拷贝:</h2><ol><li><p>简介: <code>零拷贝就是一种避免cpu将数据从一块存储拷贝到另外一块存储的技术,零拷贝指的是没有cpu参与拷贝数据</code>  </p><ul><li>零拷贝是网络编程的关键,很多性能优化都离不开零拷贝,利用零拷贝减少不必要的数据拷贝,从而优化网络编程效率  </li><li>零拷贝指的是从操作系统的角度来说,整个操作系统中有且只有一份数据,此外没有与之重复的数据,通过MDA和SG-DMA技术减少cpu拷贝的开销</li><li>java程序中,常用的零拷贝有mmap(内存映射) 和 sendFile()</li></ul></li><li><p>零拷贝的好处:  </p><ul><li>减少或者避免不必要的cpu数据拷贝,从而释放cpu去执行其他任务  </li><li>零拷贝机制能减少用户空间和操作系统内核空间的上下文切换次数</li><li>减少内存的占用  </li></ul></li><li><p>内核空间和用户空间:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/2_%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E5%86%85%E6%A0%B8%E5%92%8C%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4.png" alt="内核和用户空间">  </p><ul><li>用户空间: 提供给各个进程的空间,<code>用户空间不具有访问内核空间资源的权限</code>,如果程序需要使用内核空间的资源,<code>需要通过操作系统调度来完成</code>.从用户空间切换到内核空间,完成操作之后再从内核空间切换到用户空间,<br>这样的消耗很大.</li><li>内核空间: 系统自身使用的空间,主要提供 进程调度,内存分配,连接硬件资源等功能.  </li></ul></li><li><p>缓冲区和虚拟内存:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/2_%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt="缓冲区和虚拟内存">  </p><ul><li><code>直接内存访问技术(Direct Memory Access -DMA)</code>: 在进行I/O设备和内存数据传输的时候,数据传输工作全部交给I/O硬件设备中的DMA技术,<br>从而cpu不需要参与将数据从I/O设备传输到内存这一过程数据的拷贝.  </li><li><code>缓冲区</code>:  内核空间存放I/O过程中需要传输数据的区域  </li><li><code>虚拟内存</code>:  </li></ul></li></ol><h2 id="2-传统i-o看数据拷贝流程"><a href="#2-传统i-o看数据拷贝流程" class="headerlink" title="2. 传统i/o看数据拷贝流程:"></a>2. 传统i/o看数据拷贝流程:</h2><ol><li>以下面这个文件传输为例,了解传统I/O过程中数据拷贝的过程:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/2_%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E4%BB%A3%E7%A0%81.png" alt="内核和用户空间">  <ul><li>传统I/O文件数据拷贝流程:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/2_%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E5%9B%BE.png" alt="过程图"><br><img src="/Netty/netty%E5%AE%9E%E6%88%98/2_%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E6%8B%B7%E8%B4%9D%E6%B5%81%E7%A8%8B%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="时序图"><br>过程总结:<ul><li>上下文切换: 一共发生了四次上下文切换<ol><li>向操作系统发起read请求,<code>从用户空间切换到内核空间</code>  </li><li>read请求完成,向用户返回数据,<code>从内核空间切换到用户空间</code>  </li><li>向操作系统发起write请求, <code>从用户空间切换到内核空间</code>  </li><li>write请求完成,继续执行用户进程其他任务, <code>从内核空间切换到用户空间</code>  </li></ol></li><li>数据拷贝:  一共发生四次拷贝<ol><li>I/O硬件向内核空间缓冲区的DMA拷贝</li><li>内核缓冲区向用户缓冲区的cpu拷贝  </li><li>用户空间缓冲区向socket缓冲区的cpu拷贝  </li><li>socket缓冲区向网卡的DMA拷贝</li></ol></li></ul></li></ul></li></ol><h2 id="3-优化传统I-O实现零拷贝"><a href="#3-优化传统I-O实现零拷贝" class="headerlink" title="3. 优化传统I/O实现零拷贝:"></a>3. 优化传统I/O实现零拷贝:</h2><ol><li><p>使用mmap()调用优化掉一次<code>cpu拷贝</code>:  </p><ol><li>mmap()调用的效果: 通过内存映射,将内核空间的地址映射到用户空间,<code>达到内核空间和用户空间共享数据的效果</code>,从而减少一次从<code>内核空间拷贝数据到用户空间的cpu拷贝开销</code><br><img src="/Netty/netty%E5%AE%9E%E6%88%98/2_%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-20210829174556320.png" alt="mmap()时序图"><br><img src="/Netty/netty%E5%AE%9E%E6%88%98/2_%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-20210829174624103.png" alt="mmap()过程图"><br>过程总结:  <ul><li>四次上下文切换:  <ol><li>向操作系统发起mmap()调用,<code>从用户空间切换到内核空间</code></li><li>mmap()调用完成,返回用户空间执行用户进程后续操作,<code>从内核空间切换到用户空间</code></li><li>向操作系统发起write请求, <code>从用户空间切换到内核空间</code></li><li>write请求完成,继续执行用户进程其他任务, <code>从内核空间切换到用户空间</code> </li></ol></li><li>三次数据拷贝:  <ol><li>I/O硬件向内核空间缓冲区的DMA拷贝</li><li>由于内核空间和用户空间共享数据, <code>无需再像用户空间复制数据</code>,在write的时候<code>直接</code>从内核缓冲区通过cpu拷贝数据到socket缓冲区</li><li>socket缓冲区向网卡的DMA拷贝</li></ol></li></ul></li></ol></li><li><p>使用sendFile()替换read,write函数, <code>优化掉两次上下文切换</code>  </p><ol><li><p>sendFile函数: </p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;sys/socket.h&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset,size_t count);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>解释: out_fd是目的文件描述符,in_fd是源文件描述符号,offset是源文件的偏移量,count是需要处理的长度</li><li>sendfile的作用: <ol><li>替换write和read函数,减少两次上下文切换</li><li>在调用sendfile函数的时候,由用户空间切换到内核空间之后,直接在内核空间使用cpu拷贝,向socket缓冲区复制数据,处理完成之后再切换到用户空间  </li></ol></li></ul><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/2_%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-20210829174713842.png" alt="sendFile时序图"></p><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/2_%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-20210829174745347.png" alt="sendFile过程图"></p><ul><li>总结:  <ul><li>两次上下文切换:  <ol><li>调用sendfile函数,从用户空间切换到内核空间  </li><li>sendfile处理完成,从内核空间切换到用户空间,继续执行用户进程剩下的操作.</li></ol></li><li>三次数据拷贝<ol><li>I/O硬件通过DMA技术,将数据拷贝至内核空间缓冲区  </li><li>用户进程调用sendFile函数之后,<code>数据与用户空间缓冲区不再产生联系</code>, 直接从内核缓冲区通过cpu拷贝数据到socket缓冲区</li><li>socket缓冲向网卡的DMA拷贝  </li></ol></li></ul></li></ul></li></ol></li><li><p>优化sendfile函数,实现真正的零拷贝,<code>没有cpu拷贝</code>:  </p><ul><li><p>如果网卡支持SG-DMA(The Scatter-Gather Direct Memory Access)技术,就可以进一步<code>减少</code>数据从内核空间经过cpu拷贝到socket缓冲区的开销.原来从内核空间缓冲区,通过cpu拷贝数据到<br>socket缓冲区的过程还在,但是只有关于数据去向和长度信息的描述符才会被附加到套接字缓冲区,这部分的开销可以忽略不计.<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/2_%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-20210829174854638.png" alt="真正的零拷贝"></p><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/2_%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-20210829174921676.png" alt="真正的零拷贝"></p><ul><li>总结:  <ul><li>2次上下文切换:<ol><li>调用sendfile函数,从用户空间切换到内核空间</li><li>sendfile处理完成,从内核空间切换到用户空间,继续执行用户进程剩下的操作. </li></ol></li><li>2次数据拷贝:  <ol><li>I/O硬件通过DMA技术,将数据拷贝至内核空间缓冲区  </li><li>不再将内存缓冲区的数据复制到socket缓冲区,只是将少部分数据去向描述符和数据长度描述符传递给socket缓冲区,通过SG-DMA技术直接将数据拷贝到网卡中  </li></ol></li></ul></li></ul></li></ul></li></ol><h2 id="4-JAVA-NIO中的零拷贝"><a href="#4-JAVA-NIO中的零拷贝" class="headerlink" title="4. JAVA NIO中的零拷贝:"></a>4. JAVA NIO中的零拷贝:</h2><p>客户端demo:  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>pounds<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>zerocopy</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">FileInputStream</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">InetSocketAddress</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">FileChannel</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">SocketChannel</span><span class="token punctuation">;</span><span class="token comment">/** * @Date 2021/5/9 12:43 * @Author by pounds * @Description Nio中的零拷贝 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NioClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>        <span class="token class-name">SocketChannel</span> client <span class="token operator">=</span> <span class="token class-name">SocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        client<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token string">"localhost"</span><span class="token punctuation">,</span><span class="token number">7001</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> file <span class="token operator">=</span> <span class="token string">"protoc-3.6.1-win32.zip"</span><span class="token punctuation">;</span>        <span class="token class-name">FileChannel</span> fileChannel <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// windows系统中,transferTo方法每次只能传输8m,需要分段传输,linux系统则不需要,下面这个写法是linux的写法\</span>        <span class="token comment">// transferTo 就是使用的零拷贝</span>        fileChannel<span class="token punctuation">.</span><span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>fileChannel<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"总共耗时 %s "</span><span class="token punctuation">,</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>服务端demo:  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>pounds<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>zerocopy</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">InetSocketAddress</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token class-name">ByteBuffer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">ServerSocketChannel</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">SocketChannel</span><span class="token punctuation">;</span><span class="token comment">/** * @Date 2021/5/9 12:35 * @Author by pounds * @Description Nio中的零拷贝 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NioServer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>        <span class="token class-name">ServerSocketChannel</span> serverSocketChannel <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        serverSocketChannel<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span><span class="token number">7001</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ByteBuffer</span> byteBuffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">SocketChannel</span> socketChannel <span class="token operator">=</span> serverSocketChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> readCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">!=</span> readCount<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    readCount <span class="token operator">=</span> socketChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>byteBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 重新读</span>                byteBuffer<span class="token punctuation">.</span><span class="token function">rewind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> netty实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1 JavaIO复习</title>
      <link href="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/"/>
      <url>/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-I-O模型基本介绍"><a href="#1-1-I-O模型基本介绍" class="headerlink" title="1.1 I/O模型基本介绍:"></a>1.1 I/O模型基本介绍:</h2><h3 id="1-1-1-I-O模型的简单理解"><a href="#1-1-1-I-O模型的简单理解" class="headerlink" title="1.1.1 I/O模型的简单理解:"></a>1.1.1 I/O模型的简单理解:</h3><ol><li>为了实现不同类型的i/o方式,根据应用场景采取不同数据传输的通道,对数据进行接收和发送,不同的模型对通信的性能也有不同的影响.</li><li>I/O模型分类:<br>老张煮茶更为形象: <a href="https://www.zhihu.com/question/19732473">关于阻塞/非阻塞,异步/同步参考</a><ul><li>I/O操作分两步走:<br>1.<code>发起I/O请求</code>,2.<code>实际的I/O读写操作(内核态和用户态的数据拷贝)</code>.</li><li>阻塞与非阻塞:<br><code>阻塞与非阻塞的区别,发生在I/O操作的第一步</code><br>阻塞: 当一个I/O操作发起,处理这个I/O操作的线程会一直阻塞到整个I/O处理完成,这就是阻塞I/O<br>非阻塞: 当一个I/O操作发起,处理这个I/O操作的线程不会阻塞在该I/O操作上,而是对所有的I/O操作进行轮询,只处理准备好结果的I/O操作.        </li><li>同步和异步:<br>同步: 小明在泡面的过程期间,什么也不干,就一直等待到面泡好.<br>异步: 小红在泡面的过程期间,定个闹钟然后切了两个水果,冲了一杯咖啡.当闹钟响了表示面泡好了.<br>同步与异步的区别发生在I/0操作的第二步.同步I/O在实际读写的时候处理该I/O操作的进程会一直等待整个数据拷贝的过车,异步I/O则不会一直等待.</li><li>BIO: 同步阻塞模型,服务器实现方式为: 为每一个连接都分配一个线程专门处理这个client的请求,该连接会阻塞等待服务端的响应,如果该连接<br>什么也不做的话,会造成资源的浪费和不必要的线程开销.<br>示意图:<br>![JAVA BIO](1_JavaIO复习/JAVA BIO.png)<br>缺点:  <ol><li>如果连接空闲,容易造成资源的浪费,不必要的线程开销</li><li>高并发场景下,容易造成服务端的压力增加  </li></ol></li><li>NIO: 同步非阻塞模型,服务端实现方式为: 一个线程(服务端可以维护多个这样的线程)处理多个client连接,通过一个多路复用器以轮询的方式去<br>发现是否有连接有数据要传输,如果轮询到某个连接有数据传输就处理.对于连接是立即响应的,不会进行阻塞等待.<br>示意图:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/NIO.png" alt="JAVA NIO">  </li><li>AIO: 异步非阻塞,AIO引入异步通道的概念,采用了Proactor模式,简化了程序编写,有效请求才启动线程,他的特点就是由操作系统处理完成后再通知<br>服务端应用进程去处理,一般适用于连接较多且连接时间比较长的应用.</li></ul></li><li>I/O模型使用的场景:<ul><li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。</li><li>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。</li><li>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。  </li></ul></li></ol><h2 id="1-2-JAVA-BIO-传统i-o模型"><a href="#1-2-JAVA-BIO-传统i-o模型" class="headerlink" title="1.2 JAVA BIO(传统i/o模型):"></a>1.2 JAVA BIO(传统i/o模型):</h2><ol><li><p>基本介绍:  </p><ol><li>java BIO就是传统的 java I/O编程,其相关的接口和类在 java.io包中.</li><li>BIO(blocking I/O) ： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接<br>不做任何事情会造成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器)。</li><li>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解</li></ol></li><li><p>工作机制:  </p><ol><li><p>原理图:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/BIO%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="BIO原理">  </p></li><li><p>编程流程:  </p><ul><li>服务端启动ServerSocket,用于接收和响应客户端.</li><li>客户端启动Socket与服务端进行通信,默认情况下,服务端会给客户端每个socket建立一个线程与之通讯.</li><li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li><li>如果有响应，客户端线程会等待请求结束后，在继续执行。</li></ul></li><li><p>BIO实例:</p><blockquote><p>要求:<br>使用 BIO 模型编写一个服务器端，监听 6666 端口，当有客户端连接时，就启动一个线程与之通讯。<br>要求使用线程池机制改善，可以连接多个客户端。<br>服务器端可以接收客户端发送的数据（telnet 方式即可）。  </p></blockquote> <pre class="line-numbers language-java" data-language="java"><code class="language-java">    <span class="token comment">/*    使用线程池模拟每个请求服务端都会为之开启一个线程来处理.忽略线程池中线程数量的限制    */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BioServer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 创建线程池处理连接:</span>        <span class="token class-name">ThreadPoolExecutor</span> executor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span>                <span class="token number">10</span><span class="token punctuation">,</span>                <span class="token number">10</span><span class="token punctuation">,</span>                <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">60</span><span class="token punctuation">,</span>                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ThreadFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setNameFormat</span><span class="token punctuation">(</span><span class="token string">"BIO-THREAD-POOL-%d"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor<span class="token punctuation">.</span>DiscardPolicy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打开socket连接:</span>        <span class="token keyword">try</span><span class="token punctuation">(</span><span class="token class-name">ServerSocket</span> serverSocket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerSocket</span><span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"成功启动socket链接"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment">// 有链接过来就建立简介</span>                <span class="token keyword">final</span> <span class="token class-name">Socket</span> socket <span class="token operator">=</span> serverSocket<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"客户端接入"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 开启 线程处理通信</span>                executor<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>                    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment">// 获取输入流</span>                    <span class="token keyword">try</span> <span class="token punctuation">(</span>                      <span class="token keyword">final</span> <span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> socket<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                            <span class="token keyword">final</span> <span class="token keyword">int</span> read <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>read <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" : "</span> <span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token string">"GBK"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>                                <span class="token keyword">break</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>BIO的问题分析:</p><ul><li>每个请求都会创建一个线程来处理该请求.</li><li>并发量较大的时候,会创建大量的线程来处理I/O请求,造成服务端的压力大,资源占用严重.</li><li>建立连接之后,如果没有数据响应,那么这个线程就会被阻塞在这个I/O请求上, 造成资源的浪费.</li></ul></li></ol></li></ol><h2 id="1-3-JAVA-NIO"><a href="#1-3-JAVA-NIO" class="headerlink" title="1.3 JAVA NIO:"></a>1.3 JAVA NIO:</h2><ol><li><p>NIO基本介绍:</p><ol><li><code>NIO(non-blocking i/o)</code>: jdk提供的一套新的i/o api,同步非阻塞模型.</li><li>NIO位于jdk的java.nio包下,大多数是对java.io包中类进行了一些修改.</li><li>NIO的三大核心组件: <code>Channel(通道)</code>,<code>Buffer(缓冲区)</code>,<code>Selector(选择器)</code>.</li><li>NIO是 <code>面向缓冲区</code> 或者 <code>面向块</code> 编程的.数据读取到一个它稍后处理的缓冲区,需要时可在缓冲区前后移动获取数据,这样增加了处理过程中的灵活性<br>,使用NIO可以提供非阻塞式的搞伸缩网络.</li><li>JAVA NIO的非阻塞模式:<ul><li>读: 使一个线程从某个通道发送请求或者读取数据,但是他仅仅能得到当前可用数据,如果当前没有可用数据,什么都拿不到,不会阻塞保持线程阻塞.所以<br>在数据准备完成之前,该线程是可以做其他事情的.</li><li>写: 一个线程请求写入一些数据到某个通道,但不需要等待线程完全写入,这个线程就可以去做其他的事情.</li></ul></li></ol></li><li><p>NIO的原理示意图:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/Nio%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="NIO原理示意图"><br>解释:</p><ol><li>上图是服务端的NIO原理示意图</li><li>一个线程对应一个selector,服务端可以开启多个线程管理多个selector,然后通过一个selector去管理多个channel</li><li>一个channel对应一个buffer,一个channel就可以看做是一个连接,channel会像selector注册自己. <code>一个severSocketChannel和多个socketC hannel</code>.</li><li>一个buffer对应一个client</li><li>selector根据不同的事件,在不同事件的channel上切换,切换到哪一个channel是由事件决定的,比如: accept,read,write等事件</li><li>buffer就是一个内存块,底层就是一个数组.</li><li>数据的写入读取都是通过buffer实现的.[这里就是与BIO的区别,NIO一个buffer就能解决输入与输出,BIO要么是输入,要么是输出,无法达到双向传输的效果]<br>NIO只需要通过buffer的flip和clear方法就能完成读写的切换.</li><li>channel是双线的,可以返回底层操作系统的情况.比如linux底层操作系统就是双向的.</li></ol></li><li><p>NIO的三大核心组件:</p><ol><li><p>Buffer[缓冲区]: 缓冲区本质上是一个可以读写的内存块.(底层结构类似于数组). buffer提供了一组操作内存块的方法.缓冲区内部有一套机制,来跟踪和记录缓冲区<br>内部的状态变化.channel提供文件,网络读取数据的通道,但是数据的读取和写入都需要经过buffer.<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/NIO%E4%B8%ADbuffer%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="NIO中buffer的作用"><br><img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/buffer%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="buffer继承关系"></p><ul><li><p>buffer中几个重要的属性:  </p><table><thead><tr><th align="left">属性</th><th>作用</th></tr></thead><tbody><tr><td align="left">capacity</td><td>描述整个缓冲区的容量, <code>可以理解为数组长度</code>,无法被修改</td></tr><tr><td align="left">position</td><td>描述缓冲区下一个能够<code>写入</code>或者<code>读取</code>的位置,<code>get,put等方法会更新这个值</code></td></tr><tr><td align="left">limit</td><td>描述缓冲区第一个不能<code>写入</code>或者<code>读取的位置</code>,读写模式的切换实际上就是操作的个变量</td></tr><tr><td align="left">mark</td><td>标记,表示当前position的位置.可以通过reset()将position恢复到mark的位置</td></tr><tr><td align="left">几个变量的大小关系</td><td>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</td></tr></tbody></table></li><li><p>几个属性关系示意图:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/buffer%E5%B1%9E%E6%80%A7%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="buffer属性示意图"></p></li><li><p>读写模式切换属性变化示意图:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/buffer%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2.png" alt="读写模式切换属性变化示意图"></p></li><li><p>常用方法:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/buffer%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="buffer常用方法"></p></li><li><p>最常用的buffer –&gt; ByteBuffer:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/ByteBUffer%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95.png" alt="ByteBuffer常用方法"></p></li></ul></li><li><p>Channel[通道]:</p><ul><li>NIO中的channel跟传统i/o中的流很相似,但主要有以下几点区别:<ul><li>通道是双向的,即可以读或者写,流要么是写入,要么是读取</li><li>通道可以实现异步读写数据</li><li>通道总是向缓冲区中读写数据</li></ul></li><li>几种常用的channel:<ul><li>FileChannel : <code>从文件中读取数据</code><br> <img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/fileChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="FileChannel常用方法"></li><li>SocketChannel : <code>tcp客户端读写数据通道</code><br> <img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/socketChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="socketChannel常用方法"></li><li>ServerSocketChannel : <code>tcp服务端读写数据的通道,通常使用来监听socketChannel连接的.</code><br> <img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/serverSocketChannel%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="ServerSocketChannel常用方法"></li><li> DatagramChannel : <code>udp通信读写数据的通道</code></li></ul></li></ul></li><li><p>selector[选择器]:</p><ul><li>概念:<ul><li>NIO,使用非阻塞式I/O,使用一个线程处理多个I/O操作,就是selector实现的.</li><li><code>selector能够检测多个注册了的通道上是否有事件发生.</code>(ps: 多个通道以时间的方式可以注册到同一个selector上面,selector中维护了<br>一个事件key集合,遍历这个集合判断通道对应key的状态,然后确定通道发生什么事件),``如果通道上发生了某个事件,就做对应的逻辑处理`这样就实现了<br>非阻塞I/O以一个线程去管理多个I/O通道.</li><li><code>只有在通道真正有读写事件发生的时候,才会去进行读写操作,可以大大的减少系统开销</code>.并且不必为每一个连接都创建一个线程,减少线程创建销毁的开销</li><li><code>避免了线程之间上下文切换的开销</code></li></ul></li><li>selector的特点:<ul><li>selector可以处理多个客户端连接的请求.</li><li>selector在某个通道没有进行数据读写的时候,可以去处理其他通道上的事件.</li><li>selector通常将阻塞I/O等待I/O操作完成的时间,用在处理其他通道上的I/O操作.</li><li>由于读写操作都是非阻塞的,可以提升I/O线程的运行效率,避免频繁I/O导致线程挂起</li><li>一个线程对应一个selector,从而处理多个客户端连接和读写操作,从根本上解决了传统I/O一对一线程模型.架构的性能,弹性伸缩能力,可靠性都大幅度提升</li></ul></li><li>selector处理时间的流程:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/selector%E5%A4%84%E7%90%86%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%89%87.png" alt="selector流程图"><ul><li>创建服务端通道serverSocketChannel,并将其注册到selector上面,关注事件为accept</li><li>当accept事件发生的时候,通过serverSocketChannel.accept()方法获取客户端通道socketChannel并将其按照关心的事件注册<br>(socketChannel.register(selector,ops))到selector上</li><li>注册成功后,回返回一个selectionKey,该key就是存放在selector的一个set集合里面,[ps:通过遍历这个set来判断发生什么事件]</li><li>selector通过select()方法,得到发生事件的通道个数.</li><li>得到所有发生事件的selectionKey,通过selectionKey去获取对应的socketChannel完成相应的逻辑操作.</li></ul></li><li>selector使用的注意事项:<ul><li>要被selector管理的通道,必须是非阻塞的通道, <code>即: 该通道要实现selectableChannel接口</code></li><li>serverSocketChannel也需要注册到selector上面去,然后通过selector来管理监听事件.<code>通常一个serverSocketChannel</code>只有一个.</li><li>selector的方法keys和selectedKeys的区别:<ol><li>keys: 返回的是所有注册到selector上面的所有selectionKey, <code>即:只要注册成功就会生成一个key放进去</code>,是个set,selector不会主动删除这个set<br>里面的元素.[ps:任何删除操作都不支持]</li><li>selectedKey: 返回select方法中有事件发生的channel对应的selectionKey,[同样是任何删除操作都不支持]</li></ol></li></ul></li><li>selectionKey API:<ul><li>selectionKey,表示selector与channel之间的一种注册关系,即 channel关心事件在selector中的记录.<code>共四种</code>:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/selectionKey%E7%9A%84%E6%B3%A8%E5%86%8C%E4%BA%8B%E4%BB%B6.png" alt="selectionKey注册事件"></li><li>api:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/1_JavaIO%E5%A4%8D%E4%B9%A0/selection.png" alt="selectionKey的api"></li></ul></li></ul></li></ol></li><li><p>NIO注意事项:</p><ol><li>ByteBuffer在put,get的时候 ,put什么类型的数据,get的时候就需要使用什么类型的数据来接收,否则会抛出异常.</li><li>buffer可以转换成只读buffer,但是之后就无法写入,否则抛出异常</li><li>Nio还提供了MappedByteBuffer,可以让文件直接在内存中进行修改,然后是利用NIO来通不到文件</li><li>NIO还支持通过多个buffer来完成同一个事件的读写.</li></ol></li><li><p>NIO和BIO的比较:</p><ol><li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li><li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li><li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<br><code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li></ol></li></ol><h2 id="1-4-实例"><a href="#1-4-实例" class="headerlink" title="1.4 实例:"></a>1.4 实例:</h2><ol><li><p>内存往磁盘写文件:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**    实例要求：* 1. 使用前面学习后的 `ByteBuffer`（缓冲）和 `FileChannel`（通道），将 "hello,尚硅谷" 写入到 `file01.txt` 中* 2. 文件不存在就创建* 3. 代码演示:*/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token class-name">String</span> info <span class="token operator">=</span> <span class="token string">"hello NIO"</span><span class="token punctuation">;</span>       <span class="token keyword">try</span><span class="token punctuation">(</span>        <span class="token comment">//1. 创建一个文件输出流</span>        <span class="token keyword">final</span> <span class="token class-name">FileOutputStream</span> fileOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"src/main/resources/NioOutPutFile.txt"</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//2. 通过流拿到FileChanel,channel实际上就是流使用了装饰者模式,将channel作为属性包裹在了流中</span>        <span class="token class-name">FileChannel</span> fileOutputStreamChannel <span class="token operator">=</span> fileOutputStream<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3. 创建buffer</span>        <span class="token class-name">ByteBuffer</span> byteBuffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//4. 向buffer里面写入数据</span>        byteBuffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>info<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//5. 切换buffer的模式,使用flip由写切换为读</span>        byteBuffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//6. 将buffer中数据写入channel中</span>        fileOutputStreamChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>byteBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>从磁盘往内存读取数据:  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/* 实例要求： 1. 使用前面学习后的 `ByteBuffer`（缓冲）和 `FileChannel`（通道），将 `file01.txt` 中的数据读入到程序，并显示在控制台屏幕   2. 假定文件已经存在 3. 代码演示 */</span> <span class="token annotation punctuation">@Test</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">try</span><span class="token punctuation">(</span>             <span class="token comment">//1. 创建一个文件输出流</span>             <span class="token class-name">FileInputStream</span> fileOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"src/main/resources/NioOutPutFile.txt"</span><span class="token punctuation">)</span>     <span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token comment">//2. 通过流拿到FileChanel,channel实际上就是流使用了装饰者模式,将channel作为属性包裹在了流中</span>         <span class="token class-name">FileChannel</span> fileOutputStreamChannel <span class="token operator">=</span> fileOutputStream<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//3. 创建buffer</span>         <span class="token class-name">ByteBuffer</span> byteBuffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//4. 从channel里面读取数据</span>         fileOutputStreamChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>byteBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//5. 获取数据,array会将整个缓冲区都获取出来,就不需要切换模式</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>byteBuffer<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>         e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>文件读取然后写入:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/*实例要求：1. 使用 `FileChannel`（通道）和方法 `read、write`，完成文件的拷贝2. 拷贝一个文本文件 `1.txt`，放在项目下即可3. 代码演示*/</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">(</span>        <span class="token class-name">FileInputStream</span> fileInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"src/main/resources/NioOutPutFile.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FileOutputStream</span> fileOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"src/main/resources/NioOutPutFile1.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">FileChannel</span> inputStreamChannel <span class="token operator">=</span> fileInputStream<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FileChannel</span> outputStreamChannel <span class="token operator">=</span> fileOutputStream<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ByteBuffer</span> byteBuffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">// 往缓冲区写数据</span>            <span class="token keyword">int</span> read <span class="token operator">=</span> inputStreamChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>byteBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>read <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"read == "</span> <span class="token operator">+</span> read <span class="token operator">+</span> <span class="token string">",于是退出啦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 写模式切换为读模式</span>            byteBuffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 从缓冲区读数据</span>            outputStreamChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>byteBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//读模式转换为写模式,数据超出缓冲区的大小,就要多次读写</span>            byteBuffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过transferForm拷贝文件:  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">(</span>            <span class="token class-name">FileInputStream</span> fileInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"src/main/resources/NioOutPutFile.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">FileOutputStream</span> fileOutputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"src/main/resources/NioOutPutFile2.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">FileChannel</span> inputStreamChannel <span class="token operator">=</span> fileInputStream<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">FileChannel</span> outputStreamChannel <span class="token operator">=</span> fileOutputStream<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">ByteBuffer</span> byteBuffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment">// 往缓冲区写数据</span>            <span class="token keyword">int</span> read <span class="token operator">=</span> inputStreamChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>byteBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>read <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"read == "</span> <span class="token operator">+</span> read <span class="token operator">+</span> <span class="token string">",于是退出啦"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            inputStreamChannel<span class="token punctuation">.</span><span class="token function">transferTo</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>read<span class="token punctuation">,</span>outputStreamChannel<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>nio</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token class-name">ByteBuffer</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReadOnlyBuffer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ByteBuffer</span> normalBuffer <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">64</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            normalBuffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 写切换为读</span>        normalBuffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 转换只读</span>        <span class="token class-name">ByteBuffer</span> readOnlyBuffer <span class="token operator">=</span> normalBuffer<span class="token punctuation">.</span><span class="token function">asReadOnlyBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        readOnlyBuffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。【举例说明】</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>nio</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">RandomAccessFile</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token class-name">MappedByteBuffer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">FileChannel</span><span class="token punctuation">;</span><span class="token comment">/** * 说明 1.MappedByteBuffer 可让文件直接在内存（堆外内存）修改,操作系统不需要拷贝一次 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MappedByteBufferTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">RandomAccessFile</span> randomAccessFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RandomAccessFile</span><span class="token punctuation">(</span><span class="token string">"1.txt"</span><span class="token punctuation">,</span> <span class="token string">"rw"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取对应的通道</span>        <span class="token class-name">FileChannel</span> channel <span class="token operator">=</span> randomAccessFile<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">/**         * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式         * 参数 2：0：可以直接修改的起始位置         * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存         * 可以直接修改的范围就是 0-5         * 实际类型 DirectByteBuffer         */</span>        <span class="token class-name">MappedByteBuffer</span> mappedByteBuffer <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">FileChannel<span class="token punctuation">.</span>MapMode</span><span class="token punctuation">.</span>READ_WRITE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mappedByteBuffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">'H'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mappedByteBuffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mappedByteBuffer<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">'Y'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//IndexOutOfBoundsException</span>        randomAccessFile<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"修改成功~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>前面都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code>【举例说明】</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>atguigu<span class="token punctuation">.</span>nio</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">InetSocketAddress</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token class-name">ByteBuffer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">ServerSocketChannel</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">SocketChannel</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Arrays</span><span class="token punctuation">;</span><span class="token comment">/** * Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散] * Gathering：从 buffer 读取数据时，可以采用 buffer 数组，依次读 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScatteringAndGatheringTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>                <span class="token comment">//使用 ServerSocketChannel 和 SocketChannel 网络</span>        <span class="token class-name">ServerSocketChannel</span> serverSocketChannel <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">InetSocketAddress</span> inetSocketAddress <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">7000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//绑定端口到 socket，并启动</span>        serverSocketChannel<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>inetSocketAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//创建 buffer 数组</span>        <span class="token class-name">ByteBuffer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> byteBuffers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        byteBuffers<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        byteBuffers<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//等客户端连接 (telnet)</span>        <span class="token class-name">SocketChannel</span> socketChannel <span class="token operator">=</span> serverSocketChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> messageLength <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span> <span class="token comment">//假定从客户端接收 8 个字节</span>        <span class="token comment">//循环的读取</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> byteRead <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>byteRead <span class="token operator">&lt;</span> messageLength<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">long</span> l <span class="token operator">=</span> socketChannel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>byteBuffers<span class="token punctuation">)</span><span class="token punctuation">;</span>                byteRead <span class="token operator">+=</span> l<span class="token punctuation">;</span> <span class="token comment">//累计读取的字节数</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"byteRead = "</span> <span class="token operator">+</span> byteRead<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//使用流打印,看看当前的这个 buffer 的 position 和 limit</span>                <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>byteBuffers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>buffer <span class="token operator">-&gt;</span> <span class="token string">"position = "</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">position</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", limit = "</span> <span class="token operator">+</span> buffer<span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">//将所有的 buffer 进行 flip</span>            <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>byteBuffers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>buffer <span class="token operator">-&gt;</span> buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//将数据读出显示到客户端</span>            <span class="token keyword">long</span> byteWirte <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>byteWirte <span class="token operator">&lt;</span> messageLength<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">long</span> l <span class="token operator">=</span> socketChannel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>byteBuffers<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//</span>                byteWirte <span class="token operator">+=</span> l<span class="token punctuation">;</span>            <span class="token punctuation">}</span>                        <span class="token comment">//将所有的buffer进行clear</span>            <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>byteBuffers<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>buffer <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"byteRead = "</span> <span class="token operator">+</span> byteRead <span class="token operator">+</span> <span class="token string">", byteWrite = "</span> <span class="token operator">+</span> byteWirte <span class="token operator">+</span> <span class="token string">", messagelength = "</span> <span class="token operator">+</span> messageLength<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>NIO 网络编程应用实例 - 群聊系统</p></li></ol><p>实例要求：</p><ol><li>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>实现多人群聊</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li><li>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</li><li>示意图分析和代码  </li></ol><p>服务端代码:  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>pounds<span class="token punctuation">.</span>nio</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">InetSocketAddress</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token class-name">ByteBuffer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Iterator</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Set</span><span class="token punctuation">;</span><span class="token comment">/*** @Date 2021/4/18 19:08* @Author by pounds* @Description NIO 网络编程快速入门* 要求:* 实现服务端和客户端之间的数据简单通讯**/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NioNetWorkServer</span> <span class="token punctuation">{</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span><span class="token comment">//1. 获取Selector</span><span class="token class-name">Selector</span> selector <span class="token operator">=</span> <span class="token class-name">Selector</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2. 开启serverSocketChannel</span><span class="token class-name">ServerSocketChannel</span> serverSocketChannel <span class="token operator">=</span> <span class="token class-name">ServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">open</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3. 绑定端口</span>serverSocketChannel<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span><span class="token number">6666</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4. 将channel设置为非阻塞</span>serverSocketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//5. 注册serverSocketChannel,该channel只关心注册事件</span>serverSocketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span>OP_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"注册后的selectionKey 数量="</span> <span class="token operator">+</span> selector<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 开始循环等待客户端链接</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 每一次都只阻塞监听端口1秒</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>selector<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"本次监听端口 6666 没有监听到任何事件 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 到这里表示监听到了事件,遍历keySet判断key的类型进行相应的处理</span>            <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">&gt;</span></span> selectionKeys <span class="token operator">=</span> selector<span class="token punctuation">.</span><span class="token function">selectedKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SelectionKey</span><span class="token punctuation">&gt;</span></span> keyIterator <span class="token operator">=</span> selectionKeys<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>keyIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token class-name">SelectionKey</span> selectionKey <span class="token operator">=</span> keyIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 判断是不是监听事件的key</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>selectionKey<span class="token punctuation">.</span><span class="token function">isAcceptable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token class-name">SocketChannel</span> socketChannel <span class="token operator">=</span> serverSocketChannel<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"客户端连接成功 生成了一个 socketChannel "</span> <span class="token operator">+</span> socketChannel<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 将客户端channel也设置为非阻塞</span>                    socketChannel<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 注册客户端channel ,关注事件为 read,并绑定一个buffer</span>                    socketChannel<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>selector<span class="token punctuation">,</span><span class="token class-name">SelectionKey</span><span class="token punctuation">.</span>OP_READ<span class="token punctuation">,</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"客户端连接后 ，注册的selectionkey 数量="</span> <span class="token operator">+</span> selector<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">//上面sout的输出: 2,3,4..</span>                <span class="token punctuation">}</span>                <span class="token comment">// 判断是否是read是事件</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>selectionKey<span class="token punctuation">.</span><span class="token function">isReadable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token class-name">SocketChannel</span> channel <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SocketChannel</span><span class="token punctuation">)</span>selectionKey<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 拿到关联的buffer</span>                    <span class="token class-name">ByteBuffer</span> buffer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">)</span>selectionKey<span class="token punctuation">.</span><span class="token function">attachment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 往客户端的buffer里面写数据</span>                    channel<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"form 客户端 "</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buffer<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 防止重复处理事件,及时删除事件</span>                keyIterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端代码:  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">cn<span class="token punctuation">.</span>pounds<span class="token punctuation">.</span>nio</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>net<span class="token punctuation">.</span></span><span class="token class-name">InetSocketAddress</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span></span><span class="token class-name">ByteBuffer</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span></span><span class="token class-name">SocketChannel</span><span class="token punctuation">;</span><span class="token comment">/** * @Date 2021/5/5 17:31 * @Author by pounds * @Description NIO 网络编程快速入门 * 要求: *      实现服务端和客户端之间的数据简单通讯 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NioClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment">// 获取client端的channel            SocketChannel socketChannel = SocketChannel.open();            // 设置非阻塞            socketChannel.configureBlocking(false);            // 提供服务端的ip和端口            InetSocketAddress serverInetSocketAddress = new InetSocketAddress("127.0.0.1", 6666);            // 连接服务端            if (!socketChannel.connect(serverInetSocketAddress)) {                while (!socketChannel.finishConnect()) {                    System.out.println("连接失败,但是客户端不会阻塞,可以做些其他工作");                }            }            // 连接成功,发送数据            String info = "hello netty";            ByteBuffer byteBuffer = ByteBuffer.wrap(info.getBytes());            socketChannel.write(byteBuffer);            // 让代码停止            System.in.read();        } catch (IOException e) {            e.printStackTrace();        }    }}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> netty实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8 MySQL数据目录</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/8_MySQL%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/8_MySQL%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="8-1-数据库和文件系统的关系"><a href="#8-1-数据库和文件系统的关系" class="headerlink" title="8.1 数据库和文件系统的关系:"></a>8.1 数据库和文件系统的关系:</h2><p><code>Mysql</code>中像<code>InnoDB</code>和<code>MyISAM</code>这类存储引擎都是将数据存储在磁盘中,操作系统通过文件系统来管理磁盘,换句话说: 数据是存储在文件系统中的.</p><p>读数据是从文件系统中将数据读取到内存中,写数据是从内存中将数据写入到文件系统.</p><h2 id="8-2-Mysql的数据目录"><a href="#8-2-Mysql的数据目录" class="headerlink" title="8.2 Mysql的数据目录:"></a>8.2 Mysql的数据目录:</h2><p>Mysql服务器在启动的时候会从文件系统中的某个目录下加载一些数据,之后在运行过程中产生的数据也会存储到这个目录下的某些文件中.这个目录就是<code>数据目录</code>.</p><h3 id="8-2-1-数据目录和安装目录的区别"><a href="#8-2-1-数据目录和安装目录的区别" class="headerlink" title="8.2.1 数据目录和安装目录的区别:"></a>8.2.1 数据目录和安装目录的区别:</h3><p><code>安装目录</code>: 安装目录是mysql程序运行文件存放的地方</p><p><code>数据目录</code>: 数据目录是mysql程序在运行过程中产生的一些 <code>用户数据</code>,<code>程序运行状态数据</code>等数据存储的地方</p><h3 id="8-2-2-数据目录在哪儿"><a href="#8-2-2-数据目录在哪儿" class="headerlink" title="8.2.2 数据目录在哪儿:"></a>8.2.2 数据目录在哪儿:</h3><p><code>show variables like 'datadir'</code></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/8_MySQL%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/image-20210829003423480.png" alt="查看Mysql数据目录"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7 B+树索引的使用</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-B-树索引示意图的简化"><a href="#7-1-B-树索引示意图的简化" class="headerlink" title="7.1 B+树索引示意图的简化:"></a>7.1 B+树索引示意图的简化:</h2><h3 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据:"></a>示例数据:</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span><span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    key1 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    key2 <span class="token keyword">int</span><span class="token punctuation">,</span>    key3 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    key_part1 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    key_part2 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    key_part3 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 主键索引(聚簇索引)</span>    <span class="token keyword">key</span> idx_key1 <span class="token punctuation">(</span>key1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 二级索引(唯一索引)</span>    <span class="token keyword">unique</span> uk_key2 <span class="token punctuation">(</span>key2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 二级索引</span>    <span class="token keyword">key</span> idx_key3 <span class="token punctuation">(</span>key3<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 二级索引</span>    <span class="token keyword">key</span> idx_key_part <span class="token punctuation">(</span>key_part1<span class="token punctuation">,</span>key_part2<span class="token punctuation">,</span>key_part3<span class="token punctuation">)</span> <span class="token comment">-- 联合索引</span><span class="token punctuation">)</span><span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">charset</span><span class="token operator">=</span>utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第6章画出了详细的B+树索引结构,现在对索引结构进行简化如下图: <font color="red">里面的数据是假设的</font></p><p><strong>主键索引:</strong> 只画出了叶子结点中的记录真实数据部分</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814183104661.png"></p><p><strong>二级索引:</strong></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814183400595.png"></p><h2 id="7-2-索引的代价"><a href="#7-2-索引的代价" class="headerlink" title="7.2 索引的代价:"></a>7.2 索引的代价:</h2><h3 id="7-2-1-空间代价"><a href="#7-2-1-空间代价" class="headerlink" title="7.2.1 空间代价:"></a>7.2.1 空间代价:</h3><p>每一个索引都是一颗B+树,而B+树的结点都是一个最大为16KB的数据页,如果数据量很大的话,那么会使用很多的数据页来存储B+树的结点.占用空间很多</p><h3 id="7-2-2-时间代价"><a href="#7-2-2-时间代价" class="headerlink" title="7.2.2 时间代价:"></a>7.2.2 时间代价:</h3><ul><li><p>排序代价:</p><p>B+树中,每层结点都是按照索引列值的大小顺序排列形成一个双向链表,数据页中的记录同样是按照索引列值的大小顺序形成一个单向链表.</p><p>当我们在执行写操作的时候,必然会对记录造成修改,从而会影响到数据页中记录和数据页之间的顺序,然后存储引擎就需要去做一些额外的<code>页分裂</code>,<code>页回收</code>等操作.</p><p>如果索引创建过多,这样的时间消耗就很大.</p></li><li><p>索引选择时间消耗代价:</p><p>在执行查询操作的时候,首先会生成一个查询计划,而一般情况下,<code>mysql</code>在执行过程中只会使用一个二级索引,在执行<code>sql</code>语句的时候会去计算不同索引执行查询时所需要的时间,最后选取时间最少的索引执行.</p><p>如果索引过多,就会花很多的时间去分析.</p></li></ul><h1 id="7-3-B-树索引的应用"><a href="#7-3-B-树索引的应用" class="headerlink" title="7.3 B+树索引的应用:"></a>7.3 B+树索引的应用:</h1><h3 id="7-3-1-用于查询"><a href="#7-3-1-用于查询" class="headerlink" title="7.3.1 用于查询:"></a>7.3.1 用于查询:</h3><p>如果想要使用某个索引执行查询,但是又无法通过查询条件形成合适的扫描区间来减少需要扫描的记录数量时,则不考虑是使用这个索引来执行查询</p><p><strong>全表扫描:</strong> </p><ul><li><p>对于某个查询来说简单粗暴的方式就是扫描表中的所有的记录,判断每一条记录是否符合搜索.如果符合,就返回结果,不符合就跳过该条记录.</p></li><li><p>对于<code>InnoDB</code>搜索引擎的表来说,全表扫描就是从聚簇索引中叶子结点第一条记录依次遍历下去,直到最后一条记录</p></li></ul><p><strong>区间扫描:</strong></p><ul><li><p>由于B+树叶子结点中的记录是按照索引列值的大小顺序进行排列的,可以利用B+树查找索引列值等于某个值的第一条记录,向前或者向后的某个区间内进行记录扫描,来减少记录扫描的范围.</p></li><li><p>比如:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> id <span class="token operator">&gt;=</span> <span class="token number">2</span> <span class="token operator">and</span> id <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个语句意义是寻找 id 在区间[2,100]的数据, <code>mysql</code>会通过聚簇索引首先定位id = 2 的用户记录,然后沿着叶子结点向后扫描,直到id &gt; 100.</p><p><code>扫描区间</code>: 在这个<code>select</code>语句中[2,100] 就是扫描区间</p><p><code>边界条件</code>: <code>id &gt;= 2 and id &lt;= 100</code>就是形成扫描区间的边界条件</p><p>对于<code>全表扫描</code>来说,这是一个特殊的<code>区间扫描</code>,因为他扫描的区间涵盖了所有的数据,即 <code>(-∞,+∞)</code>.</p></li><li><p>生成扫描区间的<code>sql</code>举例:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1438</span><span class="token punctuation">,</span><span class="token number">6328</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key2 <span class="token operator">&gt;=</span> <span class="token number">38</span> <span class="token operator">and</span> key2 <span class="token operator">&lt;=</span> <span class="token number">79</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个语句<code>where</code>条件后面使用的key2列,之前的示例数据中,又为key2列创建了索引<code>uk_key2</code>,会形成下面这三个区间:</p><ul><li><p>[1438,1438] : 边界条件是 <code>key2 in (1438)</code> , 这种扫描区间中只有一个值的称为 <code>单点扫描区间</code></p></li><li><p>[6382,6382] : 边界条件是 <code>key2 in (6382)</code></p></li><li><p>[38,79] : 边界条件是 <code>key2 &gt;= 38 and key2 &lt;= 79</code> , 这种扫描区间中含有多个值的区间称为 <code>范围扫描区间</code></p></li><li><p>对应到数轴上就是:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814212755388.png"></p></li></ul></li><li><p>无法生成扫描区间<code>sql</code>举例:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">&lt;</span> <span class="token string">'a'</span> <span class="token operator">and</span> key3 <span class="token operator">&gt;</span> <span class="token string">'z'</span> <span class="token operator">and</span> common_field <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>如果使用<code>idx_key1</code>去查询:</p><p>那么扫描区间为 <code>(-∞,'a')</code>,边界条件是 <code>key1 &lt; 'a'</code>,  key3 &gt; ‘z’ and common_field = ‘abc’ 只是普通搜索条件,普通搜索条件在获取到<code>idx_key1</code>的二级索引记录之后,回表查询获取到完整的用户记录后才能判断是否符合普通搜索条件.</p></li><li><p>如果使用<code>idx_key3</code>去查询:</p><p>那么扫描区将为<code>('z',+∞)</code>,边界条件是 <code>key3 &gt; 'z'</code>, 普通条件 key1 &lt; ‘a’ and common_field = ‘abc’. </p></li></ul></li></ul><p><strong>如何产生扫描区间:</strong></p><p>对于B+索引,只要索引列 和 常量 使用 <code>=</code>, <code>&lt;=&gt;</code>,<code>IN</code>, <code>NOT IN</code>, <code>IS NULL</code>, <code>IS NOT NULL</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;&gt;</code>, <code>BETWEEN</code>, <code>LIKE</code>连接起来就能产生扫描区间.</p><p>注意:</p><ul><li><p><code>IN</code> 的语义 和 若干个等值匹配操作之间使用 <code>OR</code> 连接起来是一样的</p></li><li><p><code>!=(&lt;&gt;)</code>产生 的扫描区间比较特殊:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 生成的扫描区间为: (-∞,'a') ∪ ('a',+∞)</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">!=</span> <span class="token string">'a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>LIKE</code>操作只有在完全匹配和前缀匹配才能产生扫描区间</p></li></ul><p><strong>如何从若干个OR或者AND连接的语句之间提取扫描区间:</strong></p><h5 id="1-所有查询条件都可以生成合适的扫描区间"><a href="#1-所有查询条件都可以生成合适的扫描区间" class="headerlink" title="1. 所有查询条件都可以生成合适的扫描区间:"></a>1. 所有查询条件都可以生成合适的扫描区间:</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">and</span> key2 <span class="token operator">&gt;</span> <span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的扫描区间为:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814221320446.png"></p><blockquote><p>and连接的查询条件是对两个扫描区间取交集</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">or</span> key2 <span class="token operator">&gt;</span> <span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的扫描区间为:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814221405324.png"></p><blockquote><p>or连接的查询条件是对两个扫描区间取并集</p></blockquote><h5 id="2-部分查询条件能够生成扫描区间"><a href="#2-部分查询条件能够生成扫描区间" class="headerlink" title="2. 部分查询条件能够生成扫描区间:"></a>2. 部分查询条件能够生成扫描区间:</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">and</span> common_field <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果使用<code>uk_key2</code>索引进行查询:</p><ul><li>查询条件<code>key2 &gt; 100</code>生成的扫描范围是 (100,+∞)</li><li>查询条件<code>common_field = 'abc'</code>由于<code>uk_key2</code>索引中的二级索引记录根本就不按照<code>common_field列</code>进行排列所以这个查询条件根本就不能使扫描范围减小.也就是产生的扫描范围是: <code>(-∞,+∞)</code>.</li><li>最终产生的扫描范围是 (100,+∞)</li></ul><p>如果将sql中<code>and</code>连接换成<code>or</code>连接,产生的扫描范围是 (-∞,+∞)</p><h5 id="3-复杂查询条件中找出扫描范围"><a href="#3-复杂查询条件中找出扫描范围" class="headerlink" title="3. 复杂查询条件中找出扫描范围:"></a>3. 复杂查询条件中找出扫描范围:</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'xyz'</span> <span class="token operator">and</span> key2 <span class="token operator">=</span> <span class="token number">738</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">&lt;</span> <span class="token string">'abc'</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'lmn'</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">like</span> <span class="token string">'%suf'</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'zzz'</span> <span class="token operator">and</span> <span class="token punctuation">(</span>key2 <span class="token operator">&lt;</span> <span class="token number">8000</span> <span class="token operator">or</span> common_field <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>分析思路:</p><ul><li><p>找出where中使用了哪些列,以及表中创建了哪些索引.</p><p>在这个sql中查询条件使用了 key1,key2,common_field列,key1列有<code>idx_key1</code>,key2列有<code>uk_key2</code>.</p></li><li><p>将可能使用到的索引进行假设,分析他们的扫描区间</p></li></ul><p><strong>假设使用<code>idx_key1</code>索引:</strong></p><p>首先分析哪些搜索条件是不能产生扫描范围的:</p><p>比如上面的sql,<code>key2 = 738</code>, <code>key2 &lt; 8000</code>, <code>common_field = 'abc'</code>以及<code>key1 like '%suf'</code>是不能产生扫描范围的,直接将他们替换成<code>true</code>,则sql为:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'xyz'</span> <span class="token operator">and</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">&lt;</span> <span class="token string">'abc'</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'lmn'</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'zzz'</span> <span class="token operator">and</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- 简化:</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'xyz'</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">&lt;</span> <span class="token string">'abc'</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'lmn'</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'zzz'</span><span class="token punctuation">)</span> <span class="token comment">-- key1 &lt; 'abc' and key1 &gt; 'lmn'永远是false</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'xyz'</span><span class="token punctuation">)</span> <span class="token operator">or</span>  <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'zzz'</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为’xyz’ &lt; ‘zzz’ , 又是使用or连接, 取二者之间的并集, 所以产生的扫描范围是: (‘xyz’,+∞)</p><p><strong>假设使用<code>uk_key2</code>索引:</strong></p><p>替换掉不能差生扫描范围的查询条件之后sql为:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">and</span> key2 <span class="token operator">=</span> <span class="token number">738</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">and</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">and</span> <span class="token boolean">true</span> <span class="token operator">and</span> <span class="token punctuation">(</span>key2 <span class="token operator">&lt;</span> <span class="token number">8000</span> <span class="token operator">or</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- key2 &lt; 8000 or true 一定为true</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> key2 <span class="token operator">=</span> <span class="token number">738</span> <span class="token operator">or</span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为查询条件恒成立,那么就是个全表扫描,扫描范围是: (-∞,+∞).但是使用了二级索引,比主键全表扫描还多了一次回表操作,所以显然不适合使用<code>uk_key2</code>作为查询索引</p><h5 id="4-使用联合索引执行查询索引时的扫描范围"><a href="#4-使用联合索引执行查询索引时的扫描范围" class="headerlink" title="4. 使用联合索引执行查询索引时的扫描范围:"></a>4. 使用联合索引执行查询索引时的扫描范围:</h5><p>联合索引的排序规则:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">key</span> idx_key_part <span class="token punctuation">(</span>key_part1<span class="token punctuation">,</span>key_part2<span class="token punctuation">,</span>key_part3<span class="token punctuation">)</span> <span class="token comment">-- 联合索引</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上面这个索引为例:</p><ul><li>先对<code>key_part1</code>列的值进行排序</li><li><code>key_part1</code>相同,再根据<code>key_part2</code>列的值进行排序</li><li><code>key_part1</code>和<code>key_part2</code>列的值都相同的情况下,再使用<code>key_part3</code>列的值进行排序</li></ul><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814233953955.png"></p><p>举例</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用联合索引确定的扫描范围为 <code>['a','a']</code>,扫描边界为<code>key_part = 'a'</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part2 <span class="token operator">=</span> <span class="token string">'b'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用联合索引确定的扫描范围为 <code>[('a','b'),('a','b')]</code>,扫描边界为<code>key_part1 = 'a' and key_part2 = 'b'</code>.</p><p><code>[('a','b'),('a','b')]</code>表示: 在<code>idx_key_part</code>索引中,从第一条满足边界条件,到最后一条满足边界条件为止的所有二级索引记录</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part2 <span class="token operator">=</span> <span class="token string">'b'</span> <span class="token operator">and</span> key_part3 <span class="token operator">=</span> <span class="token string">'c'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 使用联合索引确定的扫描范围为 <code>[('a','b','c'),('a','b','c')]</code>,扫描边界为<code>key_part1 = 'a' and key_part2 = 'b' and key_part3 = 'c'</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">&lt;</span> <span class="token string">'a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 使用联合索引确定的扫描范围为 <code>(-∞,'a')</code>,扫描边界为<code>key_part1 = 'a' and key_part2 = 'b' and key_part3 = 'c'</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part2 <span class="token operator">&gt;</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part2 <span class="token operator">&lt;</span> <span class="token string">'d'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 使用联合索引确定的扫描范围为 <code>(('a','a'),('a','d'))</code>,扫描边界为<code>key_part1 = 'a' and key_part2 &gt; 'a' and key_part2 &lt; 'd'</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part2 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为联合索引排序优先级第一位的并不是<code>key_part2</code>列,所以无法减少扫描范围,因此这条sql不适合使用<code>idx_key_part</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part3 <span class="token operator">=</span> <span class="token string">'c'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条sql能够通过<code>key_part1 = 'a'</code>减少扫描范围,但是由于<code>key_part='a'</code>之后是按照<code>key_part2</code>列的值大小顺序排列的,所以<code>key_part3 = 'c'</code>并不能减少扫描范围.</p><p>所以实际得到的扫描范围是: <code>['a','a']</code>.边界条件是 <code>key_part1 = 'a'</code></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">&lt;</span> <span class="token string">'b'</span> <span class="token operator">and</span> key_part2 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个比较特殊,先看下叶子结点中二级索引的排列, 如果数据为红字的情况就会造成 <code>key_part1 &lt; 3 and key_part2 = 2</code>的查询条件,在使用符合索引的时候,只走key_part1,而不走key_part2,这是因为在<code>key_part1 &lt; 3</code>的前提下二级索引记录根本不是按照<code>key_part2</code>列的值排列的.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210815001847253.png"></p><p>所以实际上对扫描范围起到作用的只有查询条件<code>key_part1 &lt; 'b'</code>.扫描范围为: <code>[-∞,'b')</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">&lt;=</span> <span class="token string">'b'</span> <span class="token operator">and</span> key_part2 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条sql跟上面那条sql基本上是一个意思,但是在<code>key_part1 = 'b'</code>的时候,二级索引是按照<code>key_part2</code>值的顺序进行排列的,但是在<code>key_part1 &lt; 'b'</code>的时候,<code>key_part2</code>仍然是起不到作用的.生成的扫描范围是:</p><ul><li><p><code>[-∞,'b')</code>,边界条件: <code>key_part1 &lt; 'b'</code></p></li><li><p><code>[('b','a'),('b','a')]</code>,边界条件: <code>key_part1 = 'b' and key_part2 = 'a'</code></p></li></ul><p>两个扫描范围求并集: <code>((-∞,-∞),('b','a'))</code></p><h3 id="7-3-2-用于排序"><a href="#7-3-2-用于排序" class="headerlink" title="7.3.2 用于排序:"></a>7.3.2 用于排序:</h3><p>由于查询出来的数据不一定是按照我们需要的顺序进行排序的,就需要对数据进行重新排序,<code>mysql</code>中通常是将记录加载到内存中,通过排序算法进行排序操作,如果记录太多甚至还会借助磁盘空间来存放排序结果,在排序操作完成后再把排好序的结果返回给客户端.</p><p><code>文件排序(filesort)</code>: 在内存或者磁盘中进行排序的方式统称为文件排序.文件排序会影响查询速度.</p><blockquote><p> 如果<code>order by</code>后面的字段加上了索引,就可以避免<code>filesort</code></p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">order</span> <span class="token keyword">by</span> key_part1<span class="token punctuation">,</span>key_part2<span class="token punctuation">,</span>key_part3 <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于二级索引中索引记录本身就是按照索引列进行排列的,也就是说数据本身就是按照<code>order by</code>后面的顺序排列的自然无序再次进行额外的排序.</p><h4 id="1-使用索引进行排序时的注意事项"><a href="#1-使用索引进行排序时的注意事项" class="headerlink" title="1. 使用索引进行排序时的注意事项:"></a>1. 使用索引进行排序时的注意事项:</h4><ul><li><p>如果要想使用联合索引优化排序过程,那么必须要将<code>order by</code>后面排序列的顺序按照联合索引声明的顺序.</p></li><li><p>使用联合索引进行排序的时候,可以使用部分联合索引进行排序,比如: (part1,part2,part3),只使用<code>part1</code>,或者<code>part1,part2</code>进行排序,用来排序的列一定要是从左边开始连续的</p></li><li><p>如果使用联合索引进行排序时,查询条件是联合索引从左开始并且连续的常量,那么就可以使用剩下的索引进行排序,比如:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part <span class="token operator">=</span> <span class="token string">'b'</span> <span class="token keyword">order</span> <span class="token keyword">by</span> key_part3 <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询结果已经按照<code>key_part1</code>,<code>key_part2</code>的顺序排列好了,按照联合索引的排列规则,数据实际上已经按照<code>key_part3</code>排列好了,使用<code>order by key_part3</code>进行排序自然不需要额外的排序.</p></li></ul><h4 id="2-无法使用索引进行排序的情况"><a href="#2-无法使用索引进行排序的情况" class="headerlink" title="2. 无法使用索引进行排序的情况:"></a>2. 无法使用索引进行排序的情况:</h4><ol><li><p>排序规则(ASC,DESC)混用:</p><p>使用联合索引进行排序,要求各排序列的排序规则是一致的,即 <code>要么都是ASC,或者要么都是DESC</code>.</p></li><li><p>排序列包不是同一个索引:</p></li><li><p>排序列在同一个索引中,但是不是按照声明的顺序连续出现:</p></li><li><p>用来形成扫描区间的索引列和排序列不同:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">order</span> <span class="token keyword">by</span> key2 <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>排序列不是以单独列名的形式出现在order by 语句中:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">order</span> <span class="token keyword">by</span> UPPER<span class="token punctuation">(</span>key1<span class="token punctuation">)</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结:"></a>3. 总结:</h4><p>将索引用于排序,主要是利用索引中的数据都是按照索引列值顺序排列好了的,不需要在进行额外的排序,这一特点.</p><h3 id="7-3-3-索引用于分组"><a href="#7-3-3-索引用于分组" class="headerlink" title="7.3.3 索引用于分组:"></a>7.3.3 索引用于分组:</h3><p>规则与用于排序差不多,分组列必须与索引列的顺序一致,也只能使用索引列中左边连续的列进行分组.</p><h2 id="7-4-回表的代价"><a href="#7-4-回表的代价" class="headerlink" title="7.4 回表的代价:"></a>7.4 回表的代价:</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">&gt;</span> <span class="token string">'a'</span> <span class="token operator">and</span> key1 <span class="token operator">&lt;</span> <span class="token string">'c'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>全表扫描:</p><p>扫描全部的聚簇索引,然后逐一对聚簇索引记录进行条件判断,不满足就跳过,满足就返回给客户端</p></li><li><p>使用<code>idx_key1</code>索引进行查询:</p><p>在使用<code>idx_key1</code>索引进行查询时 将数据扫描的范围缩小到了(‘a’,’c’)之间, 但是由于查询的是用户记录所有的列,而二级索引记录中只存放了索引列和主键值,所以必须要根据主键值进行重新去聚簇索引中查询(回表).</p><p><code>Mysql</code>中使用页作为空间管理的基本单位,对于<code>InnoDB</code>引擎的表,索引中的数据页必须是存放在磁盘中的,在需要的时候通过页号对应数据页在磁盘中的偏移量加载到内存中来.<code>Mysql</code>会尽量保证数据页是按照页号顺序进行排列的,因此一次磁盘I/O就可以加载很多的二级索引记录到内存中,扫描二级索引记录的代价就不会太大.</p><p>但是在执行回表操作的时候,二级索引记录中存储的主键值是丝毫没有顺序的,极端的情况下,扫描区间中的二级索引记录有n条,主键值存在对应的数据页就有n页,因此可能要执行n次磁盘i/0.磁盘i/o的时间消耗是特别大的</p><p><code>mysql</code>在执行查询的时候,首先会进行查询语句的优化,查询优化器会对表中的记录事先进行一些计算,通过计算出来的统计数据,或者访问少量的记录来获得查询时的回表数量,如果回表数量特别多,就选择<code>全表扫描</code>,否则选择索引.</p><blockquote><p>为了避免全表扫描:</p><ol><li>通过<code>limit</code>减少返回的数量,从而减少回表次数,让查询走索引</li><li>通过<code>limit</code>减少返回的数量,也可以让排序使用索引</li></ol></blockquote></li></ul><h2 id="7-5-更好的创建和使用索引"><a href="#7-5-更好的创建和使用索引" class="headerlink" title="7.5 更好的创建和使用索引:"></a>7.5 更好的创建和使用索引:</h2><h3 id="7-5-1-只为查询-排序-分组列创建索引"><a href="#7-5-1-只为查询-排序-分组列创建索引" class="headerlink" title="7.5.1 只为查询,排序,分组列创建索引:"></a>7.5.1 只为查询,排序,分组列创建索引:</h3><p>通常只会为<code>where</code>字句中的列,连接字句中的连接列,分组列或者排序列创建索引.</p><p>只出现在查询列表中的列就没有必要创建索引了,比如: </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> common_field<span class="token punctuation">,</span> key_part4 <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个sql中<code>common_field</code>,<code>key_part4</code>就没有必要创建索引了.</p><h3 id="7-5-2-考虑索引列值不重复的数量"><a href="#7-5-2-考虑索引列值不重复的数量" class="headerlink" title="7.5.2 考虑索引列值不重复的数量:"></a>7.5.2 考虑索引列值不重复的数量:</h3><p>如果索引列重复值太多,那么在通过该索引进行查询的时候,一个常量查询条件都有可能有很多条,这样会造成大量的回表操作,从而导致效率不如全表扫描.</p><p>如果想要加索引的列,值重复数率太高就不要给他加索引了.</p><h3 id="7-5-3-索引列尽量选择占用空间小的类型"><a href="#7-5-3-索引列尽量选择占用空间小的类型" class="headerlink" title="7.5.3 索引列尽量选择占用空间小的类型:"></a>7.5.3 索引列尽量选择占用空间小的类型:</h3><p><code>mysql</code>都是以页为单位进行磁盘I/O加载数据的,如果数据类型占用的空间越小,一页中存放的记录数就越多.<code>在取值范围允许的情况下</code>,索引列尽量选择占用空间小的类型</p><p><font color="red">尤其是主键列,主键列不仅仅是聚簇索引中会记录主键值,所有的二级索引记录都会保存主键值,因此主键列更应该选择占用空间小的类型</font></p><h3 id="7-5-4-为列前缀建立索引"><a href="#7-5-4-为列前缀建立索引" class="headerlink" title="7.5.4 为列前缀建立索引:"></a>7.5.4 为列前缀建立索引:</h3><p>处于减少二级索引记录中存放索引值长度,从而增加数据页中存放索引的数量,减少磁盘I/O的目的,可以列值前缀建立索引.</p><p>比如:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 先删除在重新创建索引</span><span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">drop</span> <span class="token keyword">index</span> idx_key1<span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">add</span> <span class="token keyword">index</span> idx_key1<span class="token punctuation">(</span>key1<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>因为索引列值的字符串前缀实际上也是排好序的,所以可以在二级索引记录中只保留字符串前面几个字符.根据字符串前缀定位出二级索引记录中以索引值为前缀的记录,然后在判断他是否完整的匹配查询条件.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">=</span> <span class="token string">'abcdefghijklmn'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先会定位出以<code>abcdefghij</code>为前缀的二级索引记录,然后判断他们是否完全匹配<code>abcdefghijklmn</code></p><p><font color="red">这种索引无法用于排序.排序对于字符串比较的是整个字符串的全部字符,但是这种二级索引只是按照字符串的前面几个字符排好顺序</font></p><h3 id="7-5-5-覆盖索引"><a href="#7-5-5-覆盖索引" class="headerlink" title="7.5.5 覆盖索引:"></a>7.5.5 覆盖索引:</h3><p><code>覆盖索引</code>: 查询列表中的列包含在索引中,就称这种查询方式为 覆盖索引.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> key1<span class="token punctuation">,</span>id <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">=</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过<code>idx_key1</code>进行查询的时候,二级索引记录中包含了 <code>key1</code>,<code>id</code>这两列的值,所以在定位到叶子结点中的二级索引记录时就获取到了查询结果,无需进行回表操作.</p><h3 id="7-5-6-索引列名单独出现在查询条件中"><a href="#7-5-6-索引列名单独出现在查询条件中" class="headerlink" title="7.5.6 索引列名单独出现在查询条件中:"></a>7.5.6 索引列名单独出现在查询条件中:</h3><p>单独出现的意思是: 不要让索引列在查询条件中参与运算</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 不走索引:</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token comment">-- 走索引:</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token operator">/</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>sql 1 会被<code>mysql</code>认为 key2*2 是一个列,从而不会走<code>idx_key2</code></p><h3 id="7-5-7-新插入记录时主键大小对效率的影响"><a href="#7-5-7-新插入记录时主键大小对效率的影响" class="headerlink" title="7.5.7 新插入记录时主键大小对效率的影响:"></a>7.5.7 新插入记录时主键大小对效率的影响:</h3><p>主键值大小(新插入数据的主键值)对插入效率的影响,主要问题出现在无序插入,如果插入时刚好要插入的数据页满了,待插入记录的主键值又恰好位于该数据页的中间,就会造成页分裂,从而导致插入效率降低.</p><h3 id="7-5-8-冗余和重复索引"><a href="#7-5-8-冗余和重复索引" class="headerlink" title="7.5.8 冗余和重复索引:"></a>7.5.8 冗余和重复索引:</h3><p>尽量避免冗余和重复的索引,比如不要对联合索引包含的索引再创建单独的索引</p>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6 B+树索引</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813231933719.png"></p><p>前面说过,每页都有一个<code>page directory</code>作为页中记录的目录,可以通过二分法快速定位页中某条记录,现在可以快速定位页中的记录了,但是如何定位到页就成了问题,索引就是解决这个问题的</p><h2 id="6-1-没有索引如何查找"><a href="#6-1-没有索引如何查找" class="headerlink" title="6.1 没有索引如何查找"></a>6.1 没有索引如何查找</h2><h3 id="6-1-1-在页中查找"><a href="#6-1-1-在页中查找" class="headerlink" title="6.1.1 在页中查找:"></a>6.1.1 在页中查找:</h3><p>在页中查找一般是分为两种情况:</p><ul><li>以主键为搜索条件: 页目录中的槽快速定位某个主键,然后根据主键去快速定位某条记录</li><li>以其他列作为条件: 对非主键列的查找无法通过页目录中的槽定位主键,只能从<code>Infimum</code>开始一个一个的遍历.</li></ul><p>在很多页中查找:</p><p>在很多页中查找首先需要定位数据在那一页,然后才能在数据页中查找到数据.如果没有引入索引的话,无论是以主键为条件,或者以其他列为条件都无法快速定位数据在那一页,只能从第一页开始沿着双端链表逐一遍历.</p><h2 id="6-2-索引"><a href="#6-2-索引" class="headerlink" title="6.2 索引:"></a>6.2 索引:</h2><h3 id="6-2-1-一个简易的索引方案"><a href="#6-2-1-一个简易的索引方案" class="headerlink" title="6.2.1 一个简易的索引方案:"></a>6.2.1 一个简易的索引方案:</h3><p>为了演示效果,数据示意图将会以下面的形式出现:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813234348296.png"></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813234402899.png"></p><p>示例数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>index_demo<span class="token punctuation">`</span><span class="token punctuation">(</span>c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>    C2 <span class="token keyword">INT</span><span class="token punctuation">,</span>    C3 <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    PRIMERY <span class="token keyword">KEY</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">Insert</span> <span class="token keyword">into</span> <span class="token punctuation">`</span>index_demo<span class="token punctuation">`</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'U'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token string">'D'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Y'</span><span class="token punctuation">)</span><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token punctuation">`</span>index_demo<span class="token punctuation">`</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了演示效果,假设一个数据页中只能存放3条数据,大于3条就要开辟新的页来存放数据. 所以在插入上面三条记录之后,在页面中已经形成一条单向链表,且已经满了在执行第二条插入语句的时候,就会形成下面这种情况:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813234416566.png"></p><blockquote><ol><li>新生成的页号为什么是28? 因为在磁盘中多次申请磁盘空间可能不是连续的,因此页号页可能不是连续的</li><li><code>Mysql</code>规定页号大的数据页中数据主键值要比页号小的数据页中数据主键值大,否则就需要将不满足要求的数据与旧数据页中满足要求的数据进行交换</li></ol></blockquote><p>为了满足页 号大的数据页中数据主键值要比页号小的数据页中数据主键值大,交换的过程如下:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813235037699.png"></p><p>多次向 <code>index_demo</code>表中插入数据之后,如图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813235310187.png"></p><p>由于数据页之间是一个双端链表的结构,想要定位数据页只能逐一遍历,为了提高定位数据的效率,给数据页建立对应的目录,每个目录包含下列两部分:</p><ul><li>页的用户记录中最小的主键值,用 <code>key</code> 来表示;</li><li>页号,用 <code>page_no</code> 表示</li></ul><p>加上目录后如图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813235608778.png"></p><p>为了能够像<code>page directory</code>中访问槽一样的访问, 数据页的目录项, 我们需要将这些目录项在<code>物理存储器</code>上连续存储.这个时候在<code>多页中定位数据的步骤</code>为:</p><ul><li>先从根据二分法快速定位目录项,从而找到记录所在的数据页</li><li>然后去数据页中找数据</li></ul><h3 id="6-2-2-InnoDB中索引方案"><a href="#6-2-2-InnoDB中索引方案" class="headerlink" title="6.2.2 InnoDB中索引方案:"></a>6.2.2 InnoDB中索引方案:</h3><p>上面说到为了快速定位数据页从而给数据页的搞了一个目录项,并且要求目录项在物理存储中是可以连续存放的,但是会出现两个问题:</p><ul><li><code>InnoDB</code>使用页作为管理存储空间的基本单位,即 最多只能保证16KB的连续空间来存放数据. 如果记录数量一旦特别多,所有的目录项连续存储可能会出现问题</li><li>我们可能会经常对数据进行增删改操作,如果某个页面中的数据都删除了,那么该页也没有存在的必要了,就意味着存放目录项的连续空间需要把之后的目录项都向前移动一下.太影响效率</li></ul><p><code>MySQL</code>对于这一问题的解决方案是 复用存储用户记录的数据页来存储目录项,将目录项当成用户记录分页存储(<code>只不过将用户记录换成了只有主键列和页号列的目录项</code>),以保证目录向是连续的,在每一页中同样会按照目录向记录中的主键值进行排列.</p><p>为了区分目录项和用户记录, <code>Mysql</code>将目录项统称为<code>目录项记录</code>,即 在记录头信息中<code>record_type</code>字段的值设置为1.</p><p>将目录项记录存放进数据页中之后,整个结构如图:</p><p> <img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814004524301.png"></p><p><font color="red">目录项记录和用户记录的区别与联系:</font></p><ul><li>区别:<ul><li>目录项记录头的<code>record_type</code>值为1,用户记录记录头的<code>record_type</code>值为0.</li><li>目录记录只有索引列和页编号两列,用户记录可能有多个列(<code>用户自定义列</code>,<code>mysql添加的隐藏列</code>)</li><li>每页目录记录中最小的那一条记录的记录头信息中<code>min_rec_flag</code>字段值为1.用户记录记录头<code>min_rec_flag</code>字段值为0</li></ul></li><li>联系:<ul><li>除了上面几点不同之外,其余的性质并没有区别.使用的是一样的数据页,<code>页面类型都在FILE HEADER中,值为 0x45BF</code>,页的结构也是一样的,主键同样会生成对应的页目录.</li></ul></li></ul><blockquote><p>目录记录的真实数据只会存放两个值, 一个是索引列的值,一个是页码</p></blockquote><p>有了目录项记录的数据页之后,举个查询主键为20的记录的例子,此时查询的过程为:</p><ul><li>在存放<code>目录项记录</code>的数据页中通过<code>页目录</code>定位到具体的目录项记录,然后根据目录项记录中的数据页页码,找到对应存放<code>用户记录</code>的数据页(即9页)</li><li>再到9页中通过<code>页目录</code>定位到主键为20的记录,完成查找.</li></ul><p>一旦目录项多了超出了页面能存放的范围,就会像用户记录一样申请新的数据页来存放目录项,<code>多个存放目录项的数据页的结构如图</code>:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814010439409.png"></p><p>如果存放目录项的数据也变得非常多了,<code>Mysql</code>就会为这些存放目录项的数据页,创建他们对应的目录项,生成一个更高级的目录,以此类推逐渐形成一颗树一样的结构 —- 这就是<code>B+</code>树结构.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814010955356.png"></p><p><strong>B+树,示意图:</strong></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814011024445.png"></p><blockquote><p><code>mysql</code>规定B+树的叶子结点为0层,之后逐渐+1.</p></blockquote><p>假设一个数据页能够存放10条用户记录,所存放目录项记录的数据页能够存放1000条,那么B+树每层存储数据数量为:</p><ul><li>如果B+树只有1层,也就只有1个数据页,那么只能存储100条</li><li>如果B+树有2层,那么记录数为 1000 * 100 = 100,000条</li><li>如果B+树有3层,那么记录数为 1000 * 1000 * 100 = 100,000,000条</li><li>如果B+树有4层,那么记录数为 1000 * 1000 * 1000 * 100 = 100,000,000,000条</li></ul><p>可以发现B+树4层就能够存储很多的数据,<code>mysql</code>在日常使用中B+树的层数是不会超过4层的,也就是只需要去4个数据页(3个目录项数据页,1个用户记录数据页)中就能够找到指定数据(<code>要以主键为条件</code>)</p><h4 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引:"></a>1. 聚簇索引:</h4><p>前面介绍的以主键大小来排序的B+树本身就是一个目录,或者本身就是一个索引,具有以下特点:</p><ul><li>使用记录主键值的大小进行记录和页的排序:<ul><li>数据页中的任何记录都是按照主键值的大小顺序排成一个单向链表,页内记录被分成若干组,每个组里中主键值最大的记录的偏移量当做目录存放页<code>页目录</code>的槽里面</li><li>存放记录的数据页也是按照页中记录的主键大小顺序排成一个双向链表</li><li>存放目录记录的数据页分为不同层级,在同一层级的页也是按照页中目录记录的主键大小排成一个双端链表</li></ul></li><li>B+树的叶子结点存放的是 <code>完整的用户记录</code>(完整的用户记录是指: 这个记录中存储了所有列的值,包括隐藏列).</li></ul><p>具有这两个特点的索引就是<code>聚簇索引</code>,<code>InnoDB</code>默认就是聚簇索引.并且在<code>InnoDB</code>中聚簇索引就是数据的存储方式(<code>所有用户数据存放于叶子结点中</code>), 即<code>索引即数据,数据即索引</code></p><h4 id="2-二级索引"><a href="#2-二级索引" class="headerlink" title="2. 二级索引:"></a>2. 二级索引:</h4><p>当我们不以主键为索引创建出来的索引,具有以下特点:</p><ul><li>以普通列x的大小为记录和页的排序依据:<ul><li>页内记录都是按照x值的大小顺序形成单链表,记录被分成多个小组,将组内x值最大的记录的偏移量存放在<code>页目录</code>中.</li><li>每个数据页都是按照x值的大小顺序形成一个双向链表</li><li>存放目录项的数据页都会按照目录项记录中索引列的值大小顺序形成一个双向链表</li></ul></li><li>B+树的叶子结点存放的并不是完整的用户记录,真实的数据部分只有两个值,一个是索引列的值,一个是主键列的值.</li></ul><p>具有以上特点的索引就是 <code>二级索引</code>. <code>二级索引</code>是一个新的B+树,并不是主键形成的B+树,也就是说每个<code>二级索引</code>都是一颗B+树.</p><p><code>二级索引</code>的查找过程:</p><ol><li><p>根据索引值快速定位到索引值所在的非叶子节点,如果该叶子结点没有满足条件的<code>不完整的用户记录</code>,就会沿着双向链表去下一个叶子结点中找是否有满足索引条件的用户记录</p></li><li><p>在非叶子结点中找到了符合条件的用户记录, 就会根据主键值去主键形成的聚簇索引中查找到<code>完整的用户记录</code></p></li><li><p>如果<code>二级索引</code>没有唯一性的约束,那么在主键聚簇索引中找到了一条<code>完整的记录</code>后还要回到<code>二级索引</code>中沿着叶子结点形成的双向链表中继续寻找下一个满足搜索条件的<code>不完整记录</code>,然后再一次去主键聚簇索引中查找,以此往复.</p><blockquote><p>根据<code>二级索引</code>非叶子节点中<code>不完整的用户记录</code>存储的主键值去主键聚簇索引中查找<code>完整用户记录</code>的过程 称为 <code>回表</code>.</p></blockquote></li></ol><h4 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3. 联合索引:"></a>3. 联合索引:</h4><p><code>联合索引</code>本质上也就是一个<code>二级索引</code></p><p>处理可以使用单列作为索引,还可以使用多个列作为索引,不过他们之间是有排序优先级的,比如(a,b)这样的联合索引,会先以a为标准排序,如果a相同才会以b为标准进行排序.</p><p>以示例数据来讲: 按照(c2,c3)构成的联合索引,如图</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814015627353.png" alt="联合索引示意图"></p><p>说明:</p><ul><li>联合索引的每条目录项的真实数据部分都包含 c2,c3, 页号这三个数据.</li><li>c2先排序,c2相同再比较c3</li><li>联合索引叶子结点中用户记录的真实数据部分包含 c2,c3 ,主键值这三个数据</li><li>联合索引只会建立一个B+树,而不是创建多个B+树</li></ul><h3 id="6-2-3-B-树索引注意事项"><a href="#6-2-3-B-树索引注意事项" class="headerlink" title="6.2.3 B+树索引注意事项:"></a>6.2.3 B+树索引注意事项:</h3><h4 id="1-根页面永远不动"><a href="#1-根页面永远不动" class="headerlink" title="1. 根页面永远不动:"></a>1. 根页面永远不动:</h4><p>B+树的形成过程:</p><ol><li>为每个表创建B+树索引的时候, 最开是都会创建一个根节点页面.最开始没有数据的时候,根节点页面是什么都没有的</li><li>随后插入数据的过程中,先向根页面中插入数据.</li><li>当根页面中的可用空间使用完了,就会将根节点中所有数据复制到新分配的页面a中,然后对这个新页面进行页分裂作用,得到另一个页面b.然后将新插入数据按照主键值插入到页面a或者页面b中.<code>根结点升级为存储目录项的目录页面</code>.</li></ol><blockquote><p>从整个过程来看,根节点变化的只是页面内的数据,根节点在创建之后页码就不会变化.页号会被记录下来,然后当<code>mysql</code>需要使用这个索引的时候,就会查询出对应索引根节点的页号,然后进行操作.</p></blockquote><h4 id="2-非叶子节点中目录项的唯一性"><a href="#2-非叶子节点中目录项的唯一性" class="headerlink" title="2. 非叶子节点中目录项的唯一性:"></a>2. 非叶子节点中目录项的唯一性:</h4><p>前面简单的将<code>二级索引</code>认为是 <code>索引列 + 页号</code>的搭配,但是会出现下面这个问题:</p><p>以示例数据 c2列为索引的时候,会形成下图所示的索引:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814022636149.png" alt="二级索引不唯一会产生的问题"></p><p>当插入新数据 (9,1,c)的时候, 会发现根节点中所有的目录向索引列的值都是一样的,这样就无法定位新插入数据应该插入页4还是页5.</p><p>实际上<code>二级索引</code>的目录项还是会将<code>主键存储下来</code>,用于处理上面这个问题. 即当索引列相同的时候,比较主键从而决定记录的大小.所有的二级索引都是这样的,哪怕是<code>UNIQUE</code>类型的二级索引,也是这样的(因为<code>UNIQUE列可能出现多个null值</code>,或者多条记录键值相同的情况<code>MVCC</code>)</p><h4 id="3-一个页面至少容纳两条数据"><a href="#3-一个页面至少容纳两条数据" class="headerlink" title="3. 一个页面至少容纳两条数据:"></a>3. 一个页面至少容纳两条数据:</h4><p>主要是为了避免B+树层级增长过高.</p><h3 id="6-2-4-MyISAM索引方案简介"><a href="#6-2-4-MyISAM索引方案简介" class="headerlink" title="6.2.4 MyISAM索引方案简介:"></a>6.2.4 MyISAM索引方案简介:</h3><p>MyISAM的索引方案与InnoDB的索引方案,最大的区别就是</p><ul><li>MyISAM中索引和数据分开存储,即 <code>索引是索引,数据是数据</code></li><li>InnoDB中索引和数据是存储在一起的,即 <code>索引即数据,数据即索引</code></li></ul><p>MyISAM索引方案主要包含两部分:</p><ul><li><p>数据文件: 将表中的记录按照记录插入的顺序单独存储在一个文件中, 这个文件就称为<code>数据文件</code>.</p><p>数据文件并不划分如同<code>InnoDB</code>中数据页一样的结构,而是来多少数据就往数据文件中存多少数据.</p><p>MyISAM中数据在数据文件中是不会按照主键大小顺序排列的,而是按照插入的顺序排列.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814112858780.png" alt="MyISAM表中记录排列示意图"></p></li><li><p>索引文件: MyISAM会把索引信息单独存放到一个文件中,这个文件称为<code>索引文件</code>.</p></li><li><p>主键索引: MyISAM会为主键单独创建一个索引,但是主键索引叶子结点中用户记录存放的<code>不再是完整的用户记录</code>,而是主键值与行号</p></li><li><p>非主键索引: MyISAM也可以创建非主键索引,与<code>InnoDB</code>中的二级索引结构差不多.只不过</p><p>在叶子结点中用户记录存放的是 索引列,主键列,记录在数据文件中的行号.</p></li></ul><blockquote><ol><li>叶子结点中记录的是索引列+主键值+被查询数据在数据文件中的行号或者偏移量</li><li>MyISAM的索引全是二级索引包括主键索引, 所以都会去进行一次回表操作,只不过由于索引叶子结点记录的是查询记录在数据文件中的行号,或者是偏移量,所以可以直接定位被查询操作,速度是不需要担心的.</li><li><code>MyISAM</code>中,对于定长记录格式,直接使用行号来标记某条记录在数据文件中的精确位置.对于变长类型记录格式,在叶子结点中使用的是偏移量来精确定位数据文件中的位置.</li></ol></blockquote><h3 id="6-2-5-索引sql"><a href="#6-2-5-索引sql" class="headerlink" title="6.2.5 索引sql:"></a>6.2.5 索引sql:</h3><p>创建索引:</p><ul><li><p>建表的时候同时创建索引:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>表名<span class="token punctuation">`</span><span class="token punctuation">(</span>列<span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token keyword">KEY</span> <span class="token operator">|</span> <span class="token keyword">INDEX</span><span class="token punctuation">)</span> 索引名 <span class="token punctuation">(</span>需要加索引的列<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对已经存在的表,新增索引:</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- alter语句ALTER TABLE 表名 ADD (KEY|INDEX) 索引名 (需要加索引的列)-- create语句CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name    [index_type]    ON tbl_name (key_part,...)    [index_option]    [algorithm_option | lock_option] ...  key_part: 需要加索引的列,可以指定排序规则    col_name [(length)] [ASC | DESC]index_option: {    KEY_BLOCK_SIZE [=] value  | index_type  | WITH PARSER parser_name  | COMMENT 'string'}index_type: 索引类型    USING {BTREE | HASH} algorithm_option:    ALGORITHM [=] {DEFAULT | INPLACE | COPY}lock_option:    LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除索引:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">DROP</span> <span class="token punctuation">(</span><span class="token keyword">KEY</span><span class="token operator">|</span><span class="token keyword">INDEX</span><span class="token punctuation">)</span> 索引名<span class="token number">2</span><span class="token punctuation">)</span> 使用 <span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> 语句语法格式：<span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> <span class="token operator">&lt;</span>索引名<span class="token operator">&gt;</span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span>语法说明如下：<span class="token operator">&lt;</span>索引名<span class="token operator">&gt;</span>：要删除的索引名。<span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span>：指定该索引所在的表名。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修改索引:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 没有直接操作的语法,都是先删除原索引再新增索引</span><span class="token comment">-- 先删除</span><span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token keyword">user</span><span class="token keyword">drop</span> <span class="token keyword">index</span> idx_user_username<span class="token punctuation">;</span><span class="token comment">--再以修改后的内容创建同名索引</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_username <span class="token keyword">ON</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>username<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>索引查看:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> table_name<span class="token punctuation">;</span>纵向查看：<span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> table_name\G<span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">show</span> <span class="token keyword">keys</span> <span class="token keyword">from</span> table_name<span class="token punctuation">;</span>纵向查看：<span class="token keyword">show</span> <span class="token keyword">keys</span> <span class="token keyword">from</span> table_name\G<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5 InnoDB数据页结构</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-不同类型的页简介"><a href="#5-1-不同类型的页简介" class="headerlink" title="5.1 不同类型的页简介:"></a>5.1 不同类型的页简介:</h2><p>页是<code>InnoDB存储引擎</code>管理存储空间的基本单位, 一个页的基本单位是16KB.</p><p>InnoDB为了不同目的而设计了多种不同类型的页,比如:  <code>存放表空间头部信息的页</code>, <code>存放change buffer 信息的页</code>,<code>存放INODE信息的页</code>,<code>存放undo日志信息的页</code>等等</p><p>本章节主要是介绍<code>存放表中记录的页</code>,官方称之为 : <code>索引页index</code>,为了方便理解 称之为 <code>数据页</code>.</p><h2 id="5-2-数据页结构简介"><a href="#5-2-数据页结构简介" class="headerlink" title="5.2 数据页结构简介:"></a>5.2 数据页结构简介:</h2><p><code>Mysql</code>将数据页这块16KB大小的存储空间大致被划分成了 7个部分,不同部分有不同的功能.  如图所示: </p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809223800797.png" alt="单页数据页构成图"></p><p>各部分大致存储什么内容,如下表所示:</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间(字节)</th><th>功能概述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38</td><td>页的通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56</td><td>数据页的专有信息</td></tr><tr><td>Infimum+Supremum</td><td>页面中最小记录和最大记录</td><td>26</td><td>两个虚拟记录</td></tr><tr><td>User Record</td><td>用户记录</td><td>不确定</td><td>用户存放的记录</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页目录</td><td>不确定</td><td>页中某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8</td><td>校验页是否完整</td></tr></tbody></table><h2 id="5-3-记录在页中的存储"><a href="#5-3-记录在页中的存储" class="headerlink" title="5.3 记录在页中的存储:"></a>5.3 记录在页中的存储:</h2><p>在数据页的7个部分中,用户自己存入的记录会按照指定的行格式存储到<code>User Records</code>部分中.</p><p>在数据页生成的时候实际上是没有<code>User Records</code>这部分的,每当一条数据插入进来的时候,就会去<code>Free Space</code>部分申请记录需要的空间,然后与之前的<code>User Records</code>合并.当<code>Free Space</code>使用完之后就会去申请新的数据页.</p><p>数据存入大致流程:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809223836259.png" alt="数据存入数据页大致流程"></p><p><strong>示例数据:</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> page_demo <span class="token punctuation">(</span>c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>c2 <span class="token keyword">INT</span><span class="token punctuation">,</span>    c3 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">CHARSET</span><span class="token operator">=</span>ascii ROW_FORMART<span class="token operator">=</span>COMPACT<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> page_demo <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'bbbb'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">300</span><span class="token punctuation">,</span><span class="token string">'cccc'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token string">'dddd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>COMPACT</code>行格式中,<code>记录头信息</code>包含以下内容:</p><table><thead><tr><th>名称</th><th>大小(位)</th><th>意义</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_flag</td><td>1</td><td>标记记录是否被删除</td></tr><tr><td>min_rec_flag</td><td>1</td><td>B+树每层非叶子结点中最小的目录项记录都会添加这个标记</td></tr><tr><td>n_owned</td><td>4</td><td>每页数据都会被分成若干组,每个组都有个组长,组长记录的n_owned值表示该组人员数量</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在页面堆中的相对位置</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型,0(普通记录),1(B+树非叶子节点的目录项记录),2(Infimum记录),3(Supremum记录)</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><p>为了屏蔽干扰,后续示例数据行格式图都只给出<code>记录头信息</code>和<code>数据真实部分</code>,如图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809232737709.png" alt="记录头与真实数据部分"></p><p>向<code>page_demo</code>表插入四条数据之后,<code>User Records</code>部分如图所示: </p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809233733977.png" alt="插入4条示例数据后记录示意图"></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809235722131.png" alt="实际数据在磁盘中的结构"></p><p><font color="red"><strong>从上图可以看出来,记录在数据页中是按照主键大小依次排列紧挨着排列的</strong> </font></p><h3 id="5-3-1-记录头信息各个字段的含义"><a href="#5-3-1-记录头信息各个字段的含义" class="headerlink" title="5.3.1 记录头信息各个字段的含义:"></a>5.3.1 记录头信息各个字段的含义:</h3><h4 id="1-delete-flag"><a href="#1-delete-flag" class="headerlink" title="1. delete_flag:"></a>1. delete_flag:</h4><p><code>delete_flag</code>: 是用于标记该记录是否被删除,占用1位, <code>值为0表示记录没有被删除</code>,值 为1表示记录被删除.</p><p><code>MySQL</code>在删除数据的时候,实际上采用了<code>逻辑删除</code>的思想, 通过标记位标记记录是否被删除,当有新记录要插入进来的时候,复用这些被删除记录占用的空间,而不是将数据从磁盘中删除掉,然后对所有记录按照主键进行重排序.这样做的好处是<font color="#green"><strong>避免了重排序和空间开辟的性能消耗,又不浪费空间</strong>&nbsp;</font>.</p><p>被删除的数据还会通过记录头中的<code>next_record</code>将当前页中被删除的记录形成一个链表.</p><h4 id="2-min-rec-flag"><a href="#2-min-rec-flag" class="headerlink" title="2. min_rec_flag:"></a>2. min_rec_flag:</h4><p><code>min_rec_flag</code>: B+树每层非叶子结点中的最小的目录项记录都会添加这个标记.</p><h4 id="3-o-owned"><a href="#3-o-owned" class="headerlink" title="3. o_owned:"></a>3. o_owned:</h4><p><code>o_owned</code>: <code>Mysql</code>会将数据页中的记录按照一定的规则分成多个小组,每个小组中主键值最大的记录就是组长,只有组长的记录头信息中的<code>o_owned</code>字段记录着这个分组中有多少个成员(包括组长).</p><h4 id="4-heap-no"><a href="#4-heap-no" class="headerlink" title="4. heap_no:"></a>4. heap_no:</h4><p>记录在数据页中真实的情况是按照主键大小紧密无间的排列,<code>MySQL</code>将这种结构称为 <code>heap堆</code>.</p><p><code>heap_no字段</code>: 表示记录在堆中的编号,即堆中第几条记录.</p><p>两个特殊的记录:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809235809341.png" alt="Infimum和Superemum"></p><ul><li><code>Infimum记录</code>: <code>MySQL</code>自动给数据页中插入的<code>Mysql规定的当前页</code>最小的记录. <font color="yellow"><strong>并且<code>MySQL</code><strong>规定</strong> <code>Infimum记录</code>记录头信息中<code>heap_no字段值为0</code>,<code>next_record</code>永远指向用户自己添加的记录中主键最小的那一条记录.</strong> </font></li><li><code>Supremum记录</code>: <code>MySQL</code>自动给数据页中插入的<code>MySQL规定的当前页面</code>最大的记录.<font color="yellow"><strong>并且<code>MySQL</code><strong>规定</strong>,<code>Supremum记录</code>记录头信息中<code>heap_no字段的值为1</code>, 用户自己添加的记录中主键最大的那一条记录的<code>next_record</code>永远指向<code>Supremum记录</code></strong> </font></li></ul><blockquote><ol><li>这两条特殊记录共同组成了数据页中<code>Infimum+Spremium</code>部分</li><li>对于一条完整的记录来说,比较记录的大小就是比较主键的大小. 一条完整的记录,一条完整的记录,一条完整的记录</li></ol></blockquote><p>用户自己插入的记录是普通记录,普通记录根据记录的大小从2开始递增作为其记录头信息<code>heap_no字段</code>的值.</p><p><font color="red">**&nbsp;<code>heap_no字段</code>因为是表示记录在堆中的编号,一旦在分配了之后就不会改变,哪怕那条记录被删除了**&nbsp;</font></p><h4 id="5-record-type"><a href="#5-record-type" class="headerlink" title="5. record_type:"></a>5. record_type:</h4><p><code>record_type</code>: 表示当前记录的类型.<code>MySQL</code>中一共4中类型 — 0表示普通类型,1表示B+树非叶子结点的目录项记录,2表示Infimum记录,3表示Supremum记录.</p><h4 id="6-next-record"><a href="#6-next-record" class="headerlink" title="6. next_record:"></a>6. next_record:</h4><p><code>next_record</code>: 表示当前记录的真实数据到下一条记录的真实数据的距离.</p><p><code>next_record</code>值的符号表示方向,如果值为负数表示下一条记录的真实数据在当前记录真实数据的前面,如果值为整数,表示下一条记录的真实数据在当前记录的真实数据的后面.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210810002933353.png" alt="记录在数据页中形成的单链表"></p><p>为什么<code>next_word</code>表示的是 到下一条记录真实数据的距离,而不是下一条记录开始的位置?</p><p>因为<code>next_record</code>指向这里刚刚好,向前就是记录的头信息,向后就是记录的真实数据,而且行格式中,<code>变长字段列表</code>和<code>null值列表</code>都是按照逆序存放的,这样可以使记录中位置靠前的字段和他们对应的字段长度信息在内存中的距离更近,可能会提高高速缓存的命中率</p><h2 id="5-4-Page-Directory"><a href="#5-4-Page-Directory" class="headerlink" title="5.4 Page Directory:"></a>5.4 Page Directory:</h2><p>由于<code>Mysql</code>中的记录是按照主键值从小到大排列的,通过记录头信息中<code>next_record</code>字段可以定位到下一个记录,从而形成一个单向链表,单向链表在查找的时候效率不高,于是<code>Mysql</code>通过目录的形式快速定位某个区间,然后逐一去排查的方式来快输定位.</p><h3 id="5-4-1-实现过程如下"><a href="#5-4-1-实现过程如下" class="headerlink" title="5.4.1 实现过程如下:"></a>5.4.1 实现过程如下:</h3><ol><li><p>将所有记录(包含: <code>Infimum</code>和<code>Spremum</code>)划分成多个小组.</p></li><li><p>因为每个记录都是按照主键值从小到大依次排列,将小组中最后一条记录选为目录项(即组长),在其记录头信息的<code>o_owned</code>字段中记录该小组有多少条记录</p></li><li><p>将目录项在页面中的地址偏移量(就是该记录的真实数据与页面第0个字节之间的距离),单独提取出来,按在分组的先后顺序从最靠近页尾部的地方开始存放起来.存放目录项地址偏移量的地方被称为<code>槽</code>,是一个2字节大小的空间.</p></li><li><p>这些槽构成页面中的<code>Page Directory</code>部分.</p><blockquote><p>对于小组,<code>mysql</code>规定: </p><ol><li><code>Infimum</code>记录,单独为一个小组,即 <code>Infimum</code>记录所在的小组只能有一条记录</li><li><code>Spremum</code>记录所在的小组记录条数只能在 <code>1~8</code>条之间</li><li>其他小组记录条数只能在<code>4~8</code>条之间</li></ol><p>关于槽:</p><ul><li>槽的顺序: 分组的时候先从主键值小的记录开始向后分,槽表示的记录越小就越靠近<code>File Tailer</code>部分</li><li>槽如何排列的: <code>Page Directory</code>部分实际上就是一个<code>指针数组</code>,数组中的元素连续分布. </li></ul><p>为什么槽只需要两个字节:</p><p>因为页面大小为16KB,范围在<code>0 ~ 16384</code>字节之间,2个字节可以表示的范围在 <code>0 ~ 65535</code>之间,所以两个字节够了.</p></blockquote></li></ol><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210811224713628.png" alt="页目录中的槽指向分组中主键最大的元素"></p><h3 id="5-4-2-分组的过程"><a href="#5-4-2-分组的过程" class="headerlink" title="5.4.2 分组的过程:"></a>5.4.2 分组的过程:</h3><ol><li><p>数据页在还没有插入记录的时候,实际上只有两个分组,一个 <code>Infimum</code>代表的分组和<code>Spremum</code>代表的分组.</p><p>页目录也只有两个槽,分别指向<code>Infimum</code>和<code>Spremum</code>的真实数据开始的位置.</p></li><li><p>之后每插入一个记录都会从页目录中找到槽指向记录的主键值比待插入主键值大但是差值最小的槽.然后将槽指向记录的记录头信息中<code>o_owned</code>字段+1,表示本组新增一条记录,直到该组中记录数等于8个.</p></li><li><p>当小组中记录数目等于8个的时候,再向组内插入记录,该组就会分裂成两个小组,一个组4个一个组5个元素.然后给新增的小组分配一个新的槽位,来记录新增小组中组长真实数据的地址偏移量.</p></li></ol><h3 id="5-4-3-查找演示"><a href="#5-4-3-查找演示" class="headerlink" title="5.4.3 查找演示:"></a>5.4.3 查找演示:</h3><p>示例数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">Insert</span> <span class="token keyword">into</span> page_demo <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'bbbb'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">300</span><span class="token punctuation">,</span><span class="token string">'cccc'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token string">'dddd'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token string">'eeee'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">600</span><span class="token punctuation">,</span><span class="token string">'ffff'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">700</span><span class="token punctuation">,</span><span class="token string">'gggg'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">800</span><span class="token punctuation">,</span><span class="token string">'hhhh'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">900</span><span class="token punctuation">,</span><span class="token string">'iiii'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token string">'jjjj'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">1100</span><span class="token punctuation">,</span><span class="token string">'kkkk'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">1200</span><span class="token punctuation">,</span><span class="token string">'llll'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">1300</span><span class="token punctuation">,</span><span class="token string">'mmmm'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">1400</span><span class="token punctuation">,</span><span class="token string">'nnnn'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">1500</span><span class="token punctuation">,</span><span class="token string">'oooo'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">1600</span><span class="token punctuation">,</span><span class="token string">'pppp'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>假设目前分组如图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210811230743354.png" alt="记录分组示意图"></p><p>现在想要查找主键值为6的元素,因为<code>Page Directory</code>实际上就是个指针数组,并且指向的值还是按照大小逆序的,所以可以使用2分发查找:</p><ol><li>计算中间槽位: (0+４)／2 = 2,槽2指向记录的主键值为8,比6大,所以要查找的6在槽2的前面.调整high=2,low不变</li><li>重新计算中间槽位: (0+2)/2 =1,槽1指向记录的主键值为4,比6小,所以要查找的6在槽1的后面.</li><li>此时high-low=1,表示中间没有槽位了,所以主键为6的记录应该是在槽2对应的小组里面.由于记录在数据页中是按照主键从小到大依次根据<code>next_record</code>形成的一条单向链表,虽然知道槽2对应分组最大的记录但是也无法从其找到需要的记录,所以应该从槽1指向的记录通过<code>next_record</code>开始遍历找到需要的记录.</li></ol><h2 id="5-5-Page-Header"><a href="#5-5-Page-Header" class="headerlink" title="5.5 Page Header:"></a>5.5 Page Header:</h2><p><code>Page Header</code>主要是用来存储数据页中记录的状态信息的,比如: 数据页已经存了多少条记录,<code>Free Space</code>在页中的偏移量,页目录中存储了多少个槽位等.固定<code>56字节</code>.</p><p><strong>Page Header 各部分及作用:</strong></p><table><thead><tr><th>状态名称</th><th>占用空间(字节)</th><th>作用</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2</td><td>页目录中槽的数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2</td><td>当前Free Space开始的地址</td></tr><tr><td>PAGE_N_HEAP</td><td>2</td><td>第一位表示本页记录是否为紧凑型记录,其余位本页堆中记录的数量(包含Infimum,Supremum,被标记为<code>已删除</code>的记录)</td></tr><tr><td>PAGE_FREE</td><td>2</td><td>表示的是 <code>已删除记录</code>形成的单向链表中头结点记录在页面的偏移量.</td></tr><tr><td>PAGE_GARBAGE</td><td>2</td><td><code>已删除记录</code>占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2</td><td>最后插入的记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2</td><td>一个方向连续插入记录的数量</td></tr><tr><td>PAGE_N_RECS</td><td>2</td><td>本页用户记录数量(不含: <code>Infimum</code>,<code>Supremum</code> 以及 <code>已删除记录</code>)</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8</td><td>本页最大的事务id,这个值仅在二级索引页面中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2</td><td>本页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8</td><td>索引ID,表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10</td><td>B+树叶子结点段的头部信息,仅在B+树的根页面中定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10</td><td>B+树非叶子结点段的头部信息,仅在B+树的根页面中定义</td></tr></tbody></table><blockquote><ol><li><code>PAGE_DIRECTION</code>: 待插入记录的主键值比上一条记录的主键值大,则 待插入记录的插入方向就是右边,否则为左边.<code>PAGE_DIRECTION</code>就是记录这个方向</li><li><code>PAGE_N_DIRECTION</code> : 如果连续插入几条记录<code>PAGE_DIRECTION</code>都是一样的,<code>Mysql</code>就会记录沿着同一个方向插入的记录条数.如果如果方向改变<code>PAGE_N_DIRECTION</code>就会被清零重新统计</li></ol></blockquote><h2 id="5-6-File-Header"><a href="#5-6-File-Header" class="headerlink" title="5.6 File Header:"></a>5.6 File Header:</h2><p><code>File Header</code>通用于个类型的页,它描述一些通用于各种页的信息,比如本页编号,上一页,下一页等,固定占用<code>38字节</code></p><p><strong>File Header</strong>各部分及其作用:</p><table><thead><tr><th>状态名称</th><th>占用空间大小(字节)</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4</td><td>本页校验和</td></tr><tr><td>FIL_PAGH_OFFSET</td><td>4</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4</td><td>上一页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4</td><td>下一页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8</td><td>本页被最后修改时对应的LSN(Log Sequence Number,日志序列号)</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2</td><td>本页类型</td></tr><tr><td>FIL_PAGE_FILE_FLSH_LSN</td><td>8</td><td>仅在系统表空间的第一个页中定义,表示文件至少被刷新到了对应的LSN</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li><p><code>FIL_PAGH_OFFSET</code>: 页的唯一标识,<code>MySQL</code>通过页号唯一确定一个页</p></li><li><p><code>FIL_PAGE_NEXT</code>和<code>FIL_PAGE_PREV</code>: 由于一张表可能存储成千上万条数据,所以肯定无法分配连续的空间来存储,那么就需要将一张表的数据页关联起来.<code>MySQL</code>就是通过<code>FIL_PAGE_NEXT</code>和<code>FIL_PAGE_PREV</code>分别指向下一页和上一页,以页为结点形成一个双向链表.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210812001008664.png" alt="数据页之间形成的双向链表"></p></li></ul><p><strong>页的类型:</strong></p><table><thead><tr><th>类型</th><th>16进制</th><th>含义</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>刚分配还未使用</td></tr><tr><td>FIL_PAGE_UNDO_LOG</td><td>0x0002</td><td>undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>存储段的信息</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Change buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Change Buffer的一些属性</td></tr><tr><td>FIL_PAGE_TYPE_SYS</td><td>0x0006</td><td>存储一些系统数据</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务的系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间的头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>存储区的一些属性</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>溢出页</td></tr><tr><td>FIL_PAGE_INDEX</td><td>0x45BF</td><td>索引页(即数据页)</td></tr></tbody></table><h2 id="5-7-File-Trailer"><a href="#5-7-File-Trailer" class="headerlink" title="5.7 File Trailer:"></a>5.7 File Trailer:</h2><p><code>File Trailer</code>: 由于数据操作实际上都是在内存中,操作完成之后需要将结果刷新到磁盘里面去,为了防止数据没有被完全刷新的情况,<code>Mysql</code>通过<code>File Trailer</code>来校验一个数据页是否是完整的.<code>File Trailer</code>通用于所有类型的页,由<code>8字节</code>组成:</p><ul><li><code>前四字节</code>表示页的校验和: 这部分与<code>File Header</code>中的校验和是相对应的. 每当一个页在内存中操作完成,写回磁盘的时候都是先写<code>File Header</code>,在最后校验和也会被写入到<code>File Trailer</code>.如果写回磁盘的过程中,出现了只写了<code>File Header</code>中的校验和,没来得及写<code>FIle Trailer</code>中的校验和,那么就会出现在校验的时候<code>File Header</code>中的校验和是新的,而<code>File Trailer</code>中的校验和是旧的,导致出现问题</li><li><code>后四字节</code>表示页面被修改时对应的LSN的后四字节,正常情况下,<code>File Header</code>的<code>FILE_PAGE_LSN</code>字段的后四字节相同.</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4 InnoDB记录存储结构</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="4-2-InnoDB页简介"><a href="#4-2-InnoDB页简介" class="headerlink" title="4.2 InnoDB页简介:"></a>4.2 InnoDB页简介:</h2><p><code>InnoDB</code>引擎是一个将表中的数据存储到磁盘上的存储引擎,也就是说 即使服务器宕机,数据仍然存在于磁盘中.</p><p>由于计算机对于数据的处理都是发生内存中,为了提高效率,<code>InnoDB存储引擎</code>将数据分成若干页,以页作为磁盘和内存之间交互的基本单位.</p><p><code>InnoDB</code>的数据页的大小一般为 <code>16KB</code>,也就是说 一次最少从磁盘中读取<code>16KB</code>的数据到内存中,一次最少从内存中向磁盘写入<code>16KB</code>的数据</p><blockquote><ol><li>系统变量<code>innoDB_page_size</code>表示 <code>InnoDB</code>存储引擎数据页的大小,默认值为 <code>16384B</code></li><li><code>innoDB_page_size</code>变量只能在<code>mysql</code>第一次初始化数据目录的时候通过 <code>mysql --initialize</code>命令指定.服务器运行过程中并不能被修改</li></ol></blockquote><h2 id="4-3-InnoDB行格式"><a href="#4-3-InnoDB行格式" class="headerlink" title="4.3 InnoDB行格式:"></a>4.3 InnoDB行格式:</h2><p>通常插入数据的时候,都是以一行(一条记录)为单位插入,所以记录在磁盘中存放的形式也被称为 <code>行格式</code>或者<code>记录格式</code></p><p><code>行格式</code>总共4种: <code>COMPACT</code>,<code>REDUNDANT</code>,<code>DYNAMIC</code>和 <code>COMPRESSED</code>.</p><h3 id="4-3-1-指定行格式的语法"><a href="#4-3-1-指定行格式的语法" class="headerlink" title="4.3.1 指定行格式的语法:"></a>4.3.1 指定行格式的语法:</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 建表的时候指定</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> table_name <span class="token punctuation">(</span><span class="token keyword">columns</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> ROW_FORMAT<span class="token operator">=</span>行格式名称<span class="token punctuation">;</span><span class="token comment">-- 修改</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name ROW_FORMAT<span class="token operator">=</span>行格式名称<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-2-COMPACT行格式"><a href="#4-3-2-COMPACT行格式" class="headerlink" title="4.3.2 COMPACT行格式:"></a>4.3.2 COMPACT行格式:</h3><p>示例数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> record_format_demo<span class="token punctuation">(</span>c1 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>C2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>C3 <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    C4 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">CHARSET</span><span class="token operator">=</span><span class="token keyword">asc</span>Ⅱ ROW_FORMAT<span class="token operator">=</span>COMPACT<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> record_format_demo<span class="token punctuation">(</span>c1<span class="token punctuation">,</span>c2<span class="token punctuation">,</span>c3<span class="token punctuation">,</span>c4<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'aaaa'</span><span class="token punctuation">,</span> <span class="token string">'bbb'</span><span class="token punctuation">,</span> <span class="token string">'cc'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token string">'eeee'</span><span class="token punctuation">,</span> <span class="token string">'fff'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-COMPACT行格式示意图"><a href="#1-COMPACT行格式示意图" class="headerlink" title="1. COMPACT行格式示意图:"></a>1. <code>COMPACT行格式</code>示意图:</h4><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808210035653.png" alt="compact行格式示意图"></p><h4 id="2-字段解释"><a href="#2-字段解释" class="headerlink" title="2. 字段解释:"></a>2. 字段解释:</h4><h5 id="1-记录的额外信息"><a href="#1-记录的额外信息" class="headerlink" title="1. 记录的额外信息:"></a>1. 记录的额外信息:</h5><p>这部分是服务器为了更好的管理记录而不得不额外添加的一些信息.</p><h6 id="1-变长字段长度列表"><a href="#1-变长字段长度列表" class="headerlink" title="1. 变长字段长度列表:"></a>1. 变长字段长度列表:</h6><p>存储长度可以变化的字段的真实长度.比如: <code>VARCHAR</code>, <code>VARBINARY</code>, <code>TEXT</code>, <code>BLOB</code>类型字段的真实长度.</p><p><code>COMPACT</code>行格式中, 所有变长字段真实数据占用的字节数都存放在记录的开头, <code>各列所占字节数按照列的顺序逆序排列起来</code>,形成一个变长字段长度列表</p><p><font color="red">变长字段长度列表只记录非null字段真实数据的长度(占用字节数)</font></p><p><strong>变长字段真实数据占用字节数,使用多少字节表示规则如下:</strong></p><p>假设字符集表示一个字符需要<code>W字节</code>, 变长类型<code>VARCHAR(M)</code>最多能存放<code>M个字符</code>,变长字段内容占用<code>L字节</code>.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token class-name">M</span> <span class="token operator">*</span> <span class="token class-name">W</span> <span class="token operator">&gt;</span> <span class="token number">255</span> <span class="token operator">&amp;&amp;</span>　Ｌ <span class="token operator">&gt;</span> <span class="token number">127</span><span class="token punctuation">{</span><span class="token comment">// 使用两个字节表示变长字段真实数据占用字节数    </span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token comment">// 使用一个字节表示变长字段真实数据占用字节数    </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例数据第一条记录,变长字段长度列表如下: <code>示例数据使用的是 ASCⅡ字符集</code></p><table><thead><tr><th>列名</th><th>存储内容</th><th>内容长度(占用字节数)</th><th>内容长度(16进制)</th></tr></thead><tbody><tr><td>c1</td><td><code>aaaa</code></td><td>4</td><td>0x04</td></tr><tr><td>c2</td><td><code>bbb</code></td><td>3</td><td>0x06</td></tr><tr><td>c4</td><td><code>d</code></td><td>1</td><td>0x01</td></tr></tbody></table><p>变长字段长度列表填入之后,示意图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808214820708.png"></p><h6 id="2-NULL值列表"><a href="#2-NULL值列表" class="headerlink" title="2. NULL值列表:"></a>2. NULL值列表:</h6><p>由于记录中允许存入<code>null值</code>,为了节省空间,<code>COMPACT</code>行格式将一条记录中值为<code>null</code>的列统一管理,存入<code>null值列表</code>中</p><p>处理过程:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808221517085.png"></p><ol><li>统计表中允许值为<code>null</code>的列名.</li><li>如果没有允许值为<code>null</code>的列,<code>null值列表就不存在</code>,否则将 列从后往前分别对应<code>bitMap</code>的一个位置(<code>bitMap</code>从第一位开始),当 <code>bitMap</code>中元素值为 1表示对应列的值为null,值为0表示对应列的值不为null.</li><li>字节填充, <code>MYSQL</code>要求<code>null值列表</code>必须是 <code>8b</code>的整数倍(即 整数)</li></ol><p>null值列表填入后,记录结构为:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808220938727.png"></p><h6 id="3-记录头信息"><a href="#3-记录头信息" class="headerlink" title="3. 记录头信息:"></a>3. 记录头信息:</h6><p><code>记录头信息</code>使用<code>5个字节,40位</code>表示,用于描述记录的一些属性,不同位记录不同的信息.前4位称为 <code>info位</code></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808221601038.png" alt="记录头信息示意图"></p><table><thead><tr><th>名称</th><th>大小(位)</th><th>意义</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_flag</td><td>1</td><td>标记记录是否被删除</td></tr><tr><td>min_rec_flag</td><td>1</td><td>B+树每层非叶子结点中最小的目录项记录都会添加这个标记</td></tr><tr><td>n_owned</td><td>4</td><td>每页数据都会被分成若干组,每个组都有个组长,组长记录的n_owned值表示该组人员数量</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在页面堆中的相对位置</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型,0(普通记录),1(B+树非叶子节点的目录项记录),2(Infimum记录),3(Supremum记录)</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><p>见<a href="5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84.md">字段详解</a></p><p><strong>示例数据的记录头信息:</strong></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808222437030.png"></p><h5 id="2-记录的真实信息"><a href="#2-记录的真实信息" class="headerlink" title="2. 记录的真实信息:"></a>2. 记录的真实信息:</h5><h6 id="1-隐藏字段"><a href="#1-隐藏字段" class="headerlink" title="1. 隐藏字段:"></a>1. 隐藏字段:</h6><p>记录的真实信息里面,由于<code>null值字段</code>已经被位图映射的方式记录在了null值字段表里面,所以真实信息是不包含null值字段的.</p><p>除了一些真实字段数据会被记录在记录的真实信息里面,<code>MySQL</code>还会向里面添加几个隐藏字段:</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID,唯一表示一条记录</td></tr><tr><td>trx_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>说明:</p><ol><li><p>这三个真实的名字为 <code>DB_ROW_ID</code>,<code>DB_TRX_ID</code>,<code>DB_ROLL_POINTER</code></p></li><li><p><code>row_id</code>这个字段不是必须的原因,在<code>MYSQL</code>无法使用用户自定义字段为主键的时候才添加.</p><p><code>mysql</code>主键生成策略:</p><ol><li>使用用户指定的主键作为主键</li><li>用户没有指定主键,使用<code>非null的UNIQUE键</code>作为主键</li><li>没有<code>非null的UNIQUE键</code>,添加隐藏字段<code>row_id</code>.</li></ol></li><li><p>真实信息里面,不会出现null字段</p></li></ol><h5 id="3-CHAR-M-列的存储格式"><a href="#3-CHAR-M-列的存储格式" class="headerlink" title="3. CHAR(M)列的存储格式:"></a>3. CHAR(M)列的存储格式:</h5><ul><li><code>CHAR(M)</code>类型数据,在使用定长字符集(比如: <code>ascⅡ</code>字符集)的时候,这种类型的字段长度是不会被记录到变长字段长度列表里面.此时变长字段长度列表如图:</li></ul><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808224922203.png"></p><ul><li><p><code>CHAR(M)</code>类型字段,在使用变长字符集(比如: <code>utf8</code>字符集)的时候,这种类型的字段长度是会记录到变长字段长度列表里面.此时变长字段长度列表如图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808225109072.png"></p><blockquote><p>采用变长编码字符集的时候,CHAR(M)类型的数据,至少占用M个字节,即哪怕空串该列也会占用M字节</p></blockquote></li></ul><h4 id="3-示例数据最终的样子"><a href="#3-示例数据最终的样子" class="headerlink" title="3. 示例数据最终的样子:"></a>3. 示例数据最终的样子:</h4><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808224253863.png"></p><h3 id="4-3-3-REDUNDANT行格式"><a href="#4-3-3-REDUNDANT行格式" class="headerlink" title="4.3.3 REDUNDANT行格式:"></a>4.3.3 REDUNDANT行格式:</h3><p>这种格式在 <code>MYSQL5.0</code>之前就在使用了.</p><h4 id="1-REDUNDANT行格式示意图"><a href="#1-REDUNDANT行格式示意图" class="headerlink" title="1. REDUNDANT行格式示意图:"></a>1. <code>REDUNDANT行格式</code>示意图:</h4><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808225311548.png"></p><h4 id="2-字段解释-1"><a href="#2-字段解释-1" class="headerlink" title="2. 字段解释:"></a>2. 字段解释:</h4><p>示例数据具体格式:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808225758037.png"></p><h5 id="1-字段长度偏移列表"><a href="#1-字段长度偏移列表" class="headerlink" title="1. 字段长度偏移列表:"></a>1. 字段长度偏移列表:</h5><p>通过字段长度偏移量的差值表示字段的长度,同样是按照字段顺序逆序存放.</p><h5 id="2-记录头信息"><a href="#2-记录头信息" class="headerlink" title="2. 记录头信息:"></a>2. 记录头信息:</h5><p><code>REDUNDANT行格式</code>的记录头信息占用6字节(48位)</p><table><thead><tr><th>名称</th><th>大小(位)</th><th>意义</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_flag</td><td>1</td><td>标记记录是否被删除</td></tr><tr><td>min_rec_flag</td><td>1</td><td>B+树每层非叶子结点中最小的目录项记录都会添加这个标记</td></tr><tr><td>n_owned</td><td>4</td><td>每页数据都会被分成若干组,每个组都有个组长,<code>组长记录</code>的n_owned值表示该组人员数量</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在页面堆中的相对位置</td></tr><tr><td>n_field</td><td>10</td><td>记录中列的数量</td></tr><tr><td>1byte_offs_flag</td><td>1</td><td>标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><h5 id="3-1byte-offs-flag如何选择"><a href="#3-1byte-offs-flag如何选择" class="headerlink" title="3. 1byte_offs_flag如何选择:"></a>3. 1byte_offs_flag如何选择:</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> length <span class="token operator">=</span> 当前记录总长度<span class="token punctuation">;</span><span class="token keyword">if</span> length <span class="token operator">&lt;=</span> <span class="token number">127</span> <span class="token punctuation">{</span>    <span class="token comment">// 使用一个字节表示,即 1byte_offs_flag = 1</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">// 使用两个字节表示,即 1byte_offs_flag = 0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明: </p><p>实际上,当前记录总长度大于127时分成了两种情况: </p><ul><li><code>length &gt; 127 &amp;&amp; lenght &lt;= 32767</code>.</li><li><code>length &gt; 32767</code>. 这种情况下,由于每页只会保存记录前768字节和20字节的溢出页面地址,使用两个字节来表示列的长度偏移量也足够了</li></ul><p>为什么总长度大于127就要使用两个字节.</p><p>原因是: 每个列长度偏移量值 的第一位是用来记录该列是否为null的.第一位为1表示该列为null,所以 非null列数据偏移量的第一位不能为null,但是此时还需要多余的位来记录偏移量信息,于是只能使用第二个字节了.</p><h5 id="4-REDUNDANT行格式null值得处理"><a href="#4-REDUNDANT行格式null值得处理" class="headerlink" title="4. REDUNDANT行格式null值得处理:"></a>4. REDUNDANT行格式null值得处理:</h5><ul><li>对应列偏移量值的第一位是 该列是否为null的标志位,如果第一位为1,则表示该列为null</li><li>如果值为null的列是定长类型的,则真实数据部分也会为其开辟空间,然后使用0值填充</li><li>如果值为null的列是变长类型的,则真实数据部分不会为其开辟空间</li></ul><h5 id="5-CHAR-M-的处理"><a href="#5-CHAR-M-的处理" class="headerlink" title="5. CHAR(M)的处理:"></a>5. CHAR(M)的处理:</h5><p><code>REDUNDANT行格式</code>在处理CHAR(M)类型字段的时候,固定使用 对应字符集表示一个字符最多需要的字节数* M 表示该字段所占用的空间.</p><h3 id="4-3-4-溢出列"><a href="#4-3-4-溢出列" class="headerlink" title="4.3.4 溢出列:"></a>4.3.4 溢出列:</h3><p>示例数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> off_page_demo<span class="token punctuation">(</span>c <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">65532</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 ROW_FORMAT<span class="token operator">=</span>COMPACT<span class="token punctuation">;</span><span class="token comment">-- REPEAT('a',65532)表示a重复65532次</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> off_page_demo <span class="token punctuation">(</span>c<span class="token punctuation">)</span> VLAUES <span class="token punctuation">(</span><span class="token keyword">REPEAT</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">65532</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-溢出列"><a href="#1-溢出列" class="headerlink" title="1. 溢出列:"></a>1. 溢出列:</h4><p>在<code>COMPACT</code>和<code>REDUNDANT</code>行格式中如果某个列占用的字节数非常多,那么在该记录的真实数据处只会存储真实数据的前768字节和 存放其余数据的溢出页的地址(占20字节)</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808234317204.png"></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808234332764.png"></p><h4 id="2-产生溢出页的临界点"><a href="#2-产生溢出页的临界点" class="headerlink" title="2. 产生溢出页的临界点:"></a>2. 产生溢出页的临界点:</h4><p><code>Mysql</code>规定正常页面至少要存放两条记录,溢出页没有这个规定</p><p><code>Mysql页空间的分配</code>:</p><ul><li>除了记录以外的额外信息,占用132字节</li><li>每条记录的额外信息是 27字节<ul><li>2字节用于存放真实数据的长度</li><li>1字节存放列是否为null</li><li>5字节存放记录头信息</li><li>6字节的row_id列信息</li><li>6字节的trx_id列信息</li><li>7字节的roll_pointer列</li></ul></li></ul><p>如果假设一个单列记录真实数据的字节数为n,如果该列不发生溢出现象,n应该满足:  <code>132 + 2* (27*n) &lt;= 16384 </code>,也就是说单列记录不发生溢出现象的最大长度为 8099字节.</p><h3 id="4-3-5-DYNAMIC-COMPRESSED"><a href="#4-3-5-DYNAMIC-COMPRESSED" class="headerlink" title="4.3.5 DYNAMIC COMPRESSED"></a>4.3.5 DYNAMIC COMPRESSED</h3><p><code>MySQL5.7版本</code>默认的行格式为 <code>DYNAMIC</code>:</p><p>这两个行格式和<code>COMPACT</code>格式基本相同,只是处理溢出列上不同: 不会存储溢出列真实数据的前768字节,而是将所有真实数据都存放在溢出页中,在真实数据部分只会存放溢出页的地址.</p><p>COMPRESSED行格式会采用压缩算法对页面进行压缩,以节省空间.DYNAMIC行格式不会压缩页面.</p>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3 字符集和比较规则</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/3_%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/3_%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-字符集和比较规则"><a href="#3-1-字符集和比较规则" class="headerlink" title="3.1 字符集和比较规则:"></a>3.1 字符集和比较规则:</h2><h3 id="3-1-1-字符集介绍"><a href="#3-1-1-字符集介绍" class="headerlink" title="3.1.1 字符集介绍:"></a>3.1.1 字符集介绍:</h3><p>数据在计算机中实际上是以二进制的关系存储的.</p><p><strong>字符集: 是描述某个字符范围的编码规则</strong></p><p>主要是解决两个问题:</p><ul><li>界定字符的范围,就是要将哪些字符转换成二进制数据</li><li>二进制数据和字符之间如何转换,即 编码解码过程</li></ul><h3 id="3-1-2-比较规则简介"><a href="#3-1-2-比较规则简介" class="headerlink" title="3.1.2 比较规则简介:"></a>3.1.2 比较规则简介:</h3><p><strong>比较规则:</strong> 即确定两个字符之间的大小关系.不同字符集在<code>mysql</code>中的比较规则也是不相同的</p><h3 id="3-1-3-一些重要的字符集"><a href="#3-1-3-一些重要的字符集" class="headerlink" title="3.1.3 一些重要的字符集:"></a>3.1.3 一些重要的字符集:</h3><ol><li><p><code>ASCⅡ字符集</code>: 共<code>128</code>个字符,包括空格,标点,数字,大小写字母和一些不可见的字符.<code>一个字节</code>就可以表示所有的<code>ASCⅡ字符</code></p></li><li><p><code>ISO 8859-1字符集</code>:共<code>256</code>个字符,在<code>ASCⅡ</code>的基础上增加了<code>128</code>个西欧常用字符. 也可以使用<code>一个字节</code>表示所有字符</p></li><li><p><code>GB2312字符集</code>: 收录了 <code>汉字</code>以及<code>拉丁字母</code>,<code>希腊字母</code>,<code>日本平假名,片假名</code>,<code>俄语西里尔字母</code>;汉字共<code>6763</code>个,其他文字符号<code>682</code>个. <code>GB2312</code>也兼容了<code>ASCⅡ字符</code>,所以<code>当GB2312字符在ASCⅡ字符范围内,使用一个字节;不在就是用两个字节进行编码</code></p></li><li><p><code>GBK字符集</code>: 对<code>GB2312字符集</code>在字符范围上进行了扩充,编码方式与<code>GB2312字符集</code>相同</p></li><li><p><code>UTF-8字符集</code>: 字符范围几乎涵盖当今世界各个国家/地区所使用的字符.编码方式兼容<code>ASCⅡ</code>,采用变长编码方式,一个<code>UTF8字符</code>可能需要<code>1~4个字节</code></p><blockquote><p><code>UTF-8</code>实际上是<code>Unicode字符集</code>的一种编码方案.</p></blockquote></li></ol><h2 id="3-2-MySQL支持的字符集和比较规则"><a href="#3-2-MySQL支持的字符集和比较规则" class="headerlink" title="3.2 MySQL支持的字符集和比较规则"></a>3.2 MySQL支持的字符集和比较规则</h2><h3 id="3-2-1-utf8和utf8mb4"><a href="#3-2-1-utf8和utf8mb4" class="headerlink" title="3.2.1 utf8和utf8mb4:"></a>3.2.1 <code>utf8</code>和<code>utf8mb4</code>:</h3><p>由于日常常用的字符使用<code>1~3</code>个字节基本就可以表示,为了提高编码效率,MySQL在处理<code>UTF8字符集</code>的时候从字符集名称上做了区分:</p><ul><li><code>utf8mb3</code>: mysql中<code>utf8</code>的别名,通常使用的<code>uft8</code>字符集就是这种,只使用<code>1~3个字节</code>表示字符.</li><li><code>utf8mb4</code>: 真正意义上的<code>utf8</code>字符集,使用<code>1~4</code>个字节表示字符. <code>可以存储emoji表情</code></li></ul><h3 id="3-2-2-查看字符集"><a href="#3-2-2-查看字符集" class="headerlink" title="3.2.2 查看字符集:"></a>3.2.2 查看字符集:</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token punctuation">(</span><span class="token keyword">character</span> <span class="token keyword">set</span> <span class="token operator">|</span> <span class="token keyword">charset</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token operator">like</span> <span class="token string">'字符集名称匹配模式'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/3_%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/image-20210808175539113.png" alt="image-20210808175539113"></p><p>说明:</p><ol><li><code>Default collation</code>: 表示该字符集默认的比较规则</li><li><code>Maxlen</code>: 表示该字符集最多使用多少个字节来描述字符.</li></ol><blockquote><p>注意: mysql中字符集名称都是小写的</p></blockquote><h3 id="3-2-3-查看比较规则"><a href="#3-2-3-查看比较规则" class="headerlink" title="3.2.3 查看比较规则:"></a>3.2.3 查看比较规则:</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> collation <span class="token punctuation">[</span><span class="token operator">like</span> <span class="token string">'字符集匹配模式'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/3_%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/image-20210808180418418.png" alt="image-20210808180418418"></p><p><strong>比较规则的命名:</strong></p><ul><li><p>比较规则都是由与其关联的字符集的名称开头,如图中都是<code>utf8</code>的比较规则</p></li><li><p><code>_</code>之后紧跟的是该规则适用的语种名称.如: <code>utf8_slovak_ci</code>表示斯洛伐克语言的比较规则</p></li><li><p><code>_</code>之后紧跟的是该规则是否区分对应语言中某些性质,如<code>大小写</code>,<code>重音</code>等</p><table><thead><tr><th>后缀</th><th>描述</th></tr></thead><tbody><tr><td>_ai</td><td>不区分重音(accent insensitive)</td></tr><tr><td>_as</td><td>区分重音(accent sensitive)</td></tr><tr><td>_ci</td><td>不区分大小写(case insensitive)</td></tr><tr><td>_cs</td><td>区分大小写(case sensitive)</td></tr><tr><td>_bin</td><td>二进制形式比较(binary)</td></tr></tbody></table></li></ul><blockquote><p>每个字符集都有很多的比较规则,<code>show collation</code>语句查询出来的信息中,<code>default</code>为yes的那一种比较规则就是默认比较规则</p></blockquote><h2 id="3-3-mysql中的应用"><a href="#3-3-mysql中的应用" class="headerlink" title="3.3 mysql中的应用:"></a>3.3 mysql中的应用:</h2><h3 id="3-3-1-不同级别的字符集和比较规则"><a href="#3-3-1-不同级别的字符集和比较规则" class="headerlink" title="3.3.1 不同级别的字符集和比较规则:"></a>3.3.1 不同级别的字符集和比较规则:</h3><p>mysql字符集和比较规则分成了四个级别:</p><ul><li>服务器级别</li><li>数据库级别</li><li>表级别</li><li>列级别</li></ul><h4 id="1-服务器级别"><a href="#1-服务器级别" class="headerlink" title="1. 服务器级别:"></a>1. 服务器级别:</h4><p>服务器级别的字符集和比较规则,通过两个系统变量来设置.</p><ul><li><code>character_set_server</code>: 服务器级别字符集</li><li><code>collation_server</code>: 服务器级别比较规则</li></ul><p><strong>两个变量的查询:</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询字符集</span><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'character_set_server'</span><span class="token punctuation">;</span><span class="token comment">-- 查比较规则</span><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'collation_server'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/3_%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/image-20210808182132027.png" alt="image-20210808182132027"></p><p><strong>两个变量的设置:</strong></p><p>可以通过 <code>SET</code>语句和<code>配置文件</code>的方式设置这两个系统变量</p><h4 id="2-数据库级别"><a href="#2-数据库级别" class="headerlink" title="2. 数据库级别:"></a>2. 数据库级别:</h4><p>数据库级别的字符集和比较规则,通过两个系统变量来设置:</p><ul><li><code>character_set_database</code>: 字符集</li><li><code>collation_database</code>: 比较规则</li></ul><p><strong>变量查询:</strong> 跟服务器级别没区别,只是换下变量名</p><p><strong>变量修改:</strong></p><p>在创建数据库的时候就可以指定字符集和比较规则:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建的时候设置</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 数据库名<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token punctuation">]</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集名<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token punctuation">]</span> COLLATION 比较规则名字<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">-- 修改</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 数据库名<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token punctuation">]</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集名<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token punctuation">]</span> COLLATION 比较规则名字<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意事项:</strong></p><ol><li>如果没有设置数据库级别的字符集和比较规则,那么就会使用服务器级别的字符集和比较规则</li><li><code>character_set_database</code>和<code>collation_database</code>这两个变量只是用来给用户展示当前数据库使用的字符集和比较规则,并不能通过<code>SET</code>这两个变量来改变当前数据库的字符集和比较规则.</li></ol><h4 id="3-表级别"><a href="#3-表级别" class="headerlink" title="3. 表级别:"></a>3. 表级别:</h4><p>表级别没有字符集和比较规则的系统变量</p><p><strong>设置表级别的字符集和比较规则:</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 建表设置</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名 <span class="token punctuation">(</span>列信息<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token punctuation">]</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集名称<span class="token punctuation">]</span><span class="token punctuation">[</span>COLLATION 比较规则名字<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">-- 修改</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token punctuation">(</span>列信息<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token punctuation">]</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集名称<span class="token punctuation">]</span><span class="token punctuation">[</span>COLLATION 比较规则名字<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意事项:</strong></p><ol><li>如果建表的时候没有设置字符集和比较规则,那么就会使用表所在数据库的字符集和比较规则.</li></ol><h4 id="4-列级别"><a href="#4-列级别" class="headerlink" title="4. 列级别:"></a>4. 列级别:</h4><p>列级别没有字符集和比较规则的系统变量</p><p><strong>设置列级别的字符集和比较规则:</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 建表设置</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名 <span class="token punctuation">(</span>    列名 字符串类型 <span class="token punctuation">[</span><span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集名称<span class="token punctuation">]</span> <span class="token punctuation">[</span>COLLATION 比较规则名<span class="token punctuation">]</span><span class="token punctuation">,</span>    其他列信息<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 修改</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">MODIFY</span> 列名 字符串类型 <span class="token punctuation">[</span><span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集名称<span class="token punctuation">]</span> <span class="token punctuation">[</span>COLLATION 比较规则名称<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意事项:</strong></p><ol><li>如果建表的时候没有设置列的字符集和比较规则,那么就会使用列所在表的字符集和比较规则.</li><li>修改列的字符集时,如果列中的数据不能使用修改后的字符集表示,则会发生错误.</li></ol><h4 id="5-仅修改字符集或比较规则"><a href="#5-仅修改字符集或比较规则" class="headerlink" title="5. 仅修改字符集或比较规则:"></a>5. 仅修改字符集或比较规则:</h4><p>字符集和比较规则之间是相互关联的,如果仅仅修改其中某一项,另外一项也会变成对应的值</p><ul><li>仅修改字符集,则 比较规则将变为修改后的字符集默认的比较规则</li><li>仅修改比较规则, 则 字符集将变为修改后的比较规则对应的字符集</li></ul><h3 id="3-3-2-c-s通信过程中使用的字符集"><a href="#3-3-2-c-s通信过程中使用的字符集" class="headerlink" title="3.3.2 c/s通信过程中使用的字符集:"></a>3.3.2 c/s通信过程中使用的字符集:</h3><ol><li><p>客户端向服务器发送数据的时候,会使用一种字符集对数据进行编码,服务器接收到数据之后会对数据进行解码</p></li><li><p>字符集转换: 就是服务器接收到数据之后使用与客户端相同的字符集解码,然后再用其他字符集对数据进行编码</p></li><li><p>一次查询请求字符集的变化:</p><ol><li><p>客户端发送请求: </p><p>客户端在发送查询请求的时候,默认使用的字符集与系统使用的字符集相同,使用该字符集给数据进行编码.</p><blockquote><p>特别的: win系统下,可以使用<code>--defualt-character-set</code>启动项设置客户端使用的字符集,<code>unix系统</code>不行</p></blockquote></li><li><p>服务器接收请求:</p><p>服务器接收到客户端编码之后的二进制字节序列后,会为当前客户端维护一个<code>SESSION范围的变量 --- character_set_client</code>,该变量表示的是客户端在编码数据的时候使用的字符集.</p><p>如果<code>character_set_client</code>表示的字符集不能解码客户端的请求,则 报错</p></li><li><p>服务器处理请求:</p><p>在真正处理之前,会将请求数据使用 <code>character_set_client</code>表示的字符集进行解码,解码之后使用<code>SESSION 范围变量 cahracter_set_connect</code>对数据进行编码,称为一个新的字节序列</p><p><code>character_set_client</code> 变量的作用是: 描述服务器接收到请求数据并解码之后,要想正确表示客户端表达的语义应该使用什么字符集进行编码.</p></li><li><p>服务器响应之前对响应数据进行编码:</p><p>将查询结果通过数据本身在Mysql中使用的字符集进行解码,然后根据<code>SESISION范围变量 character_set_result</code>表示的字符集进行编码,编码之后发送给客户端</p></li><li><p>客户端接收到相应之后:</p><p>使用默认的字符集对数据进行解码,然后展示给用户</p></li></ol></li><li><p>交换过程流程图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/3_%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/image-20210808195044276.png" alt="image-20210808195044276"></p></li><li><p>几个变量的总结:</p><table><thead><tr><th>系统变量(SESSION范围)</th><th>作用</th></tr></thead><tbody><tr><td>character_set_client</td><td>表示请求数据编码使用的字符集</td></tr><tr><td>character_set_connection</td><td>表示请求序列需要被转换的字符集</td></tr><tr><td>character_set_result</td><td>表示客户端希望的响应数据编码时使用的字符集</td></tr></tbody></table><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/3_%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/image-20210808193922376.png" alt="image-20210808193922376"></p></li></ol><h3 id="3-3-3-比较规则的应用"><a href="#3-3-3-比较规则的应用" class="headerlink" title="3.3.3 比较规则的应用:"></a>3.3.3 比较规则的应用:</h3><p>比较规则主要是应用于 数据字段排序.如果发现数据排序结果与期望不同,就可以考虑是不是比较规则的问题.</p>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2 重要系统变量</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/2_%E9%87%8D%E8%A6%81%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/2_%E9%87%8D%E8%A6%81%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-启动选项和配置文件"><a href="#2-1-启动选项和配置文件" class="headerlink" title="2.1 启动选项和配置文件"></a>2.1 启动选项和配置文件</h2><p>任何程序都可以通过配置文件和程序启动参数设置该程序在运行的时候的一些默认值和必要参数的值.</p><h3 id="2-1-1-在命令行上使用选项"><a href="#2-1-1-在命令行上使用选项" class="headerlink" title="2.1.1  在命令行上使用选项:"></a>2.1.1  在命令行上使用选项:</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 在启动的时候使用选项的通用格式:</span>可执行文件 --启动选项1<span class="token punctuation">[</span><span class="token operator">=</span>值1<span class="token punctuation">]</span> --启动选项2<span class="token punctuation">[</span><span class="token operator">=</span>值2<span class="token punctuation">]</span> --启动选项3<span class="token punctuation">[</span><span class="token operator">=</span>值3<span class="token punctuation">]</span> <span class="token punctuation">..</span>. --启动选项n<span class="token punctuation">[</span><span class="token operator">=</span>值n<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在命令行中,可以将各个启动选项写到一行里面,每个启动选项使用<code>--</code>表示开始,选项之间使用空格分开.</p><p><strong>选项的长形式和短形式</strong>: <code>--</code>为参数的长形式,<code>MYSQL</code>对于某些常用的参数提供了短形式<code>-</code>,比如: <code>mysql -p</code>启动的时候确定要连接的服务器端</p><p><strong>注意事项:</strong></p><ol><li>在命令行中指定选项值得时候需要注意, <code>选项名</code>、<code>=</code>和<code>值</code>这三者之间是不能有空格的.</li><li>长形式和短形式之间的区别是: 长形式前缀为 <code>--</code>,短形式为 <code>-</code>;长形式的选项名是单词,短形式的选项名是字母</li><li>选项名是区分大小写的: <code>-p</code> — 表示密码 和<code>-P</code> — 表示端口号 这两个之间是不一样的.</li><li><code>可执行文件 --help</code>: 可以看到该可执行文件支持的启动选项</li></ol><h3 id="2-1-2-配置文件中使用选项"><a href="#2-1-2-配置文件中使用选项" class="headerlink" title="2.1.2 配置文件中使用选项:"></a>2.1.2 配置文件中使用选项:</h3><p><font color="red">推荐使用选项的方式.</font></p><ol><li><p>配置文件的路径:</p><p><code>mysql</code>会从多个路径下面的配置文件去寻找相关配置信息.<code>unix系统</code>下的配置文件路径为:</p><table><thead><tr><th>/etc/my.cnf</th><th></th></tr></thead><tbody><tr><td>/etc/mysql/my.cnf</td><td></td></tr><tr><td>SYSCONFDIR/my.cnf</td><td></td></tr><tr><td>#MYSQL_HOME/my.cnf</td><td>特定服务器的悬系那个(仅限服务器)</td></tr><tr><td>defaults-extra-file</td><td>命令行指定的额外配置文件路径</td></tr><tr><td>~/.my.cnf</td><td>特定于用户的选项</td></tr><tr><td>~/.mylogin.cnf</td><td>特定于用户的登录路径选项(仅限客户端)</td></tr></tbody></table><p>说明:</p><ul><li>SYSCONFDIR: 表示使用CMake构建MySQL时使用SYSCONFDIR选项指定的目录</li><li>MYSQL_HOME: 就是配置好的系统环境变量.</li><li>除了<code>.mylogin,cnf</code>(只能存放客户端的一些选项), <code>$MYSQL_HOME/my.cnf</code>(只能存放服务器相关选项)外,其余配置文件即可以存放客户端,也可以存放服务器相关的选项.</li><li><code>~</code>: 表示当前用户目录,<code>unix系统</code>的概念</li><li><code>default-extra-file</code>: 表示程序启动的时候可以通过指定<code>default-extra-file</code>启动选项的值来添加额外的配置文件路径</li><li><code>.mylogin.cnf</code>是一个特殊的配置文件,私有<code>mysql_config_editor</code>实用程序创建的加密文件.该文件只能包含一些在启动客户端程序时用于连接服务器的选项.</li></ul></li><li><p>配置文件的内容:</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">[mysqld](具体的启动选项....)[client](具体的启动选项....)[mysql](具体的启动选项....)[mysqld]<span class="token comment"># binlog 配置</span><span class="token attr-name">log-bin</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql/logs/mysql-bin.log</span><span class="token attr-name">expire-logs-days</span><span class="token punctuation">=</span><span class="token attr-value">14</span><span class="token attr-name">max-binlog-size</span><span class="token punctuation">=</span><span class="token attr-value">500M</span><span class="token attr-name">server-id</span><span class="token punctuation">=</span><span class="token attr-value">1</span><span class="token comment"># GENERAL</span><span class="token attr-name">basedir</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql</span><span class="token attr-name">datadir</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql/data</span><span class="token attr-name">socket</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql/mysql.sock</span><span class="token attr-name">user</span><span class="token punctuation">=</span><span class="token attr-value">mysql</span><span class="token attr-name">default-storage-engine</span><span class="token punctuation">=</span><span class="token attr-value">InnoDB</span><span class="token attr-name">character-set-server</span><span class="token punctuation">=</span><span class="token attr-value">utf8</span><span class="token attr-name">lower_case_table_names</span> <span class="token punctuation">=</span> <span class="token attr-value">1</span><span class="token attr-name">explicit_defaults_for_timestamp</span><span class="token punctuation">=</span><span class="token attr-value">true</span>[mysqld_safe]<span class="token attr-name">log-error</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql/mysql-error.log</span><span class="token attr-name">pid-file</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql/mysqld.pid</span>[client]<span class="token attr-name">socket</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql/mysql.sock</span>[mysql]<span class="token attr-name">default-character-set</span><span class="token punctuation">=</span><span class="token attr-value">utf8</span><span class="token attr-name">socket</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql/mysql.sock</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明:</p><ul><li><p>配置文件只能使用长形式的选项来设置,且<code>不能使用--前缀</code></p></li><li><p><code>选项</code>、<code>=</code>和<code>值</code>之间不能有空格</p></li><li><p><code>[]</code>: 表示一个选项组,名称和可执行文件相对应,特别地:</p><ul><li><code>[server]</code>: 下面的启动选项将作用于所有的服务器程序</li><li><code>[client]</code>: 下面的启动选项将作用于所有的客户端程序</li></ul></li><li><p>程序对应类别和能读取的选项组:</p><table><thead><tr><th>程序名</th><th>类别</th><th>能读取的组</th></tr></thead><tbody><tr><td>mysqld</td><td>服务器程序</td><td>[mysqld]  [server]</td></tr><tr><td>mysqld_safe</td><td>服务器程序</td><td>[mysqld] [server] [mysqld_safe]</td></tr><tr><td>mysql.server</td><td>服务器程序</td><td>[mysqld] [server] [mysql.server]</td></tr><tr><td>mysql</td><td>客户端程序</td><td>[mysql] [client]</td></tr><tr><td>mysqladmin</td><td>客户端程序</td><td>[mysqladmin] [client]</td></tr><tr><td>mysqldump</td><td>客户端程序</td><td>[mysqldump] [client]</td></tr></tbody></table></li></ul></li></ol><p>   配置文件设置系统变量举例:</p>   <pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">[server]skiping-networking<span class="token attr-name">default-storage-engine</span><span class="token punctuation">=</span><span class="token attr-value">MyISAM</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>   配置文件,如上,然后通过 <code>mysqld</code>启动服务器:</p><p>   虽然在启动的时候,并没有设置任何的启动项,但是<code>mysql</code>会去默认路径下面读取相关的配置文件,上面的这个配置文件就会被读取出来,并且<code>mysqld</code>是可以读取<code>[server]</code>组下面的配置的.所以上面两个配置通过<code>mysqld</code>是可以生效的.</p><p>   <font color="red">如果上面配置文件中的<code>[server]</code>改成<code>[client]</code>,那么设置的启动项是不会生效的</font></p><ol start="3"><li><p>特定<code>mysql</code>版本的专用选项组:</p><p>在具体的选项组上面加上<code>mysql</code>的版本号,就可以让该选项组只能被对应<code>mysql</code>版本的可执行文件才能读取到.</p><p>比如: <code>[mysqld-5.7] </code>就只能由5.7版本的<code>mysql</code>中的可执行文件 <code>mysqld</code>读取到</p></li><li><p>配置文件的优先级:</p><p>如果创建了多个配置文件,配置文件将按照下图从上到下的顺序依次读取配置文件:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/2_%E9%87%8D%E8%A6%81%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/image-20210807171454760.png"></p><p><font color="red">注意: 如果不同的配置文件中设置了相同的配置项,那么后面加载的配置文件中的配置项,会将先加载的配置文件中的配置项覆盖.即<code>多个配置文件,相同配置,以最后加载的为准</code></font></p></li><li><p>同一个配置文件中多个组的优先级:</p><p>在同一个配置文件中,可执行文件会从上到下依次读取多个组的配置文件,如果多个组中存在相同的配置项,以后面读取到的配置项为准.</p></li><li><p>default-file的使用:</p><p>default-file: 在程序启动的时候指定配置文件的加载路径,<font color="red">注意: default-file指定了之后,就只会从指定的文件路径中去加载配置,程序不再去默认的配置文件加载配置</font></p><p>default-extra-file: 在程序启动的时候指定配置文件<code>额外</code>的加载路径,<font color="red">注意: default-extra-file指定的是额外的配置文件路径,也就是说程序还是会去默认的配置文件路径加载配置</font></p></li><li><p>命令行和配置文件中启动选项的区别:</p><p>除了部分专门为<code>命令行</code>设计的启动选项外,大部分启动选项都可以写入配置文件中.如果 命令行和配置文件出现了相同的配置项,那么以<code>命令行中的配置项为准</code></p></li></ol><h2 id="2-2-系统变量"><a href="#2-2-系统变量" class="headerlink" title="2.2 系统变量:"></a>2.2 系统变量:</h2><p>一些会影响<code>mysql</code>程序行为的变量,被称为<code>系统变量</code>.</p><p>比如: </p><ul><li><code>max_connects:</code> 控制同时连接的客户端数量</li><li><code>default_storage_engine:</code>控制表的默认存储引擎</li><li><code>query_cache_size:</code>控制查询缓存的默认大小</li></ul><h3 id="2-2-1-查看系统变量"><a href="#2-2-1-查看系统变量" class="headerlink" title="2.2.1 查看系统变量:"></a>2.2.1 查看系统变量:</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 建议使用模糊匹配去查询需要的系统变量</span><span class="token keyword">show</span> variables <span class="token punctuation">[</span>liske 匹配的模式<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-2-2-设置系统变量"><a href="#2-2-2-设置系统变量" class="headerlink" title="2.2.2 设置系统变量:"></a>2.2.2 设置系统变量:</h3><h4 id="1-通过启动项设置"><a href="#1-通过启动项设置" class="headerlink" title="1. 通过启动项设置:"></a>1. 通过启动项设置:</h4><ul><li><p>通过命令行设置系统变量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqld --default-storage-engine<span class="token operator">=</span>MyISAM --max-connections<span class="token operator">=</span><span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>通过配置文件设置系统变量:</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">[server]<span class="token attr-name">default-storage-engine</span><span class="token punctuation">=</span><span class="token attr-value">InnoDB</span><span class="token attr-name">max_connections</span><span class="token punctuation">=</span><span class="token attr-value">1000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="2-服务器程序运行过程中设置"><a href="#2-服务器程序运行过程中设置" class="headerlink" title="2. 服务器程序运行过程中设置:"></a>2. 服务器程序运行过程中设置:</h4><p>在服务器程序运行过程中可以动态修改变量而且无需停止并启动服务器.</p><p><strong>系统变量的作用范围:</strong></p><p><code>GLOBAL(全局范围)</code>: 影响服务器的整体操作.具有<code>GLOBAL</code>作用范围的系统变量可以称为全局变量</p><p><code>SESSION(会话范围)</code>: 影响某个客户端链接的操作.具有<code>SESSION</code>作用范围的变量可以称为会话变量</p><p><strong>系统变量初始化的过程</strong></p><ol><li><p>服务器在启动的时候,会将每个全局变量按照配置设置全局变量的默认值.</p></li><li><p>客户端连接到服务器,服务器会为每个连接维护一组会话变量,初始值为同名的全局变量的值,(有部分的特殊会话变量不会按照全局变量的值进行初始化)</p></li></ol><p>举个例子: 以默认存储引擎为例</p><ol><li><p>服务器启动,会将<code>default-storage-engine</code>按照配置设置成为一个作用范围为<code>GLOBAL</code>的全局变量.</p></li><li><p>之后,每一个客户端成功连接,服务器都会为其分配一个名字为 <code>default-storage-engine</code>,作用范围为<code>SESSION</code>的会话变量,且这个会话变量的初始值为 <code>作用范围为GLOBAL的同名全局变量的值</code></p></li></ol><p><strong>设置系统变量:</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">]</span> 系统变量名 <span class="token operator">=</span> 值<span class="token keyword">set</span> <span class="token punctuation">[</span>@@<span class="token punctuation">(</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">]</span>系统变量名 <span class="token operator">=</span> 值<span class="token comment">-- 设置全局默认存储引擎:</span><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> <span class="token keyword">default</span><span class="token operator">-</span>storage<span class="token operator">-</span><span class="token keyword">engine</span> <span class="token operator">=</span> MyISAM<span class="token keyword">SET</span> @<span class="token variable">@GLOBAL.default</span><span class="token operator">-</span>storage<span class="token operator">-</span><span class="token keyword">engine</span> <span class="token operator">=</span> MyISAM<span class="token comment">-- 设置当前会话默认存储引擎</span><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> <span class="token keyword">default</span><span class="token operator">-</span>storage<span class="token operator">-</span><span class="token keyword">engine</span> <span class="token operator">=</span> MyISAM<span class="token keyword">SET</span> @<span class="token variable">@GLOBAL.default</span><span class="token operator">-</span>storage<span class="token operator">-</span><span class="token keyword">engine</span> <span class="token operator">=</span> MyISAM<span class="token keyword">SET</span> <span class="token keyword">default</span><span class="token operator">-</span>storage<span class="token operator">-</span><span class="token keyword">engine</span> <span class="token operator">=</span> MyISAM<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上,<code>GLOBAL</code>影响的是之后新客户端连接到服务器时 该系统变量取什么值,<code>SESSION</code>影响的是 当前客户端连接到服务器时 该系统变量取什么值.</p><p><font color="red"><b>注意:</b></font></p><ol><li> 如果不指定作用范围,默认是<code>SESSION</code>范围</li><li> 改变<code>GLOBAL</code>作用范围的变量值,不会影响服务器为已经连接的客户端分配好了,作用范围为<code>SESSION</code>的对应变量值,只会影响后续连接到服务器的客户端<code>SESSION</code>范围的值.</li></ol><p><strong>查看不同作用范围的值</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">]</span> VARIABLES <span class="token punctuation">[</span><span class="token operator">LIKE</span> <span class="token string">'匹配模式'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意:</p><ul><li>如果查询的是<code>GLOBAL</code>全局变量,如果改变量没有<code>GLOBAL</code>作用范围是不会显示出来的</li><li>同理,变量没有<code>SESSION</code>作用范围,也不会显示</li><li>如果不指定作用范围,默认查询的是<code>SESSION</code>作用范围</li></ul><h4 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项:"></a>3. 注意事项:</h4><ol><li><p><code>关于作用范围</code>:  并不是所有的系统变量都既有<code>GLOBAL</code>范围又有<code>SESSION</code>范围,可能只有其中一种范围.</p></li><li><p>有些系统变量是只读的,是不能被设置的</p></li><li><p>启动项和系统变量的区别:</p><p><code>启动项</code>是程序启动时由用户传递的一些参数,<code>系统变量</code>是影响服务器程序运行行为的变量.</p><ul><li>大部分系统变量都可以通过启动项进行传参</li><li>有些系统变量是程序运行过程中生成的,不能当做启动项来设置</li><li>部分启动项也不是系统变量</li></ul></li></ol><h2 id="2-3-状态变量"><a href="#2-3-状态变量" class="headerlink" title="2.3 状态变量:"></a>2.3 状态变量:</h2><p><code>状态变量</code>: 是为了让我们更好了解服务器程序运行情况的信息数据</p><p>状态变量是用来展示服务器程序运行情况的信息数据,只能由服务器程序自己设置,不能人为设置.</p><p>查询语法:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">]</span> <span class="token keyword">STATUS</span> <span class="token punctuation">[</span><span class="token operator">LIKE</span> <span class="token string">'匹配模式'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1 初识MySQL</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-MySQL的C-S架构"><a href="#1-1-MySQL的C-S架构" class="headerlink" title="1.1 MySQL的C/S架构:"></a>1.1 MySQL的C/S架构:</h2><p>MySQL是典型的C/S架构, 由 <code>客户端程序Client</code> 和 <code>服务端程序server</code>两部分组成.</p><p>MySQL的大致运行过程为: 服务端程序直接与要存储的数据打交道,多个客户端程序可以连接到这个服务器程序,向服务器程序发送 CRUD请求,然后服务端程序根据这些请求进行相应的处理,最后将结果响应给客户端.</p><h2 id="1-2-MySQL的安装"><a href="#1-2-MySQL的安装" class="headerlink" title="1.2 MySQL的安装:"></a>1.2 MySQL的安装:</h2><p>[参考链接](zip包安装mysql： <a href="https://www.cnblogs.com/qixing/p/12271499.html">https://www.cnblogs.com/qixing/p/12271499.html</a>)</p><p><strong>注意事项</strong></p><p>配置文件中一些重要文件的路径要写对, <font color="red">都需要根据自己具体的文件所在路径来写</font>,比如: </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token comment"># binlog 配置</span>log<span class="token punctuation">-</span>bin=/usr/local/mysql/logs/mysql<span class="token punctuation">-</span>bin.logexpire<span class="token punctuation">-</span>logs<span class="token punctuation">-</span>days=14max<span class="token punctuation">-</span>binlog<span class="token punctuation">-</span>size=500Mserver<span class="token punctuation">-</span>id=1<span class="token comment"># GENERAL</span>basedir=/usr/local/mysqldatadir=/usr/local/mysql/datasocket=/usr/local/mysql/mysql.sockuser=mysqldefault<span class="token punctuation">-</span>storage<span class="token punctuation">-</span>engine=InnoDBcharacter<span class="token punctuation">-</span>set<span class="token punctuation">-</span>server=utf8lower_case_table_names = 1explicit_defaults_for_timestamp=true<span class="token punctuation">[</span>mysqld_safe<span class="token punctuation">]</span>log<span class="token punctuation">-</span>error=/usr/local/mysql/mysql<span class="token punctuation">-</span>error.logpid<span class="token punctuation">-</span>file=/usr/local/mysql/mysqld.pid<span class="token punctuation">[</span>client<span class="token punctuation">]</span>socket=/usr/local/mysql/mysql.sock<span class="token punctuation">[</span>mysql<span class="token punctuation">]</span>default<span class="token punctuation">-</span>character<span class="token punctuation">-</span>set=utf8socket=/usr/local/mysql/mysql.sock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>mysql</code>通过zip包安装之后,文件目录为:  学习的时候<code>mysql</code>程序是安装在<code>/usr/local/mysql</code>目录下面的</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/image-20210805221313354.png"></p><h3 id="1-2-1-bin目录下的可执行文件"><a href="#1-2-1-bin目录下的可执行文件" class="headerlink" title="1.2.1 bin目录下的可执行文件"></a>1.2.1 bin目录下的可执行文件</h3><p><code>bin</code>目录下面放了很多的<code>mysql</code>程序的可执行文件,大致如下:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/image-20210805221420290.png"></p><p>启动<code>mysql</code>: 通常是通过 上面列举的可执行文件的<code>相对</code>/<code>绝对</code>路径来启动<code>mysql</code>.比如: <code>/usr/local/mysql/bin/mysqld</code>,但是为了在任何地方都可以直接使用<code>mysql</code>的可执行文件, 会将<code>mysql</code>的<code>bin</code>目录加入到环境变量文件中去.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/image-20210805221952074.png"></p><h2 id="1-3-启动mysql服务端程序"><a href="#1-3-启动mysql服务端程序" class="headerlink" title="1.3 启动mysql服务端程序:"></a>1.3 启动<code>mysql</code>服务端程序:</h2><h3 id="1-3-1-mysqld"><a href="#1-3-1-mysqld" class="headerlink" title="1.3.1 mysqld:"></a>1.3.1 <code>mysqld</code>:</h3><p><code>mysqld</code>可执行文件就表示一个<code>mysql</code>服务器程序,运行<code>mysqld</code>就可以启动一个<code>mysql</code>进程. <strong>但是这个可执行文件不常用</strong></p><h3 id="1-3-2-mysqld-safe"><a href="#1-3-2-mysqld-safe" class="headerlink" title="1.3.2 mysqld_safe:"></a>1.3.2 <code>mysqld_safe</code>:</h3><p><code>mysqld_safe</code>是一个启动脚本, 在脚本中会去调用<code>mysqld</code>可执行文件来启动一个 <code>mysql</code>进程, 然后持续监控服务器的运行状态, <strong>当服务器出现错误的时候可以帮助重启服务器程序</strong>. 程序运行期间的<code>错误日志</code>或者其他<code>诊断日志</code>被存放在数据目录(我的路径为: <code>/usr/local/mysql/data</code>)中一个<code>.err</code>后缀的文件里面.</p><h3 id="1-3-3-mysql-server"><a href="#1-3-3-mysql-server" class="headerlink" title="1.3.3 mysql.server:"></a>1.3.3 <code>mysql.server</code>:</h3><p><code>mysql.server</code>也是启动脚本, 它会简介的调用<code>mysald_safe</code>. </p><p><code>mysql.server</code>实际上是一个链接文件,指向的是 <code>/usr/local/mysql/support-files/mysql.server</code></p><p><code>mysql.server</code>启动<code>mysql</code>程序:  <code>mysql.server start</code></p><p><code>mysql.server</code>停止<code>mysql</code>程序:  <code>mysql.server stop</code></p><h3 id="1-3-4-mysqld-multi"><a href="#1-3-4-mysqld-multi" class="headerlink" title="1.3.4 mysqld_multi:"></a>1.3.4 <code>mysqld_multi</code>:</h3><p><code>mysqld_multi</code>: 使用来启动多个<code>mysql</code>服务器程序的,也可以报告服务器程序的运行状态,本质上还是是一个 <code>shell</code>脚本.</p><h2 id="1-4-启动mysql客户端程序"><a href="#1-4-启动mysql客户端程序" class="headerlink" title="1.4 启动mysql客户端程序:"></a>1.4 启动<code>mysql</code>客户端程序:</h2><p><code>bin</code>目录下面有许多的客户端程序,如: <code>mysqladmin</code>,<code>mysqldump</code>,<code>mysqlcheck</code>等等.重点关注名字为 <code>mysql</code> 的可执行文件.</p><p>通过<code>mysql</code>可执行文件常用格式:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -h主机ip -P端口号 -D数据库名 -u用户名 -p密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>-h</th><th align="left">表示<code>mysql</code>服务器程序所在的主机i地址,本地连接可以省略这个参数</th></tr></thead><tbody><tr><td>-P</td><td align="left">表示<code>mysql</code>服务器程序所使用的端口号</td></tr><tr><td>-D</td><td align="left">表示要连接<code>mysql</code>服务器程序中的哪一个数据库</td></tr><tr><td>-u</td><td align="left">使用哪一个用户来链接<code>mysql</code>服务器程序</td></tr><tr><td>-p</td><td align="left">密码</td></tr></tbody></table><p>链接成功后如图:  本地连接省略了部分参数</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/image-20210805224537807.png"></p><p>退出<code>mysql</code>客户端程序: <code>quit</code>,<code>exit</code>,<code>\q</code>等命令都可以退出</p><h3 id="1-4-1-连接注意事项"><a href="#1-4-1-连接注意事项" class="headerlink" title="1.4.1 连接注意事项:"></a>1.4.1 连接注意事项:</h3><ol><li><code>不要显示通过mysql -pxxxx去连接服务器</code>: 通过<code>history</code>,<code>ps</code>之类的命令可以看到</li><li><code>一定要显示连接的话,-p和密码之间不能有空格</code>: <code>-p</code>之后的任何字符都会被认为是密码的一部分,如果密码含有特殊字符还需要转义</li><li><code>参数之间没有顺序要求</code>.</li><li><code>unix系统中,如果不指定-u参数,会使用系统当前用户作为mysql用户去连接服务器,win系统默认是ODBC</code>.</li></ol><h2 id="1-5-客户端与服务端的连接过程"><a href="#1-5-客户端与服务端的连接过程" class="headerlink" title="1.5 客户端与服务端的连接过程:"></a>1.5 客户端与服务端的连接过程:</h2><h3 id="1-5-1-TCP-IP"><a href="#1-5-1-TCP-IP" class="headerlink" title="1.5.1 TCP/IP:"></a>1.5.1 TCP/IP:</h3><p><code>mysql</code>程序是一个<code>c/s</code>架构的程序,底层是依靠<code>tcp/ip</code>网络通信协议来实现<code>c/s</code>之间的通信.<code>tcp/ip</code>协议是通过 <code>ip+端口号</code>来确定一个应用层程序的.而服务端程序则会持续监听<code>默认端口号</code>或者<code>启动时指定的其他端口号</code></p><p><code>mysql</code>服务端程序默认的端口号是: <code>3306</code>.也可以通过 <code>mysqld -P端口号</code>在服务器程序启动的时候使用其他端口作为服务器程序监听的端口号.</p><h3 id="1-5-2-命名管道和共享内存"><a href="#1-5-2-命名管道和共享内存" class="headerlink" title="1.5.2 命名管道和共享内存:"></a>1.5.2 命名管道和共享内存:</h3><p>win系统上可以给客户端程序和服务器程序之间使用<code>命名管道</code>或<code>共享内存</code>进行通信,不过启动时需要添加一些参数:</p><ol><li>使用<code>命名管道</code>进行进程之间通信:<ul><li> 启动服务器程序的时候,需要加上<code>--enable-named-pipe</code>参数</li><li> 启动客户端程序的时候,需要加上 <code>--pipe</code>或者 <code>--prototype=pipe</code></li></ul></li><li>使用<code>共享内存</code>进行进程之间通信:<ul><li>启动服务器,加上<code>--shared-memory</code></li><li>服务器启动之后共享内存就是本地客户端程序默认的链接方式,也可以在启动客户端,加上<code>--protocol=memory</code>来链接</li></ul></li></ol><h3 id="1-5-3-UNIX域套接字"><a href="#1-5-3-UNIX域套接字" class="headerlink" title="1.5.3 UNIX域套接字:"></a>1.5.3 UNIX域套接字:</h3><p>当服务器和客户端都是运行在<code>UNIX系统</code>上的时候,可以使用<code>UNIX域套接字</code>进行进程之间通信</p><p>开启方法: </p><ul><li><p>服务器默认开启: 启动客户端程序的时候 <code>不指定-h参数</code>、<code>-h参数为localhost</code> 或者 <code>指定--protocol=socket</code>都可以开启<code>UNIX域套接字</code>进行进程之间通信.</p></li><li><p>客户端显示开启: <code>mysql -hlocalhost -uroot --socket=文件路径</code></p></li></ul><p>默认的<code>UNIX域套接字文件</code>为 <code>/tmp/mysql.sock</code>,可以通过 <code>mysqld --socket=文件路径</code>修改.</p><h2 id="1-6-服务端程序处理客户端请求"><a href="#1-6-服务端程序处理客户端请求" class="headerlink" title="1.6 服务端程序处理客户端请求:"></a>1.6 服务端程序处理客户端请求:</h2><p>无论客户端进程和服务端进程采用什么方式通信,最后客户端程序的请求都会转换成一段文本(<code>MYSQL语句</code>),服务器进程处理后再向客户端进程响应一段文本<code>处理结果</code></p><p>整个处理过程大致如下: </p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/image-20210805231436699.png"></p><h3 id="1-6-1-处理连接"><a href="#1-6-1-处理连接" class="headerlink" title="1.6.1 处理连接:"></a>1.6.1 处理连接:</h3><p><code>mysql</code>对于处理客户端请求的线程采用了<code>池化</code>思想来管理.每当有客户端请求过来,服务器进程都会创建一个线程专门与这个客户端进行交互; 当客户端与服务器断开连接的时候,线程不会被销毁,而是被集中缓存起来,待后续连接过来继续使用.</p><p>客户端发送给服务端的连接,会携带<code>主机信息</code>,<code>用户名</code>,<code>密码</code>等信息,服务端会对这些信息进行校验,通过的连接服务端才会创建线程与其建立连接.</p><h3 id="1-6-2-解析与优化"><a href="#1-6-2-解析与优化" class="headerlink" title="1.6.2 解析与优化:"></a>1.6.2 解析与优化:</h3><p>连接建立之后,服务端已经获取到了客户端的文本请求,然后开始对文本请求进行处理,比较重要的部分是: <code>查询缓存</code>,<code>语法解析</code>,<code>查询优化</code></p><ol><li>查询缓存: <code>MYSQL</code>服务器会对之前已经处理过的文本请求 和 请求结果进行缓存,如果当前查询是已经处理过的,直接将对应的结果返回给客户端;如果没有处理过就会进行下一步处理.<ul><li>缓存不命中的原因:<ul><li>如果两个查询请求有<code>任何字符上的不同</code>(如: 空格、注释、大小写),都会造成缓存不命中</li><li>如果查询请求中包含某些系统函数,用户自定义变量和函数、系统表,如: <code>mysql</code>、<code>information_schema</code>等</li><li><code>mysql</code>的缓存系统会监测涉及的每张表,只要该表的<code>结构</code>或者<code>数据</code>被修改,那么 与该表关联的所有查询缓存都会被删除</li></ul></li><li>查询缓存的缺点: 查询缓存可以提高查询效率,但是也会存在对缓存数据进行维护的开销<ul><li>每次都要去查询缓存中检索</li><li>查询请求处理完之后要更新缓存数据</li><li>维护该查询缓存对应的内存区域等</li></ul></li></ul></li><li>语法解析: 如果没有命中缓存,就会进行真正的查询处理.<code>MYSQL</code>会对查询请求文本进行解析,判断语法是否正确,然后从文本中将要查询的表、和查询条件提取出来,存放在<code>MYSQL</code>服务器内部使用的结构上</li><li>查询优化: 在语法解析之后,<code>MYSQL</code>会对查询语句进行优化.优化后的结果就是生成一个执行计划.</li></ol><h3 id="1-6-3-存储引擎"><a href="#1-6-3-存储引擎" class="headerlink" title="1.6.3 存储引擎:"></a>1.6.3 存储引擎:</h3><p><code>查询优化</code>之后还没有去访问表中的数据.<code>MYSQL</code>服务器将数据的<code>存储</code>和<code>提取</code>操作都封装到了一个名为 <code>存储引擎</code>的模块里面.</p><p><code>存储引擎</code>主要还是负责 <code>物理上如何表示数据记录</code>、<code>如何从逻辑上的表中读取数据</code>、<code>怎么把数据写入到具体的物理存储器上</code>等</p><p>为了方便管理, <code>MYSQL</code>处理请求的过程大致被分为了两部分: <code>server层</code>(连接管理,查询缓存,语法解析,查询缓存),<code>存储引擎层(存取真实数据的功能)</code>.所以在<code>server层</code>堆语法进行优化完毕之后,只需要按照<code>执行计划</code>去调用底层存储引擎提供的接口获取到数据后返回给客户端.通常是以一条<code>记录</code>为单位.</p><p>以<code>SELECT</code>为例: <code>server层</code>按照执行计划向<code>存储引擎层</code>获取一条<code>记录</code>然后判断是否符合<code>where</code>条件,如果符合就返回给客户端(存入一个缓冲区,缓冲区满了一起flush出去),不符合就跳过该数据,然后向<code>存储引擎层</code>获取下一条数据,以此往复.</p><h2 id="1-7-常用的存储引擎"><a href="#1-7-常用的存储引擎" class="headerlink" title="1.7 常用的存储引擎:"></a>1.7 常用的存储引擎:</h2><table><thead><tr><th align="left">存储引擎</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">ARCHIVE</td><td align="center">用于数据文档(插入之后不能再被修改)</td></tr><tr><td align="left">BLACKHOLE</td><td align="center">丢弃写操作,读操作会返回空内容</td></tr><tr><td align="left">CSV</td><td align="center">在存储数据的时候,以逗号分隔数据项</td></tr><tr><td align="left">FEDERATED</td><td align="center">用来访问远程表</td></tr><tr><td align="left">InnoDB</td><td align="center">支持事务,行锁,外键</td></tr><tr><td align="left">MyISAM</td><td align="center">只要的非事务处理存储引擎</td></tr><tr><td align="left">MEMORY</td><td align="center">数据存储在内存,不存储在磁盘里面;多用于临时表</td></tr><tr><td align="left">MERGE</td><td align="center">用来管理多个MyISAM表构成的表集合</td></tr><tr><td align="left">NDB</td><td align="center">MySQL集群专用存储引擎</td></tr></tbody></table><p>其中最常用的是 <code>InnoDB</code>,<code>MyISAM</code>和<code>MEMORY</code>.</p><p>支持的功能:</p><table><thead><tr><th align="left">Feature</th><th align="left">MyISAM</th><th align="left">Memory</th><th align="left">InnoDB</th><th align="left">Archive</th><th align="left">NDB</th></tr></thead><tbody><tr><td align="left">B-tree indexes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Backup/point-in-time recovery (note 1)</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Cluster database support</td><td align="left">No</td><td align="left">No</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Clustered indexes</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Compressed data</td><td align="left">Yes (note 2)</td><td align="left">No</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">No</td></tr><tr><td align="left">Data caches</td><td align="left">No</td><td align="left">N/A</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Encrypted data</td><td align="left">Yes (note 3)</td><td align="left">Yes (note 3)</td><td align="left">Yes (note 4)</td><td align="left">Yes (note 3)</td><td align="left">Yes (note 3)</td></tr><tr><td align="left">Foreign key support</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes (note 5)</td></tr><tr><td align="left">Full-text search indexes</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes (note 6)</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Geospatial data type support</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Geospatial indexing support</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes (note 7)</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Hash indexes</td><td align="left">No</td><td align="left">Yes</td><td align="left">No (note 8)</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Index caches</td><td align="left">Yes</td><td align="left">N/A</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Locking granularity</td><td align="left">Table</td><td align="left">Table</td><td align="left">Row</td><td align="left">Row</td><td align="left">Row</td></tr><tr><td align="left">MVCC</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Replication support (note 1)</td><td align="left">Yes</td><td align="left">Limited (note 9)</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Storage limits</td><td align="left">256TB</td><td align="left">RAM</td><td align="left">64TB</td><td align="left">None</td><td align="left">384EB</td></tr><tr><td align="left">T-tree indexes</td><td align="left">No</td><td align="left">No</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Transactions</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Update statistics for data dictionary</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr></tbody></table><h2 id="1-8-关于引擎的一些操作"><a href="#1-8-关于引擎的一些操作" class="headerlink" title="1.8 关于引擎的一些操作:"></a>1.8 关于引擎的一些操作:</h2><h3 id="1-8-1-查询支持的引擎"><a href="#1-8-1-查询支持的引擎" class="headerlink" title="1.8.1 查询支持的引擎:"></a>1.8.1 查询支持的引擎:</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> engines<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/image-20210806000318560.png"></p><ul><li><code>Support</code>: 是否支持该引擎,<code>DEFAULT</code>表示该引擎是默认存储引擎</li><li><code>Comment</code>: 是该引擎的功能概述</li><li><code>Transaction</code>: 表示该引擎是否支持事务</li><li><code>XA</code>: 表示该存储引擎是否支持分布式事务</li><li><code>Saveoptions</code>: 表示该引擎是否支持部分回滚</li></ul><h3 id="1-8-2-设置表的存储引擎"><a href="#1-8-2-设置表的存储引擎" class="headerlink" title="1.8.2 设置表的存储引擎:"></a>1.8.2 设置表的存储引擎:</h3><ol><li><p>建表的时候就设置存储引擎</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t_mysql_study<span class="token punctuation">`</span><span class="token punctuation">(</span>    字段语句<span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span> 存储引擎名字<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>修改已经创建好的表的存储引擎:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 修改表的引擎</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ENGINE</span> <span class="token operator">=</span> 存储引擎名称<span class="token punctuation">;</span><span class="token comment"># 查看建表语句来看引擎是否修改</span><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t_mysql_study<span class="token punctuation">`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/image-20210806001522467.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
