<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>sout<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"辣鸡"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> test<span class="token punctuation">:</span>    lallala<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token comment">// 事务操作示例</span><span class="token keyword">func</span> <span class="token function">transactionDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>tx<span class="token punctuation">,</span> err <span class="token operator">:=</span> sqlxDB<span class="token punctuation">.</span><span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 开启事务</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">if</span> tx <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"begin trans failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>sqlStr1 <span class="token operator">:=</span> <span class="token string">"Update t_go_study_user set name = '张三' where id=?"</span>ret1<span class="token punctuation">,</span> err <span class="token operator">:=</span> tx<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>sqlStr1<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"exec sql1 failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>affRow1<span class="token punctuation">,</span> err <span class="token operator">:=</span> ret1<span class="token punctuation">.</span><span class="token function">RowsAffected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"exec ret1.RowsAffected() failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>sqlStr2 <span class="token operator">:=</span> <span class="token string">"Update t_go_study_user set name = '张三' where id=?"</span>ret2<span class="token punctuation">,</span> err <span class="token operator">:=</span> tx<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>sqlStr2<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"exec sql2 failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>affRow2<span class="token punctuation">,</span> err <span class="token operator">:=</span> ret2<span class="token punctuation">.</span><span class="token function">RowsAffected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"exec ret1.RowsAffected() failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>affRow1<span class="token punctuation">,</span> affRow2<span class="token punctuation">)</span><span class="token keyword">if</span> affRow1 <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> affRow2 <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"事务提交啦..."</span><span class="token punctuation">)</span>tx<span class="token punctuation">.</span><span class="token function">Commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 提交事务</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"事务回滚啦..."</span><span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"exec trans success!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 紅色</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 綠色</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 黃色</div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>5 InnoDB数据页结构</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-不同类型的页简介"><a href="#5-1-不同类型的页简介" class="headerlink" title="5.1 不同类型的页简介:"></a>5.1 不同类型的页简介:</h2><p>页是<code>InnoDB存储引擎</code>管理存储空间的基本单位, 一个页的基本单位是16KB.</p><p>InnoDB为了不同目的而设计了多种不同类型的页,比如:  <code>存放表空间头部信息的页</code>, <code>存放change buffer 信息的页</code>,<code>存放INODE信息的页</code>,<code>存放undo日志信息的页</code>等等</p><p>本章节主要是介绍<code>存放表中记录的页</code>,官方称之为 : <code>索引页index</code>,为了方便理解 称之为 <code>数据页</code>.</p><h2 id="5-2-数据页结构简介"><a href="#5-2-数据页结构简介" class="headerlink" title="5.2 数据页结构简介:"></a>5.2 数据页结构简介:</h2><p><code>Mysql</code>将数据页这块16KB大小的存储空间大致被划分成了 7个部分,不同部分有不同的功能.  如图所示: </p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809223800797.png" alt="单页数据页构成图"></p><p>各部分大致存储什么内容,如下表所示:</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间(字节)</th><th>功能概述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38</td><td>页的通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56</td><td>数据页的专有信息</td></tr><tr><td>Infimum+Supremum</td><td>页面中最小记录和最大记录</td><td>26</td><td>两个虚拟记录</td></tr><tr><td>User Record</td><td>用户记录</td><td>不确定</td><td>用户存放的记录</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页目录</td><td>不确定</td><td>页中某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8</td><td>校验页是否完整</td></tr></tbody></table><h2 id="5-3-记录在页中的存储"><a href="#5-3-记录在页中的存储" class="headerlink" title="5.3 记录在页中的存储:"></a>5.3 记录在页中的存储:</h2><p>在数据页的7个部分中,用户自己存入的记录会按照指定的行格式存储到<code>User Records</code>部分中.</p><p>在数据页生成的时候实际上是没有<code>User Records</code>这部分的,每当一条数据插入进来的时候,就会去<code>Free Space</code>部分申请记录需要的空间,然后与之前的<code>User Records</code>合并.当<code>Free Space</code>使用完之后就会去申请新的数据页.</p><p>数据存入大致流程:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809223836259.png" alt="数据存入数据页大致流程"></p><p><strong>示例数据:</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> page_demo <span class="token punctuation">(</span>c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>c2 <span class="token keyword">INT</span><span class="token punctuation">,</span>    c3 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">CHARSET</span><span class="token operator">=</span>ascii ROW_FORMART<span class="token operator">=</span>COMPACT<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> page_demo <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'bbbb'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">300</span><span class="token punctuation">,</span><span class="token string">'cccc'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token string">'dddd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>COMPACT</code>行格式中,<code>记录头信息</code>包含以下内容:</p><table><thead><tr><th>名称</th><th>大小(位)</th><th>意义</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_flag</td><td>1</td><td>标记记录是否被删除</td></tr><tr><td>min_rec_flag</td><td>1</td><td>B+树每层非叶子结点中最小的目录项记录都会添加这个标记</td></tr><tr><td>n_owned</td><td>4</td><td>每页数据都会被分成若干组,每个组都有个组长,组长记录的n_owned值表示该组人员数量</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在页面堆中的相对位置</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型,0(普通记录),1(B+树非叶子节点的目录项记录),2(Infimum记录),3(Supremum记录)</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><p>为了屏蔽干扰,后续示例数据行格式图都只给出<code>记录头信息</code>和<code>数据真实部分</code>,如图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809232737709.png" alt="记录头与真实数据部分"></p><p>向<code>page_demo</code>表插入四条数据之后,<code>User Records</code>部分如图所示: </p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809233733977.png" alt="插入4条示例数据后记录示意图"></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809235722131.png" alt="实际数据在磁盘中的结构"></p><p><font color="red"><strong>从上图可以看出来,记录在数据页中是按照主键大小依次排列紧挨着排列的</strong> </font></p><h3 id="5-3-1-记录头信息各个字段的含义"><a href="#5-3-1-记录头信息各个字段的含义" class="headerlink" title="5.3.1 记录头信息各个字段的含义:"></a>5.3.1 记录头信息各个字段的含义:</h3><h4 id="1-delete-flag"><a href="#1-delete-flag" class="headerlink" title="1. delete_flag:"></a>1. delete_flag:</h4><p><code>delete_flag</code>: 是用于标记该记录是否被删除,占用1位, <code>值为0表示记录没有被删除</code>,值 为1表示记录被删除.</p><p><code>MySQL</code>在删除数据的时候,实际上采用了<code>逻辑删除</code>的思想, 通过标记位标记记录是否被删除,当有新记录要插入进来的时候,复用这些被删除记录占用的空间,而不是将数据从磁盘中删除掉,然后对所有记录按照主键进行重排序.这样做的好处是<font color="#green"><strong>避免了重排序和空间开辟的性能消耗,又不浪费空间</strong>&nbsp;</font>.</p><p>被删除的数据还会通过记录头中的<code>next_record</code>将当前页中被删除的记录形成一个链表.</p><h4 id="2-min-rec-flag"><a href="#2-min-rec-flag" class="headerlink" title="2. min_rec_flag:"></a>2. min_rec_flag:</h4><p><code>min_rec_flag</code>: B+树每层非叶子结点中的最小的目录项记录都会添加这个标记.</p><h4 id="3-o-owned"><a href="#3-o-owned" class="headerlink" title="3. o_owned:"></a>3. o_owned:</h4><p><code>o_owned</code>: <code>Mysql</code>会将数据页中的记录按照一定的规则分成多个小组,每个小组中主键值最大的记录就是组长,只有组长的记录头信息中的<code>o_owned</code>字段记录着这个分组中有多少个成员(包括组长).</p><h4 id="4-heap-no"><a href="#4-heap-no" class="headerlink" title="4. heap_no:"></a>4. heap_no:</h4><p>记录在数据页中真实的情况是按照主键大小紧密无间的排列,<code>MySQL</code>将这种结构称为 <code>heap堆</code>.</p><p><code>heap_no字段</code>: 表示记录在堆中的编号,即堆中第几条记录.</p><p>两个特殊的记录:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809235809341.png" alt="Infimum和Superemum"></p><ul><li><code>Infimum记录</code>: <code>MySQL</code>自动给数据页中插入的<code>Mysql规定的当前页</code>最小的记录. <font color="yellow"><strong>并且<code>MySQL</code><strong>规定</strong> <code>Infimum记录</code>记录头信息中<code>heap_no字段值为0</code>,<code>next_record</code>永远指向用户自己添加的记录中主键最小的那一条记录.</strong> </font></li><li><code>Supremum记录</code>: <code>MySQL</code>自动给数据页中插入的<code>MySQL规定的当前页面</code>最大的记录.<font color="yellow"><strong>并且<code>MySQL</code><strong>规定</strong>,<code>Supremum记录</code>记录头信息中<code>heap_no字段的值为1</code>, 用户自己添加的记录中主键最大的那一条记录的<code>next_record</code>永远指向<code>Supremum记录</code></strong> </font></li></ul><blockquote><ol><li>这两条特殊记录共同组成了数据页中<code>Infimum+Spremium</code>部分</li><li>对于一条完整的记录来说,比较记录的大小就是比较主键的大小. 一条完整的记录,一条完整的记录,一条完整的记录</li></ol></blockquote><p>用户自己插入的记录是普通记录,普通记录根据记录的大小从2开始递增作为其记录头信息<code>heap_no字段</code>的值.</p><p><font color="red">**&nbsp;<code>heap_no字段</code>因为是表示记录在堆中的编号,一旦在分配了之后就不会改变,哪怕那条记录被删除了**&nbsp;</font></p><h4 id="5-record-type"><a href="#5-record-type" class="headerlink" title="5. record_type:"></a>5. record_type:</h4><p><code>record_type</code>: 表示当前记录的类型.<code>MySQL</code>中一共4中类型 — 0表示普通类型,1表示B+树非叶子结点的目录项记录,2表示Infimum记录,3表示Supremum记录.</p><h4 id="6-next-record"><a href="#6-next-record" class="headerlink" title="6. next_record:"></a>6. next_record:</h4><p><code>next_record</code>: 表示当前记录的真实数据到下一条记录的真实数据的距离.</p><p><code>next_record</code>值的符号表示方向,如果值为负数表示下一条记录的真实数据在当前记录真实数据的前面,如果值为整数,表示下一条记录的真实数据在当前记录的真实数据的后面.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210810002933353.png" alt="记录在数据页中形成的单链表"></p><p>为什么<code>next_word</code>表示的是 到下一条记录真实数据的距离,而不是下一条记录开始的位置?</p><p>因为<code>next_record</code>指向这里刚刚好,向前就是记录的头信息,向后就是记录的真实数据,而且行格式中,<code>变长字段列表</code>和<code>null值列表</code>都是按照逆序存放的,这样可以使记录中位置靠前的字段和他们对应的字段长度信息在内存中的距离更近,可能会提高高速缓存的命中率</p><h2 id="5-4-Page-Directory"><a href="#5-4-Page-Directory" class="headerlink" title="5.4 Page Directory:"></a>5.4 Page Directory:</h2><p>由于<code>Mysql</code>中的记录是按照主键值从小到大排列的,通过记录头信息中<code>next_record</code>字段可以定位到下一个记录,从而形成一个单向链表,单向链表在查找的时候效率不高,于是<code>Mysql</code>通过目录的形式快速定位某个区间,然后逐一去排查的方式来快输定位.</p><h3 id="5-4-1-实现过程如下"><a href="#5-4-1-实现过程如下" class="headerlink" title="5.4.1 实现过程如下:"></a>5.4.1 实现过程如下:</h3><ol><li><p>将所有记录(包含: <code>Infimum</code>和<code>Spremum</code>)划分成多个小组.</p></li><li><p>因为每个记录都是按照主键值从小到大依次排列,将小组中最后一条记录选为目录项(即组长),在其记录头信息的<code>o_owned</code>字段中记录该小组有多少条记录</p></li><li><p>将目录项在页面中的地址偏移量(就是该记录的真实数据与页面第0个字节之间的距离),单独提取出来,按在分组的先后顺序从最靠近页尾部的地方开始存放起来.存放目录项地址偏移量的地方被称为<code>槽</code>,是一个2字节大小的空间.</p></li><li><p>这些槽构成页面中的<code>Page Directory</code>部分.</p><blockquote><p>对于小组,<code>mysql</code>规定: </p><ol><li><code>Infimum</code>记录,单独为一个小组,即 <code>Infimum</code>记录所在的小组只能有一条记录</li><li><code>Spremum</code>记录所在的小组记录条数只能在 <code>1~8</code>条之间</li><li>其他小组记录条数只能在<code>4~8</code>条之间</li></ol><p>关于槽:</p><ul><li>槽的顺序: 分组的时候先从主键值小的记录开始向后分,槽表示的记录越小就越靠近<code>File Tailer</code>部分</li><li>槽如何排列的: <code>Page Directory</code>部分实际上就是一个<code>指针数组</code>,数组中的元素连续分布. </li></ul><p>为什么槽只需要两个字节:</p><p>因为页面大小为16KB,范围在<code>0 ~ 16384</code>字节之间,2个字节可以表示的范围在 <code>0 ~ 65535</code>之间,所以两个字节够了.</p></blockquote></li></ol><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210811224713628.png" alt="页目录中的槽指向分组中主键最大的元素"></p><h3 id="5-4-2-分组的过程"><a href="#5-4-2-分组的过程" class="headerlink" title="5.4.2 分组的过程:"></a>5.4.2 分组的过程:</h3><ol><li><p>数据页在还没有插入记录的时候,实际上只有两个分组,一个 <code>Infimum</code>代表的分组和<code>Spremum</code>代表的分组.</p><p>页目录也只有两个槽,分别指向<code>Infimum</code>和<code>Spremum</code>的真实数据开始的位置.</p></li><li><p>之后每插入一个记录都会从页目录中找到槽指向记录的主键值比待插入主键值大但是差值最小的槽.然后将槽指向记录的记录头信息中<code>o_owned</code>字段+1,表示本组新增一条记录,直到该组中记录数等于8个.</p></li><li><p>当小组中记录数目等于8个的时候,再向组内插入记录,该组就会分裂成两个小组,一个组4个一个组5个元素.然后给新增的小组分配一个新的槽位,来记录新增小组中组长真实数据的地址偏移量.</p></li></ol><h3 id="5-4-3-查找演示"><a href="#5-4-3-查找演示" class="headerlink" title="5.4.3 查找演示:"></a>5.4.3 查找演示:</h3><p>示例数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">Insert</span> <span class="token keyword">into</span> page_demo <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'bbbb'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">300</span><span class="token punctuation">,</span><span class="token string">'cccc'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token string">'dddd'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token string">'eeee'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">600</span><span class="token punctuation">,</span><span class="token string">'ffff'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">700</span><span class="token punctuation">,</span><span class="token string">'gggg'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">800</span><span class="token punctuation">,</span><span class="token string">'hhhh'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">900</span><span class="token punctuation">,</span><span class="token string">'iiii'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token string">'jjjj'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">1100</span><span class="token punctuation">,</span><span class="token string">'kkkk'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">1200</span><span class="token punctuation">,</span><span class="token string">'llll'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">1300</span><span class="token punctuation">,</span><span class="token string">'mmmm'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">1400</span><span class="token punctuation">,</span><span class="token string">'nnnn'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">1500</span><span class="token punctuation">,</span><span class="token string">'oooo'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">1600</span><span class="token punctuation">,</span><span class="token string">'pppp'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>假设目前分组如图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210811230743354.png" alt="记录分组示意图"></p><p>现在想要查找主键值为6的元素,因为<code>Page Directory</code>实际上就是个指针数组,并且指向的值还是按照大小逆序的,所以可以使用2分发查找:</p><ol><li>计算中间槽位: (0+４)／2 = 2,槽2指向记录的主键值为8,比6大,所以要查找的6在槽2的前面.调整high=2,low不变</li><li>重新计算中间槽位: (0+2)/2 =1,槽1指向记录的主键值为4,比6小,所以要查找的6在槽1的后面.</li><li>此时high-low=1,表示中间没有槽位了,所以主键为6的记录应该是在槽2对应的小组里面.由于记录在数据页中是按照主键从小到大依次根据<code>next_record</code>形成的一条单向链表,虽然知道槽2对应分组最大的记录但是也无法从其找到需要的记录,所以应该从槽1指向的记录通过<code>next_record</code>开始遍历找到需要的记录.</li></ol><h2 id="5-5-Page-Header"><a href="#5-5-Page-Header" class="headerlink" title="5.5 Page Header:"></a>5.5 Page Header:</h2><p><code>Page Header</code>主要是用来存储数据页中记录的状态信息的,比如: 数据页已经存了多少条记录,<code>Free Space</code>在页中的偏移量,页目录中存储了多少个槽位等.固定<code>56字节</code>.</p><p><strong>Page Header 各部分及作用:</strong></p><table><thead><tr><th>状态名称</th><th>占用空间(字节)</th><th>作用</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2</td><td>页目录中槽的数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2</td><td>当前Free Space开始的地址</td></tr><tr><td>PAGE_N_HEAP</td><td>2</td><td>第一位表示本页记录是否为紧凑型记录,其余位本页堆中记录的数量(包含Infimum,Supremum,被标记为<code>已删除</code>的记录)</td></tr><tr><td>PAGE_FREE</td><td>2</td><td>表示的是 <code>已删除记录</code>形成的单向链表中头结点记录在页面的偏移量.</td></tr><tr><td>PAGE_GARBAGE</td><td>2</td><td><code>已删除记录</code>占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2</td><td>最后插入的记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2</td><td>一个方向连续插入记录的数量</td></tr><tr><td>PAGE_N_RECS</td><td>2</td><td>本页用户记录数量(不含: <code>Infimum</code>,<code>Supremum</code> 以及 <code>已删除记录</code>)</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8</td><td>本页最大的事务id,这个值仅在二级索引页面中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2</td><td>本页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8</td><td>索引ID,表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10</td><td>B+树叶子结点段的头部信息,仅在B+树的根页面中定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10</td><td>B+树非叶子结点段的头部信息,仅在B+树的根页面中定义</td></tr></tbody></table><blockquote><ol><li><code>PAGE_DIRECTION</code>: 待插入记录的主键值比上一条记录的主键值大,则 待插入记录的插入方向就是右边,否则为左边.<code>PAGE_DIRECTION</code>就是记录这个方向</li><li><code>PAGE_N_DIRECTION</code> : 如果连续插入几条记录<code>PAGE_DIRECTION</code>都是一样的,<code>Mysql</code>就会记录沿着同一个方向插入的记录条数.如果如果方向改变<code>PAGE_N_DIRECTION</code>就会被清零重新统计</li></ol></blockquote><h2 id="5-6-File-Header"><a href="#5-6-File-Header" class="headerlink" title="5.6 File Header:"></a>5.6 File Header:</h2><p><code>File Header</code>通用于个类型的页,它描述一些通用于各种页的信息,比如本页编号,上一页,下一页等,固定占用<code>38字节</code></p><p><strong>File Header</strong>各部分及其作用:</p><table><thead><tr><th>状态名称</th><th>占用空间大小(字节)</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4</td><td>本页校验和</td></tr><tr><td>FIL_PAGH_OFFSET</td><td>4</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4</td><td>上一页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4</td><td>下一页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8</td><td>本页被最后修改时对应的LSN(Log Sequence Number,日志序列号)</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2</td><td>本页类型</td></tr><tr><td>FIL_PAGE_FILE_FLSH_LSN</td><td>8</td><td>仅在系统表空间的第一个页中定义,表示文件至少被刷新到了对应的LSN</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li><p><code>FIL_PAGH_OFFSET</code>: 页的唯一标识,<code>MySQL</code>通过页号唯一确定一个页</p></li><li><p><code>FIL_PAGE_NEXT</code>和<code>FIL_PAGE_PREV</code>: 由于一张表可能存储成千上万条数据,所以肯定无法分配连续的空间来存储,那么就需要将一张表的数据页关联起来.<code>MySQL</code>就是通过<code>FIL_PAGE_NEXT</code>和<code>FIL_PAGE_PREV</code>分别指向下一页和上一页,以页为结点形成一个双向链表.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210812001008664.png" alt="数据页之间形成的双向链表"></p></li></ul><p><strong>页的类型:</strong></p><table><thead><tr><th>类型</th><th>16进制</th><th>含义</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>刚分配还未使用</td></tr><tr><td>FIL_PAGE_UNDO_LOG</td><td>0x0002</td><td>undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>存储段的信息</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Change buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Change Buffer的一些属性</td></tr><tr><td>FIL_PAGE_TYPE_SYS</td><td>0x0006</td><td>存储一些系统数据</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务的系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间的头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>存储区的一些属性</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>溢出页</td></tr><tr><td>FIL_PAGE_INDEX</td><td>0x45BF</td><td>索引页(即数据页)</td></tr></tbody></table><h2 id="5-7-File-Trailer"><a href="#5-7-File-Trailer" class="headerlink" title="5.7 File Trailer:"></a>5.7 File Trailer:</h2><p><code>File Trailer</code>: 由于数据操作实际上都是在内存中,操作完成之后需要将结果刷新到磁盘里面去,为了防止数据没有被完全刷新的情况,<code>Mysql</code>通过<code>File Trailer</code>来校验一个数据页是否是完整的.<code>File Trailer</code>通用于所有类型的页,由<code>8字节</code>组成:</p><ul><li><code>前四字节</code>表示页的校验和: 这部分与<code>File Header</code>中的校验和是相对应的. 每当一个页在内存中操作完成,写回磁盘的时候都是先写<code>File Header</code>,在最后校验和也会被写入到<code>File Trailer</code>.如果写回磁盘的过程中,出现了只写了<code>File Header</code>中的校验和,没来得及写<code>FIle Trailer</code>中的校验和,那么就会出现在校验的时候<code>File Header</code>中的校验和是新的,而<code>File Trailer</code>中的校验和是旧的,导致出现问题</li><li><code>后四字节</code>表示页面被修改时对应的LSN的后四字节,正常情况下,<code>File Header</code>的<code>FILE_PAGE_LSN</code>字段的后四字节相同.</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B+树索引</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813231933719.png"></p><p>前面说过,每页都有一个<code>page directory</code>作为页中记录的目录,可以通过二分法快速定位页中某条记录,现在可以快速定位页中的记录了,但是如何定位到页就成了问题,索引就是解决这个问题的</p><h2 id="6-1-没有索引如何查找"><a href="#6-1-没有索引如何查找" class="headerlink" title="6.1 没有索引如何查找"></a>6.1 没有索引如何查找</h2><h3 id="6-1-1-在页中查找"><a href="#6-1-1-在页中查找" class="headerlink" title="6.1.1 在页中查找:"></a>6.1.1 在页中查找:</h3><p>在页中查找一般是分为两种情况:</p><ul><li>以主键为搜索条件: 页目录中的槽快速定位某个主键,然后根据主键去快速定位某条记录</li><li>以其他列作为条件: 对非主键列的查找无法通过页目录中的槽定位主键,只能从<code>Infimum</code>开始一个一个的遍历.</li></ul><p>在很多页中查找:</p><p>在很多页中查找首先需要定位数据在那一页,然后才能在数据页中查找到数据.如果没有引入索引的话,无论是以主键为条件,或者以其他列为条件都无法快速定位数据在那一页,只能从第一页开始沿着双端链表逐一遍历.</p><h2 id="6-2-索引"><a href="#6-2-索引" class="headerlink" title="6.2 索引:"></a>6.2 索引:</h2><h3 id="6-2-1-一个简易的索引方案"><a href="#6-2-1-一个简易的索引方案" class="headerlink" title="6.2.1 一个简易的索引方案:"></a>6.2.1 一个简易的索引方案:</h3><p>为了演示效果,数据示意图将会以下面的形式出现:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813234348296.png"></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813234402899.png"></p><p>示例数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>index_demo<span class="token punctuation">`</span><span class="token punctuation">(</span>c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>    C2 <span class="token keyword">INT</span><span class="token punctuation">,</span>    C3 <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    PRIMERY <span class="token keyword">KEY</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">Insert</span> <span class="token keyword">into</span> <span class="token punctuation">`</span>index_demo<span class="token punctuation">`</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'U'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token string">'D'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Y'</span><span class="token punctuation">)</span><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token punctuation">`</span>index_demo<span class="token punctuation">`</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了演示效果,假设一个数据页中只能存放3条数据,大于3条就要开辟新的页来存放数据. 所以在插入上面三条记录之后,在页面中已经形成一条单向链表,且已经满了在执行第二条插入语句的时候,就会形成下面这种情况:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813234416566.png"></p><blockquote><ol><li>新生成的页号为什么是28? 因为在磁盘中多次申请磁盘空间可能不是连续的,因此页号页可能不是连续的</li><li><code>Mysql</code>规定页号大的数据页中数据主键值要比页号小的数据页中数据主键值大,否则就需要将不满足要求的数据与旧数据页中满足要求的数据进行交换</li></ol></blockquote><p>为了满足页 号大的数据页中数据主键值要比页号小的数据页中数据主键值大,交换的过程如下:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813235037699.png"></p><p>多次向 <code>index_demo</code>表中插入数据之后,如图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813235310187.png"></p><p>由于数据页之间是一个双端链表的结构,想要定位数据页只能逐一遍历,为了提高定位数据的效率,给数据页建立对应的目录,每个目录包含下列两部分:</p><ul><li>页的用户记录中最小的主键值,用 <code>key</code> 来表示;</li><li>页号,用 <code>page_no</code> 表示</li></ul><p>加上目录后如图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813235608778.png"></p><p>为了能够像<code>page directory</code>中访问槽一样的访问, 数据页的目录项, 我们需要将这些目录项在<code>物理存储器</code>上连续存储.这个时候在<code>多页中定位数据的步骤</code>为:</p><ul><li>先从根据二分法快速定位目录项,从而找到记录所在的数据页</li><li>然后去数据页中找数据</li></ul><h3 id="6-2-2-InnoDB中索引方案"><a href="#6-2-2-InnoDB中索引方案" class="headerlink" title="6.2.2 InnoDB中索引方案:"></a>6.2.2 InnoDB中索引方案:</h3><p>上面说到为了快速定位数据页从而给数据页的搞了一个目录项,并且要求目录项在物理存储中是可以连续存放的,但是会出现两个问题:</p><ul><li><code>InnoDB</code>使用页作为管理存储空间的基本单位,即 最多只能保证16KB的连续空间来存放数据. 如果记录数量一旦特别多,所有的目录项连续存储可能会出现问题</li><li>我们可能会经常对数据进行增删改操作,如果某个页面中的数据都删除了,那么该页也没有存在的必要了,就意味着存放目录项的连续空间需要把之后的目录项都向前移动一下.太影响效率</li></ul><p><code>MySQL</code>对于这一问题的解决方案是 复用存储用户记录的数据页来存储目录项,将目录项当成用户记录分页存储(<code>只不过将用户记录换成了只有主键列和页号列的目录项</code>),以保证目录向是连续的,在每一页中同样会按照目录向记录中的主键值进行排列.</p><p>为了区分目录项和用户记录, <code>Mysql</code>将目录项统称为<code>目录项记录</code>,即 在记录头信息中<code>record_type</code>字段的值设置为1.</p><p>将目录项记录存放进数据页中之后,整个结构如图:</p><p> <img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814004524301.png"></p><p><font color="red">目录项记录和用户记录的区别与联系:</font></p><ul><li>区别:<ul><li>目录项记录头的<code>record_type</code>值为1,用户记录记录头的<code>record_type</code>值为0.</li><li>目录记录只有索引列和页编号两列,用户记录可能有多个列(<code>用户自定义列</code>,<code>mysql添加的隐藏列</code>)</li><li>每页目录记录中最小的那一条记录的记录头信息中<code>min_rec_flag</code>字段值为1.用户记录记录头<code>min_rec_flag</code>字段值为0</li></ul></li><li>联系:<ul><li>除了上面几点不同之外,其余的性质并没有区别.使用的是一样的数据页,<code>页面类型都在FILE HEADER中,值为 0x45BF</code>,页的结构也是一样的,主键同样会生成对应的页目录.</li></ul></li></ul><blockquote><p>目录记录的真实数据只会存放两个值, 一个是索引列的值,一个是页码</p></blockquote><p>有了目录项记录的数据页之后,举个查询主键为20的记录的例子,此时查询的过程为:</p><ul><li>在存放<code>目录项记录</code>的数据页中通过<code>页目录</code>定位到具体的目录项记录,然后根据目录项记录中的数据页页码,找到对应存放<code>用户记录</code>的数据页(即9页)</li><li>再到9页中通过<code>页目录</code>定位到主键为20的记录,完成查找.</li></ul><p>一旦目录项多了超出了页面能存放的范围,就会像用户记录一样申请新的数据页来存放目录项,<code>多个存放目录项的数据页的结构如图</code>:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814010439409.png"></p><p>如果存放目录项的数据也变得非常多了,<code>Mysql</code>就会为这些存放目录项的数据页,创建他们对应的目录项,生成一个更高级的目录,以此类推逐渐形成一颗树一样的结构 —- 这就是<code>B+</code>树结构.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814010955356.png"></p><p><strong>B+树,示意图:</strong></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814011024445.png"></p><blockquote><p><code>mysql</code>规定B+树的叶子结点为0层,之后逐渐+1.</p></blockquote><p>假设一个数据页能够存放10条用户记录,所存放目录项记录的数据页能够存放1000条,那么B+树每层存储数据数量为:</p><ul><li>如果B+树只有1层,也就只有1个数据页,那么只能存储100条</li><li>如果B+树有2层,那么记录数为 1000 * 100 = 100,000条</li><li>如果B+树有3层,那么记录数为 1000 * 1000 * 100 = 100,000,000条</li><li>如果B+树有4层,那么记录数为 1000 * 1000 * 1000 * 100 = 100,000,000,000条</li></ul><p>可以发现B+树4层就能够存储很多的数据,<code>mysql</code>在日常使用中B+树的层数是不会超过4层的,也就是只需要去4个数据页(3个目录项数据页,1个用户记录数据页)中就能够找到指定数据(<code>要以主键为条件</code>)</p><h4 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引:"></a>1. 聚簇索引:</h4><p>前面介绍的以主键大小来排序的B+树本身就是一个目录,或者本身就是一个索引,具有以下特点:</p><ul><li>使用记录主键值的大小进行记录和页的排序:<ul><li>数据页中的任何记录都是按照主键值的大小顺序排成一个单向链表,页内记录被分成若干组,每个组里中主键值最大的记录的偏移量当做目录存放页<code>页目录</code>的槽里面</li><li>存放记录的数据页也是按照页中记录的主键大小顺序排成一个双向链表</li><li>存放目录记录的数据页分为不同层级,在同一层级的页也是按照页中目录记录的主键大小排成一个双端链表</li></ul></li><li>B+树的叶子结点存放的是 <code>完整的用户记录</code>(完整的用户记录是指: 这个记录中存储了所有列的值,包括隐藏列).</li></ul><p>具有这两个特点的索引就是<code>聚簇索引</code>,<code>InnoDB</code>默认就是聚簇索引.并且在<code>InnoDB</code>中聚簇索引就是数据的存储方式(<code>所有用户数据存放于叶子结点中</code>), 即<code>索引即数据,数据即索引</code></p><h4 id="2-二级索引"><a href="#2-二级索引" class="headerlink" title="2. 二级索引:"></a>2. 二级索引:</h4><p>当我们不以主键为索引创建出来的索引,具有以下特点:</p><ul><li>以普通列x的大小为记录和页的排序依据:<ul><li>页内记录都是按照x值的大小顺序形成单链表,记录被分成多个小组,将组内x值最大的记录的偏移量存放在<code>页目录</code>中.</li><li>每个数据页都是按照x值的大小顺序形成一个双向链表</li><li>存放目录项的数据页都会按照目录项记录中索引列的值大小顺序形成一个双向链表</li></ul></li><li>B+树的叶子结点存放的并不是完整的用户记录,真实的数据部分只有两个值,一个是索引列的值,一个是主键列的值.</li></ul><p>具有以上特点的索引就是 <code>二级索引</code>. <code>二级索引</code>是一个新的B+树,并不是主键形成的B+树,也就是说每个<code>二级索引</code>都是一颗B+树.</p><p><code>二级索引</code>的查找过程:</p><ol><li><p>根据索引值快速定位到索引值所在的非叶子节点,如果该叶子结点没有满足条件的<code>不完整的用户记录</code>,就会沿着双向链表去下一个叶子结点中找是否有满足索引条件的用户记录</p></li><li><p>在非叶子结点中找到了符合条件的用户记录, 就会根据主键值去主键形成的聚簇索引中查找到<code>完整的用户记录</code></p></li><li><p>如果<code>二级索引</code>没有唯一性的约束,那么在主键聚簇索引中找到了一条<code>完整的记录</code>后还要回到<code>二级索引</code>中沿着叶子结点形成的双向链表中继续寻找下一个满足搜索条件的<code>不完整记录</code>,然后再一次去主键聚簇索引中查找,以此往复.</p><blockquote><p>根据<code>二级索引</code>非叶子节点中<code>不完整的用户记录</code>存储的主键值去主键聚簇索引中查找<code>完整用户记录</code>的过程 称为 <code>回表</code>.</p></blockquote></li></ol><h4 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3. 联合索引:"></a>3. 联合索引:</h4><p><code>联合索引</code>本质上也就是一个<code>二级索引</code></p><p>处理可以使用单列作为索引,还可以使用多个列作为索引,不过他们之间是有排序优先级的,比如(a,b)这样的联合索引,会先以a为标准排序,如果a相同才会以b为标准进行排序.</p><p>以示例数据来讲: 按照(c2,c3)构成的联合索引,如图</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814015627353.png" alt="联合索引示意图"></p><p>说明:</p><ul><li>联合索引的每条目录项的真实数据部分都包含 c2,c3, 页号这三个数据.</li><li>c2先排序,c2相同再比较c3</li><li>联合索引叶子结点中用户记录的真实数据部分包含 c2,c3 ,主键值这三个数据</li><li>联合索引只会建立一个B+树,而不是创建多个B+树</li></ul><h3 id="6-2-3-B-树索引注意事项"><a href="#6-2-3-B-树索引注意事项" class="headerlink" title="6.2.3 B+树索引注意事项:"></a>6.2.3 B+树索引注意事项:</h3><h4 id="1-根页面永远不动"><a href="#1-根页面永远不动" class="headerlink" title="1. 根页面永远不动:"></a>1. 根页面永远不动:</h4><p>B+树的形成过程:</p><ol><li>为每个表创建B+树索引的时候, 最开是都会创建一个根节点页面.最开始没有数据的时候,根节点页面是什么都没有的</li><li>随后插入数据的过程中,先向根页面中插入数据.</li><li>当根页面中的可用空间使用完了,就会将根节点中所有数据复制到新分配的页面a中,然后对这个新页面进行页分裂作用,得到另一个页面b.然后将新插入数据按照主键值插入到页面a或者页面b中.<code>根结点升级为存储目录项的目录页面</code>.</li></ol><blockquote><p>从整个过程来看,根节点变化的只是页面内的数据,根节点在创建之后页码就不会变化.页号会被记录下来,然后当<code>mysql</code>需要使用这个索引的时候,就会查询出对应索引根节点的页号,然后进行操作.</p></blockquote><h4 id="2-非叶子节点中目录项的唯一性"><a href="#2-非叶子节点中目录项的唯一性" class="headerlink" title="2. 非叶子节点中目录项的唯一性:"></a>2. 非叶子节点中目录项的唯一性:</h4><p>前面简单的将<code>二级索引</code>认为是 <code>索引列 + 页号</code>的搭配,但是会出现下面这个问题:</p><p>以示例数据 c2列为索引的时候,会形成下图所示的索引:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814022636149.png" alt="二级索引不唯一会产生的问题"></p><p>当插入新数据 (9,1,c)的时候, 会发现根节点中所有的目录向索引列的值都是一样的,这样就无法定位新插入数据应该插入页4还是页5.</p><p>实际上<code>二级索引</code>的目录项还是会将<code>主键存储下来</code>,用于处理上面这个问题. 即当索引列相同的时候,比较主键从而决定记录的大小.所有的二级索引都是这样的,哪怕是<code>UNIQUE</code>类型的二级索引,也是这样的(因为<code>UNIQUE列可能出现多个null值</code>,或者多条记录键值相同的情况<code>MVCC</code>)</p><h4 id="3-一个页面至少容纳两条数据"><a href="#3-一个页面至少容纳两条数据" class="headerlink" title="3. 一个页面至少容纳两条数据:"></a>3. 一个页面至少容纳两条数据:</h4><p>主要是为了避免B+树层级增长过高.</p><h3 id="6-2-4-MyISAM索引方案简介"><a href="#6-2-4-MyISAM索引方案简介" class="headerlink" title="6.2.4 MyISAM索引方案简介:"></a>6.2.4 MyISAM索引方案简介:</h3><p>MyISAM的索引方案与InnoDB的索引方案,最大的区别就是</p><ul><li>MyISAM中索引和数据分开存储,即 <code>索引是索引,数据是数据</code></li><li>InnoDB中索引和数据是存储在一起的,即 <code>索引即数据,数据即索引</code></li></ul><p>MyISAM索引方案主要包含两部分:</p><ul><li><p>数据文件: 将表中的记录按照记录插入的顺序单独存储在一个文件中, 这个文件就称为<code>数据文件</code>.</p><p>数据文件并不划分如同<code>InnoDB</code>中数据页一样的结构,而是来多少数据就往数据文件中存多少数据.</p><p>MyISAM中数据在数据文件中是不会按照主键大小顺序排列的,而是按照插入的顺序排列.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814112858780.png" alt="MyISAM表中记录排列示意图"></p></li><li><p>索引文件: MyISAM会把索引信息单独存放到一个文件中,这个文件称为<code>索引文件</code>.</p></li><li><p>主键索引: MyISAM会为主键单独创建一个索引,但是主键索引叶子结点中用户记录存放的<code>不再是完整的用户记录</code>,而是主键值与行号</p></li><li><p>非主键索引: MyISAM也可以创建非主键索引,与<code>InnoDB</code>中的二级索引结构差不多.只不过</p><p>在叶子结点中用户记录存放的是 索引列,主键列,记录在数据文件中的行号.</p></li></ul><blockquote><ol><li>叶子结点中记录的是索引列+主键值+被查询数据在数据文件中的行号或者偏移量</li><li>MyISAM的索引全是二级索引包括主键索引, 所以都会去进行一次回表操作,只不过由于索引叶子结点记录的是查询记录在数据文件中的行号,或者是偏移量,所以可以直接定位被查询操作,速度是不需要担心的.</li><li><code>MyISAM</code>中,对于定长记录格式,直接使用行号来标记某条记录在数据文件中的精确位置.对于变长类型记录格式,在叶子结点中使用的是偏移量来精确定位数据文件中的位置.</li></ol></blockquote><h3 id="6-2-5-索引sql"><a href="#6-2-5-索引sql" class="headerlink" title="6.2.5 索引sql:"></a>6.2.5 索引sql:</h3><p>创建索引:</p><ul><li><p>建表的时候同时创建索引:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>表名<span class="token punctuation">`</span><span class="token punctuation">(</span>列<span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token keyword">KEY</span> <span class="token operator">|</span> <span class="token keyword">INDEX</span><span class="token punctuation">)</span> 索引名 <span class="token punctuation">(</span>需要加索引的列<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对已经存在的表,新增索引:</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- alter语句ALTER TABLE 表名 ADD (KEY|INDEX) 索引名 (需要加索引的列)-- create语句CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name    [index_type]    ON tbl_name (key_part,...)    [index_option]    [algorithm_option | lock_option] ...  key_part: 需要加索引的列,可以指定排序规则    col_name [(length)] [ASC | DESC]index_option: {    KEY_BLOCK_SIZE [=] value  | index_type  | WITH PARSER parser_name  | COMMENT 'string'}index_type: 索引类型    USING {BTREE | HASH} algorithm_option:    ALGORITHM [=] {DEFAULT | INPLACE | COPY}lock_option:    LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除索引:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">DROP</span> <span class="token punctuation">(</span><span class="token keyword">KEY</span><span class="token operator">|</span><span class="token keyword">INDEX</span><span class="token punctuation">)</span> 索引名<span class="token number">2</span><span class="token punctuation">)</span> 使用 <span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> 语句语法格式：<span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> <span class="token operator">&lt;</span>索引名<span class="token operator">&gt;</span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span>语法说明如下：<span class="token operator">&lt;</span>索引名<span class="token operator">&gt;</span>：要删除的索引名。<span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span>：指定该索引所在的表名。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修改索引:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 没有直接操作的语法,都是先删除原索引再新增索引</span><span class="token comment">-- 先删除</span><span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token keyword">user</span><span class="token keyword">drop</span> <span class="token keyword">index</span> idx_user_username<span class="token punctuation">;</span><span class="token comment">--再以修改后的内容创建同名索引</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_username <span class="token keyword">ON</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>username<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>索引查看:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> table_name<span class="token punctuation">;</span>纵向查看：<span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> table_name\G<span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">show</span> <span class="token keyword">keys</span> <span class="token keyword">from</span> table_name<span class="token punctuation">;</span>纵向查看：<span class="token keyword">show</span> <span class="token keyword">keys</span> <span class="token keyword">from</span> table_name\G<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7 B+树索引的使用</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-B-树索引示意图的简化"><a href="#7-1-B-树索引示意图的简化" class="headerlink" title="7.1 B+树索引示意图的简化:"></a>7.1 B+树索引示意图的简化:</h2><h3 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据:"></a>示例数据:</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span><span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    key1 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    key2 <span class="token keyword">int</span><span class="token punctuation">,</span>    key3 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    key_part1 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    key_part2 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    key_part3 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 主键索引(聚簇索引)</span>    <span class="token keyword">key</span> idx_key1 <span class="token punctuation">(</span>key1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 二级索引(唯一索引)</span>    <span class="token keyword">unique</span> uk_key2 <span class="token punctuation">(</span>key2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 二级索引</span>    <span class="token keyword">key</span> idx_key3 <span class="token punctuation">(</span>key3<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 二级索引</span>    <span class="token keyword">key</span> idx_key_part <span class="token punctuation">(</span>key_part1<span class="token punctuation">,</span>key_part2<span class="token punctuation">,</span>key_part3<span class="token punctuation">)</span> <span class="token comment">-- 联合索引</span><span class="token punctuation">)</span><span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">charset</span><span class="token operator">=</span>utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第6章画出了详细的B+树索引结构,现在对索引结构进行简化如下图: <font color="red">里面的数据是假设的</font></p><p><strong>主键索引:</strong> 只画出了叶子结点中的记录真实数据部分</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814183104661.png"></p><p><strong>二级索引:</strong></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814183400595.png"></p><h2 id="7-2-索引的代价"><a href="#7-2-索引的代价" class="headerlink" title="7.2 索引的代价:"></a>7.2 索引的代价:</h2><h3 id="7-2-1-空间代价"><a href="#7-2-1-空间代价" class="headerlink" title="7.2.1 空间代价:"></a>7.2.1 空间代价:</h3><p>每一个索引都是一颗B+树,而B+树的结点都是一个最大为16KB的数据页,如果数据量很大的话,那么会使用很多的数据页来存储B+树的结点.占用空间很多</p><h3 id="7-2-2-时间代价"><a href="#7-2-2-时间代价" class="headerlink" title="7.2.2 时间代价:"></a>7.2.2 时间代价:</h3><ul><li><p>排序代价:</p><p>B+树中,每层结点都是按照索引列值的大小顺序排列形成一个双向链表,数据页中的记录同样是按照索引列值的大小顺序形成一个单向链表.</p><p>当我们在执行写操作的时候,必然会对记录造成修改,从而会影响到数据页中记录和数据页之间的顺序,然后存储引擎就需要去做一些额外的<code>页分裂</code>,<code>页回收</code>等操作.</p><p>如果索引创建过多,这样的时间消耗就很大.</p></li><li><p>索引选择时间消耗代价:</p><p>在执行查询操作的时候,首先会生成一个查询计划,而一般情况下,<code>mysql</code>在执行过程中只会使用一个二级索引,在执行<code>sql</code>语句的时候会去计算不同索引执行查询时所需要的时间,最后选取时间最少的索引执行.</p><p>如果索引过多,就会花很多的时间去分析.</p></li></ul><h1 id="7-3-B-树索引的应用"><a href="#7-3-B-树索引的应用" class="headerlink" title="7.3 B+树索引的应用:"></a>7.3 B+树索引的应用:</h1><h3 id="7-3-1-用于查询"><a href="#7-3-1-用于查询" class="headerlink" title="7.3.1 用于查询:"></a>7.3.1 用于查询:</h3><p>如果想要使用某个索引执行查询,但是又无法通过查询条件形成合适的扫描区间来减少需要扫描的记录数量时,则不考虑是使用这个索引来执行查询</p><p><strong>全表扫描:</strong> </p><ul><li><p>对于某个查询来说简单粗暴的方式就是扫描表中的所有的记录,判断每一条记录是否符合搜索.如果符合,就返回结果,不符合就跳过该条记录.</p></li><li><p>对于<code>InnoDB</code>搜索引擎的表来说,全表扫描就是从聚簇索引中叶子结点第一条记录依次遍历下去,直到最后一条记录</p></li></ul><p><strong>区间扫描:</strong></p><ul><li><p>由于B+树叶子结点中的记录是按照索引列值的大小顺序进行排列的,可以利用B+树查找索引列值等于某个值的第一条记录,向前或者向后的某个区间内进行记录扫描,来减少记录扫描的范围.</p></li><li><p>比如:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> id <span class="token operator">&gt;=</span> <span class="token number">2</span> <span class="token operator">and</span> id <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个语句意义是寻找 id 在区间[2,100]的数据, <code>mysql</code>会通过聚簇索引首先定位id = 2 的用户记录,然后沿着叶子结点向后扫描,直到id &gt; 100.</p><p><code>扫描区间</code>: 在这个<code>select</code>语句中[2,100] 就是扫描区间</p><p><code>边界条件</code>: <code>id &gt;= 2 and id &lt;= 100</code>就是形成扫描区间的边界条件</p><p>对于<code>全表扫描</code>来说,这是一个特殊的<code>区间扫描</code>,因为他扫描的区间涵盖了所有的数据,即 <code>(-∞,+∞)</code>.</p></li><li><p>生成扫描区间的<code>sql</code>举例:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1438</span><span class="token punctuation">,</span><span class="token number">6328</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key2 <span class="token operator">&gt;=</span> <span class="token number">38</span> <span class="token operator">and</span> key2 <span class="token operator">&lt;=</span> <span class="token number">79</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个语句<code>where</code>条件后面使用的key2列,之前的示例数据中,又为key2列创建了索引<code>uk_key2</code>,会形成下面这三个区间:</p><ul><li><p>[1438,1438] : 边界条件是 <code>key2 in (1438)</code> , 这种扫描区间中只有一个值的称为 <code>单点扫描区间</code></p></li><li><p>[6382,6382] : 边界条件是 <code>key2 in (6382)</code></p></li><li><p>[38,79] : 边界条件是 <code>key2 &gt;= 38 and key2 &lt;= 79</code> , 这种扫描区间中含有多个值的区间称为 <code>范围扫描区间</code></p></li><li><p>对应到数轴上就是:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814212755388.png"></p></li></ul></li><li><p>无法生成扫描区间<code>sql</code>举例:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">&lt;</span> <span class="token string">'a'</span> <span class="token operator">and</span> key3 <span class="token operator">&gt;</span> <span class="token string">'z'</span> <span class="token operator">and</span> common_field <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>如果使用<code>idx_key1</code>去查询:</p><p>那么扫描区间为 <code>(-∞,'a')</code>,边界条件是 <code>key1 &lt; 'a'</code>,  key3 &gt; ‘z’ and common_field = ‘abc’ 只是普通搜索条件,普通搜索条件在获取到<code>idx_key1</code>的二级索引记录之后,回表查询获取到完整的用户记录后才能判断是否符合普通搜索条件.</p></li><li><p>如果使用<code>idx_key3</code>去查询:</p><p>那么扫描区将为<code>('z',+∞)</code>,边界条件是 <code>key3 &gt; 'z'</code>, 普通条件 key1 &lt; ‘a’ and common_field = ‘abc’. </p></li></ul></li></ul><p><strong>如何产生扫描区间:</strong></p><p>对于B+索引,只要索引列 和 常量 使用 <code>=</code>, <code>&lt;=&gt;</code>,<code>IN</code>, <code>NOT IN</code>, <code>IS NULL</code>, <code>IS NOT NULL</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;&gt;</code>, <code>BETWEEN</code>, <code>LIKE</code>连接起来就能产生扫描区间.</p><p>注意:</p><ul><li><p><code>IN</code> 的语义 和 若干个等值匹配操作之间使用 <code>OR</code> 连接起来是一样的</p></li><li><p><code>!=(&lt;&gt;)</code>产生 的扫描区间比较特殊:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 生成的扫描区间为: (-∞,'a') ∪ ('a',+∞)</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">!=</span> <span class="token string">'a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>LIKE</code>操作只有在完全匹配和前缀匹配才能产生扫描区间</p></li></ul><p><strong>如何从若干个OR或者AND连接的语句之间提取扫描区间:</strong></p><h5 id="1-所有查询条件都可以生成合适的扫描区间"><a href="#1-所有查询条件都可以生成合适的扫描区间" class="headerlink" title="1. 所有查询条件都可以生成合适的扫描区间:"></a>1. 所有查询条件都可以生成合适的扫描区间:</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">and</span> key2 <span class="token operator">&gt;</span> <span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的扫描区间为:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814221320446.png"></p><blockquote><p>and连接的查询条件是对两个扫描区间取交集</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">or</span> key2 <span class="token operator">&gt;</span> <span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的扫描区间为:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814221405324.png"></p><blockquote><p>or连接的查询条件是对两个扫描区间取并集</p></blockquote><h5 id="2-部分查询条件能够生成扫描区间"><a href="#2-部分查询条件能够生成扫描区间" class="headerlink" title="2. 部分查询条件能够生成扫描区间:"></a>2. 部分查询条件能够生成扫描区间:</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">and</span> common_field <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果使用<code>uk_key2</code>索引进行查询:</p><ul><li>查询条件<code>key2 &gt; 100</code>生成的扫描范围是 (100,+∞)</li><li>查询条件<code>common_field = 'abc'</code>由于<code>uk_key2</code>索引中的二级索引记录根本就不按照<code>common_field列</code>进行排列所以这个查询条件根本就不能使扫描范围减小.也就是产生的扫描范围是: <code>(-∞,+∞)</code>.</li><li>最终产生的扫描范围是 (100,+∞)</li></ul><p>如果将sql中<code>and</code>连接换成<code>or</code>连接,产生的扫描范围是 (-∞,+∞)</p><h5 id="3-复杂查询条件中找出扫描范围"><a href="#3-复杂查询条件中找出扫描范围" class="headerlink" title="3. 复杂查询条件中找出扫描范围:"></a>3. 复杂查询条件中找出扫描范围:</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'xyz'</span> <span class="token operator">and</span> key2 <span class="token operator">=</span> <span class="token number">738</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">&lt;</span> <span class="token string">'abc'</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'lmn'</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">like</span> <span class="token string">'%suf'</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'zzz'</span> <span class="token operator">and</span> <span class="token punctuation">(</span>key2 <span class="token operator">&lt;</span> <span class="token number">8000</span> <span class="token operator">or</span> common_field <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>分析思路:</p><ul><li><p>找出where中使用了哪些列,以及表中创建了哪些索引.</p><p>在这个sql中查询条件使用了 key1,key2,common_field列,key1列有<code>idx_key1</code>,key2列有<code>uk_key2</code>.</p></li><li><p>将可能使用到的索引进行假设,分析他们的扫描区间</p></li></ul><p><strong>假设使用<code>idx_key1</code>索引:</strong></p><p>首先分析哪些搜索条件是不能产生扫描范围的:</p><p>比如上面的sql,<code>key2 = 738</code>, <code>key2 &lt; 8000</code>, <code>common_field = 'abc'</code>以及<code>key1 like '%suf'</code>是不能产生扫描范围的,直接将他们替换成<code>true</code>,则sql为:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'xyz'</span> <span class="token operator">and</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">&lt;</span> <span class="token string">'abc'</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'lmn'</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'zzz'</span> <span class="token operator">and</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- 简化:</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'xyz'</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">&lt;</span> <span class="token string">'abc'</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'lmn'</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'zzz'</span><span class="token punctuation">)</span> <span class="token comment">-- key1 &lt; 'abc' and key1 &gt; 'lmn'永远是false</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'xyz'</span><span class="token punctuation">)</span> <span class="token operator">or</span>  <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'zzz'</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为’xyz’ &lt; ‘zzz’ , 又是使用or连接, 取二者之间的并集, 所以产生的扫描范围是: (‘xyz’,+∞)</p><p><strong>假设使用<code>uk_key2</code>索引:</strong></p><p>替换掉不能差生扫描范围的查询条件之后sql为:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">and</span> key2 <span class="token operator">=</span> <span class="token number">738</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">and</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">and</span> <span class="token boolean">true</span> <span class="token operator">and</span> <span class="token punctuation">(</span>key2 <span class="token operator">&lt;</span> <span class="token number">8000</span> <span class="token operator">or</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- key2 &lt; 8000 or true 一定为true</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> key2 <span class="token operator">=</span> <span class="token number">738</span> <span class="token operator">or</span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为查询条件恒成立,那么就是个全表扫描,扫描范围是: (-∞,+∞).但是使用了二级索引,比主键全表扫描还多了一次回表操作,所以显然不适合使用<code>uk_key2</code>作为查询索引</p><h5 id="4-使用联合索引执行查询索引时的扫描范围"><a href="#4-使用联合索引执行查询索引时的扫描范围" class="headerlink" title="4. 使用联合索引执行查询索引时的扫描范围:"></a>4. 使用联合索引执行查询索引时的扫描范围:</h5><p>联合索引的排序规则:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">key</span> idx_key_part <span class="token punctuation">(</span>key_part1<span class="token punctuation">,</span>key_part2<span class="token punctuation">,</span>key_part3<span class="token punctuation">)</span> <span class="token comment">-- 联合索引</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上面这个索引为例:</p><ul><li>先对<code>key_part1</code>列的值进行排序</li><li><code>key_part1</code>相同,再根据<code>key_part2</code>列的值进行排序</li><li><code>key_part1</code>和<code>key_part2</code>列的值都相同的情况下,再使用<code>key_part3</code>列的值进行排序</li></ul><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814233953955.png"></p><p>举例</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用联合索引确定的扫描范围为 <code>['a','a']</code>,扫描边界为<code>key_part = 'a'</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part2 <span class="token operator">=</span> <span class="token string">'b'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用联合索引确定的扫描范围为 <code>[('a','b'),('a','b')]</code>,扫描边界为<code>key_part1 = 'a' and key_part2 = 'b'</code>.</p><p><code>[('a','b'),('a','b')]</code>表示: 在<code>idx_key_part</code>索引中,从第一条满足边界条件,到最后一条满足边界条件为止的所有二级索引记录</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part2 <span class="token operator">=</span> <span class="token string">'b'</span> <span class="token operator">and</span> key_part3 <span class="token operator">=</span> <span class="token string">'c'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 使用联合索引确定的扫描范围为 <code>[('a','b','c'),('a','b','c')]</code>,扫描边界为<code>key_part1 = 'a' and key_part2 = 'b' and key_part3 = 'c'</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">&lt;</span> <span class="token string">'a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 使用联合索引确定的扫描范围为 <code>(-∞,'a')</code>,扫描边界为<code>key_part1 = 'a' and key_part2 = 'b' and key_part3 = 'c'</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part2 <span class="token operator">&gt;</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part2 <span class="token operator">&lt;</span> <span class="token string">'d'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 使用联合索引确定的扫描范围为 <code>(('a','a'),('a','d'))</code>,扫描边界为<code>key_part1 = 'a' and key_part2 &gt; 'a' and key_part2 &lt; 'd'</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part2 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为联合索引排序优先级第一位的并不是<code>key_part2</code>列,所以无法减少扫描范围,因此这条sql不适合使用<code>idx_key_part</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part3 <span class="token operator">=</span> <span class="token string">'c'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条sql能够通过<code>key_part1 = 'a'</code>减少扫描范围,但是由于<code>key_part='a'</code>之后是按照<code>key_part2</code>列的值大小顺序排列的,所以<code>key_part3 = 'c'</code>并不能减少扫描范围.</p><p>所以实际得到的扫描范围是: <code>['a','a']</code>.边界条件是 <code>key_part1 = 'a'</code></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">&lt;</span> <span class="token string">'b'</span> <span class="token operator">and</span> key_part2 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个比较特殊,先看下叶子结点中二级索引的排列, 如果数据为红字的情况就会造成 <code>key_part1 &lt; 3 and key_part2 = 2</code>的查询条件,在使用符合索引的时候,只走key_part1,而不走key_part2,这是因为在<code>key_part1 &lt; 3</code>的前提下二级索引记录根本不是按照<code>key_part2</code>列的值排列的.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210815001847253.png"></p><p>所以实际上对扫描范围起到作用的只有查询条件<code>key_part1 &lt; 'b'</code>.扫描范围为: <code>[-∞,'b')</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">&lt;=</span> <span class="token string">'b'</span> <span class="token operator">and</span> key_part2 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条sql跟上面那条sql基本上是一个意思,但是在<code>key_part1 = 'b'</code>的时候,二级索引是按照<code>key_part2</code>值的顺序进行排列的,但是在<code>key_part1 &lt; 'b'</code>的时候,<code>key_part2</code>仍然是起不到作用的.生成的扫描范围是:</p><ul><li><p><code>[-∞,'b')</code>,边界条件: <code>key_part1 &lt; 'b'</code></p></li><li><p><code>[('b','a'),('b','a')]</code>,边界条件: <code>key_part1 = 'b' and key_part2 = 'a'</code></p></li></ul><p>两个扫描范围求并集: <code>((-∞,-∞),('b','a'))</code></p><h3 id="7-3-2-用于排序"><a href="#7-3-2-用于排序" class="headerlink" title="7.3.2 用于排序:"></a>7.3.2 用于排序:</h3><p>由于查询出来的数据不一定是按照我们需要的顺序进行排序的,就需要对数据进行重新排序,<code>mysql</code>中通常是将记录加载到内存中,通过排序算法进行排序操作,如果记录太多甚至还会借助磁盘空间来存放排序结果,在排序操作完成后再把排好序的结果返回给客户端.</p><p><code>文件排序(filesort)</code>: 在内存或者磁盘中进行排序的方式统称为文件排序.文件排序会影响查询速度.</p><blockquote><p> 如果<code>order by</code>后面的字段加上了索引,就可以避免<code>filesort</code></p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">order</span> <span class="token keyword">by</span> key_part1<span class="token punctuation">,</span>key_part2<span class="token punctuation">,</span>key_part3 <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于二级索引中索引记录本身就是按照索引列进行排列的,也就是说数据本身就是按照<code>order by</code>后面的顺序排列的自然无序再次进行额外的排序.</p><h4 id="1-使用索引进行排序时的注意事项"><a href="#1-使用索引进行排序时的注意事项" class="headerlink" title="1. 使用索引进行排序时的注意事项:"></a>1. 使用索引进行排序时的注意事项:</h4><ul><li><p>如果要想使用联合索引优化排序过程,那么必须要将<code>order by</code>后面排序列的顺序按照联合索引声明的顺序.</p></li><li><p>使用联合索引进行排序的时候,可以使用部分联合索引进行排序,比如: (part1,part2,part3),只使用<code>part1</code>,或者<code>part1,part2</code>进行排序,用来排序的列一定要是从左边开始连续的</p></li><li><p>如果使用联合索引进行排序时,查询条件是联合索引从左开始并且连续的常量,那么就可以使用剩下的索引进行排序,比如:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part <span class="token operator">=</span> <span class="token string">'b'</span> <span class="token keyword">order</span> <span class="token keyword">by</span> key_part3 <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询结果已经按照<code>key_part1</code>,<code>key_part2</code>的顺序排列好了,按照联合索引的排列规则,数据实际上已经按照<code>key_part3</code>排列好了,使用<code>order by key_part3</code>进行排序自然不需要额外的排序.</p></li></ul><h4 id="2-无法使用索引进行排序的情况"><a href="#2-无法使用索引进行排序的情况" class="headerlink" title="2. 无法使用索引进行排序的情况:"></a>2. 无法使用索引进行排序的情况:</h4><ol><li><p>排序规则(ASC,DESC)混用:</p><p>使用联合索引进行排序,要求各排序列的排序规则是一致的,即 <code>要么都是ASC,或者要么都是DESC</code>.</p></li><li><p>排序列包不是同一个索引:</p></li><li><p>排序列在同一个索引中,但是不是按照声明的顺序连续出现:</p></li><li><p>用来形成扫描区间的索引列和排序列不同:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">order</span> <span class="token keyword">by</span> key2 <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>排序列不是以单独列名的形式出现在order by 语句中:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">order</span> <span class="token keyword">by</span> UPPER<span class="token punctuation">(</span>key1<span class="token punctuation">)</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结:"></a>3. 总结:</h4><p>将索引用于排序,主要是利用索引中的数据都是按照索引列值顺序排列好了的,不需要在进行额外的排序,这一特点.</p><h3 id="7-3-3-索引用于分组"><a href="#7-3-3-索引用于分组" class="headerlink" title="7.3.3 索引用于分组:"></a>7.3.3 索引用于分组:</h3><p>规则与用于排序差不多,分组列必须与索引列的顺序一致,也只能使用索引列中左边连续的列进行分组.</p><h2 id="7-4-回表的代价"><a href="#7-4-回表的代价" class="headerlink" title="7.4 回表的代价:"></a>7.4 回表的代价:</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">&gt;</span> <span class="token string">'a'</span> <span class="token operator">and</span> key1 <span class="token operator">&lt;</span> <span class="token string">'c'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>全表扫描:</p><p>扫描全部的聚簇索引,然后逐一对聚簇索引记录进行条件判断,不满足就跳过,满足就返回给客户端</p></li><li><p>使用<code>idx_key1</code>索引进行查询:</p><p>在使用<code>idx_key1</code>索引进行查询时 将数据扫描的范围缩小到了(‘a’,’c’)之间, 但是由于查询的是用户记录所有的列,而二级索引记录中只存放了索引列和主键值,所以必须要根据主键值进行重新去聚簇索引中查询(回表).</p><p><code>Mysql</code>中使用页作为空间管理的基本单位,对于<code>InnoDB</code>引擎的表,索引中的数据页必须是存放在磁盘中的,在需要的时候通过页号对应数据页在磁盘中的偏移量加载到内存中来.<code>Mysql</code>会尽量保证数据页是按照页号顺序进行排列的,因此一次磁盘I/O就可以加载很多的二级索引记录到内存中,扫描二级索引记录的代价就不会太大.</p><p>但是在执行回表操作的时候,二级索引记录中存储的主键值是丝毫没有顺序的,极端的情况下,扫描区间中的二级索引记录有n条,主键值存在对应的数据页就有n页,因此可能要执行n次磁盘i/0.磁盘i/o的时间消耗是特别大的</p><p><code>mysql</code>在执行查询的时候,首先会进行查询语句的优化,查询优化器会对表中的记录事先进行一些计算,通过计算出来的统计数据,或者访问少量的记录来获得查询时的回表数量,如果回表数量特别多,就选择<code>全表扫描</code>,否则选择索引.</p><blockquote><p>为了避免全表扫描:</p><ol><li>通过<code>limit</code>减少返回的数量,从而减少回表次数,让查询走索引</li><li>通过<code>limit</code>减少返回的数量,也可以让排序使用索引</li></ol></blockquote></li></ul><h2 id="7-5-更好的创建和使用索引"><a href="#7-5-更好的创建和使用索引" class="headerlink" title="7.5 更好的创建和使用索引:"></a>7.5 更好的创建和使用索引:</h2><h3 id="7-5-1-只为查询-排序-分组列创建索引"><a href="#7-5-1-只为查询-排序-分组列创建索引" class="headerlink" title="7.5.1 只为查询,排序,分组列创建索引:"></a>7.5.1 只为查询,排序,分组列创建索引:</h3><p>通常只会为<code>where</code>字句中的列,连接字句中的连接列,分组列或者排序列创建索引.</p><p>只出现在查询列表中的列就没有必要创建索引了,比如: </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> common_field<span class="token punctuation">,</span> key_part4 <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个sql中<code>common_field</code>,<code>key_part4</code>就没有必要创建索引了.</p><h3 id="7-5-2-考虑索引列值不重复的数量"><a href="#7-5-2-考虑索引列值不重复的数量" class="headerlink" title="7.5.2 考虑索引列值不重复的数量:"></a>7.5.2 考虑索引列值不重复的数量:</h3><p>如果索引列重复值太多,那么在通过该索引进行查询的时候,一个常量查询条件都有可能有很多条,这样会造成大量的回表操作,从而导致效率不如全表扫描.</p><p>如果想要加索引的列,值重复数率太高就不要给他加索引了.</p><h3 id="7-5-3-索引列尽量选择占用空间小的类型"><a href="#7-5-3-索引列尽量选择占用空间小的类型" class="headerlink" title="7.5.3 索引列尽量选择占用空间小的类型:"></a>7.5.3 索引列尽量选择占用空间小的类型:</h3><p><code>mysql</code>都是以页为单位进行磁盘I/O加载数据的,如果数据类型占用的空间越小,一页中存放的记录数就越多.<code>在取值范围允许的情况下</code>,索引列尽量选择占用空间小的类型</p><p><font color="red">尤其是主键列,主键列不仅仅是聚簇索引中会记录主键值,所有的二级索引记录都会保存主键值,因此主键列更应该选择占用空间小的类型</font></p><h3 id="7-5-4-为列前缀建立索引"><a href="#7-5-4-为列前缀建立索引" class="headerlink" title="7.5.4 为列前缀建立索引:"></a>7.5.4 为列前缀建立索引:</h3><p>处于减少二级索引记录中存放索引值长度,从而增加数据页中存放索引的数量,减少磁盘I/O的目的,可以列值前缀建立索引.</p><p>比如:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 先删除在重新创建索引</span><span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">drop</span> <span class="token keyword">index</span> idx_key1<span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">add</span> <span class="token keyword">index</span> idx_key1<span class="token punctuation">(</span>key1<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>因为索引列值的字符串前缀实际上也是排好序的,所以可以在二级索引记录中只保留字符串前面几个字符.根据字符串前缀定位出二级索引记录中以索引值为前缀的记录,然后在判断他是否完整的匹配查询条件.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">=</span> <span class="token string">'abcdefghijklmn'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先会定位出以<code>abcdefghij</code>为前缀的二级索引记录,然后判断他们是否完全匹配<code>abcdefghijklmn</code></p><p><font color="red">这种索引无法用于排序.排序对于字符串比较的是整个字符串的全部字符,但是这种二级索引只是按照字符串的前面几个字符排好顺序</font></p><h3 id="7-5-5-覆盖索引"><a href="#7-5-5-覆盖索引" class="headerlink" title="7.5.5 覆盖索引:"></a>7.5.5 覆盖索引:</h3><p><code>覆盖索引</code>: 查询列表中的列包含在索引中,就称这种查询方式为 覆盖索引.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> key1<span class="token punctuation">,</span>id <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">=</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过<code>idx_key1</code>进行查询的时候,二级索引记录中包含了 <code>key1</code>,<code>id</code>这两列的值,所以在定位到叶子结点中的二级索引记录时就获取到了查询结果,无需进行回表操作.</p><h3 id="7-5-6-索引列名单独出现在查询条件中"><a href="#7-5-6-索引列名单独出现在查询条件中" class="headerlink" title="7.5.6 索引列名单独出现在查询条件中:"></a>7.5.6 索引列名单独出现在查询条件中:</h3><p>单独出现的意思是: 不要让索引列在查询条件中参与运算</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 不走索引:</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token comment">-- 走索引:</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token operator">/</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>sql 1 会被<code>mysql</code>认为 key2*2 是一个列,从而不会走<code>idx_key2</code></p><h3 id="7-5-7-新插入记录时主键大小对效率的影响"><a href="#7-5-7-新插入记录时主键大小对效率的影响" class="headerlink" title="7.5.7 新插入记录时主键大小对效率的影响:"></a>7.5.7 新插入记录时主键大小对效率的影响:</h3><p>主键值大小(新插入数据的主键值)对插入效率的影响,主要问题出现在无序插入,如果插入时刚好要插入的数据页满了,待插入记录的主键值又恰好位于该数据页的中间,就会造成页分裂,从而导致插入效率降低.</p><h3 id="7-5-8-冗余和重复索引"><a href="#7-5-8-冗余和重复索引" class="headerlink" title="7.5.8 冗余和重复索引:"></a>7.5.8 冗余和重复索引:</h3><p>尽量避免冗余和重复的索引,比如不要对联合索引包含的索引再创建单独的索引</p>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8 MySQL数据目录</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/8_MySQL%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/8_MySQL%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="8-1-数据库和文件系统的关系"><a href="#8-1-数据库和文件系统的关系" class="headerlink" title="8.1 数据库和文件系统的关系:"></a>8.1 数据库和文件系统的关系:</h2><p><code>Mysql</code>中像<code>InnoDB</code>和<code>MyISAM</code>这类存储引擎都是将数据存储在磁盘中,操作系统通过文件系统来管理磁盘,换句话说: 数据是存储在文件系统中的.</p><p>读数据是从文件系统中将数据读取到内存中,写数据是从内存中将数据写入到文件系统.</p><h2 id="8-2-Mysql的数据目录"><a href="#8-2-Mysql的数据目录" class="headerlink" title="8.2 Mysql的数据目录:"></a>8.2 Mysql的数据目录:</h2><p>Mysql服务器在启动的时候会从文件系统中的某个目录下加载一些数据,之后在运行过程中产生的数据也会存储到这个目录下的某些文件中.这个目录就是<code>数据目录</code>.</p><h3 id="8-2-1-数据目录和安装目录的区别"><a href="#8-2-1-数据目录和安装目录的区别" class="headerlink" title="8.2.1 数据目录和安装目录的区别:"></a>8.2.1 数据目录和安装目录的区别:</h3><p><code>安装目录</code>: 安装目录是mysql程序运行文件存放的地方</p><p><code>数据目录</code>: 数据目录是mysql程序在运行过程中产生的一些 <code>用户数据</code>,<code>程序运行状态数据</code>等数据存储的地方</p><h3 id="8-2-2-数据目录在哪儿"><a href="#8-2-2-数据目录在哪儿" class="headerlink" title="8.2.2 数据目录在哪儿:"></a>8.2.2 数据目录在哪儿:</h3><p><code>show variables like 'datadir'</code></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/8_MySQL%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/image-20210829003423480.png" alt="查看Mysql数据目录"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
