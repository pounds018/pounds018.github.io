<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>sout<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"辣鸡"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> test<span class="token punctuation">:</span>    lallala<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token comment">// 事务操作示例</span><span class="token keyword">func</span> <span class="token function">transactionDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>tx<span class="token punctuation">,</span> err <span class="token operator">:=</span> sqlxDB<span class="token punctuation">.</span><span class="token function">Begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 开启事务</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span><span class="token keyword">if</span> tx <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"begin trans failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>sqlStr1 <span class="token operator">:=</span> <span class="token string">"Update t_go_study_user set name = '张三' where id=?"</span>ret1<span class="token punctuation">,</span> err <span class="token operator">:=</span> tx<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>sqlStr1<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"exec sql1 failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>affRow1<span class="token punctuation">,</span> err <span class="token operator">:=</span> ret1<span class="token punctuation">.</span><span class="token function">RowsAffected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"exec ret1.RowsAffected() failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>sqlStr2 <span class="token operator">:=</span> <span class="token string">"Update t_go_study_user set name = '张三' where id=?"</span>ret2<span class="token punctuation">,</span> err <span class="token operator">:=</span> tx<span class="token punctuation">.</span><span class="token function">Exec</span><span class="token punctuation">(</span>sqlStr2<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"exec sql2 failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>affRow2<span class="token punctuation">,</span> err <span class="token operator">:=</span> ret2<span class="token punctuation">.</span><span class="token function">RowsAffected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 回滚</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"exec ret1.RowsAffected() failed, err:%v\n"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token keyword">return</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>affRow1<span class="token punctuation">,</span> affRow2<span class="token punctuation">)</span><span class="token keyword">if</span> affRow1 <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> affRow2 <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"事务提交啦..."</span><span class="token punctuation">)</span>tx<span class="token punctuation">.</span><span class="token function">Commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 提交事务</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>tx<span class="token punctuation">.</span><span class="token function">Rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"事务回滚啦..."</span><span class="token punctuation">)</span><span class="token punctuation">}</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"exec trans success!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><div class="uk-alert uk-alert-danger"><i class="fas fa-exclamation-triangle"></i> 紅色</div><div class="uk-alert uk-alert-success"><i class="fa fa-check-circle"></i> 綠色</div><div class="uk-alert uk-alert-warning"><i class="fa fa-exclamation-circle"></i> 黃色</div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1 初识MySQL</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-MySQL的C-S架构"><a href="#1-1-MySQL的C-S架构" class="headerlink" title="1.1 MySQL的C/S架构:"></a>1.1 MySQL的C/S架构:</h2><p>MySQL是典型的C/S架构, 由 <code>客户端程序Client</code> 和 <code>服务端程序server</code>两部分组成.</p><p>MySQL的大致运行过程为: 服务端程序直接与要存储的数据打交道,多个客户端程序可以连接到这个服务器程序,向服务器程序发送 CRUD请求,然后服务端程序根据这些请求进行相应的处理,最后将结果响应给客户端.</p><h2 id="1-2-MySQL的安装"><a href="#1-2-MySQL的安装" class="headerlink" title="1.2 MySQL的安装:"></a>1.2 MySQL的安装:</h2><p>[参考链接](zip包安装mysql： <a href="https://www.cnblogs.com/qixing/p/12271499.html">https://www.cnblogs.com/qixing/p/12271499.html</a>)</p><p><strong>注意事项</strong></p><p>配置文件中一些重要文件的路径要写对, <font color="red">都需要根据自己具体的文件所在路径来写</font>,比如: </p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">[</span>mysqld<span class="token punctuation">]</span><span class="token comment"># binlog 配置</span>log<span class="token punctuation">-</span>bin=/usr/local/mysql/logs/mysql<span class="token punctuation">-</span>bin.logexpire<span class="token punctuation">-</span>logs<span class="token punctuation">-</span>days=14max<span class="token punctuation">-</span>binlog<span class="token punctuation">-</span>size=500Mserver<span class="token punctuation">-</span>id=1<span class="token comment"># GENERAL</span>basedir=/usr/local/mysqldatadir=/usr/local/mysql/datasocket=/usr/local/mysql/mysql.sockuser=mysqldefault<span class="token punctuation">-</span>storage<span class="token punctuation">-</span>engine=InnoDBcharacter<span class="token punctuation">-</span>set<span class="token punctuation">-</span>server=utf8lower_case_table_names = 1explicit_defaults_for_timestamp=true<span class="token punctuation">[</span>mysqld_safe<span class="token punctuation">]</span>log<span class="token punctuation">-</span>error=/usr/local/mysql/mysql<span class="token punctuation">-</span>error.logpid<span class="token punctuation">-</span>file=/usr/local/mysql/mysqld.pid<span class="token punctuation">[</span>client<span class="token punctuation">]</span>socket=/usr/local/mysql/mysql.sock<span class="token punctuation">[</span>mysql<span class="token punctuation">]</span>default<span class="token punctuation">-</span>character<span class="token punctuation">-</span>set=utf8socket=/usr/local/mysql/mysql.sock<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>mysql</code>通过zip包安装之后,文件目录为:  学习的时候<code>mysql</code>程序是安装在<code>/usr/local/mysql</code>目录下面的</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/image-20210805221313354.png"></p><h3 id="1-2-1-bin目录下的可执行文件"><a href="#1-2-1-bin目录下的可执行文件" class="headerlink" title="1.2.1 bin目录下的可执行文件"></a>1.2.1 bin目录下的可执行文件</h3><p><code>bin</code>目录下面放了很多的<code>mysql</code>程序的可执行文件,大致如下:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/image-20210805221420290.png"></p><p>启动<code>mysql</code>: 通常是通过 上面列举的可执行文件的<code>相对</code>/<code>绝对</code>路径来启动<code>mysql</code>.比如: <code>/usr/local/mysql/bin/mysqld</code>,但是为了在任何地方都可以直接使用<code>mysql</code>的可执行文件, 会将<code>mysql</code>的<code>bin</code>目录加入到环境变量文件中去.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/image-20210805221952074.png"></p><h2 id="1-3-启动mysql服务端程序"><a href="#1-3-启动mysql服务端程序" class="headerlink" title="1.3 启动mysql服务端程序:"></a>1.3 启动<code>mysql</code>服务端程序:</h2><h3 id="1-3-1-mysqld"><a href="#1-3-1-mysqld" class="headerlink" title="1.3.1 mysqld:"></a>1.3.1 <code>mysqld</code>:</h3><p><code>mysqld</code>可执行文件就表示一个<code>mysql</code>服务器程序,运行<code>mysqld</code>就可以启动一个<code>mysql</code>进程. <strong>但是这个可执行文件不常用</strong></p><h3 id="1-3-2-mysqld-safe"><a href="#1-3-2-mysqld-safe" class="headerlink" title="1.3.2 mysqld_safe:"></a>1.3.2 <code>mysqld_safe</code>:</h3><p><code>mysqld_safe</code>是一个启动脚本, 在脚本中会去调用<code>mysqld</code>可执行文件来启动一个 <code>mysql</code>进程, 然后持续监控服务器的运行状态, <strong>当服务器出现错误的时候可以帮助重启服务器程序</strong>. 程序运行期间的<code>错误日志</code>或者其他<code>诊断日志</code>被存放在数据目录(我的路径为: <code>/usr/local/mysql/data</code>)中一个<code>.err</code>后缀的文件里面.</p><h3 id="1-3-3-mysql-server"><a href="#1-3-3-mysql-server" class="headerlink" title="1.3.3 mysql.server:"></a>1.3.3 <code>mysql.server</code>:</h3><p><code>mysql.server</code>也是启动脚本, 它会简介的调用<code>mysald_safe</code>. </p><p><code>mysql.server</code>实际上是一个链接文件,指向的是 <code>/usr/local/mysql/support-files/mysql.server</code></p><p><code>mysql.server</code>启动<code>mysql</code>程序:  <code>mysql.server start</code></p><p><code>mysql.server</code>停止<code>mysql</code>程序:  <code>mysql.server stop</code></p><h3 id="1-3-4-mysqld-multi"><a href="#1-3-4-mysqld-multi" class="headerlink" title="1.3.4 mysqld_multi:"></a>1.3.4 <code>mysqld_multi</code>:</h3><p><code>mysqld_multi</code>: 使用来启动多个<code>mysql</code>服务器程序的,也可以报告服务器程序的运行状态,本质上还是是一个 <code>shell</code>脚本.</p><h2 id="1-4-启动mysql客户端程序"><a href="#1-4-启动mysql客户端程序" class="headerlink" title="1.4 启动mysql客户端程序:"></a>1.4 启动<code>mysql</code>客户端程序:</h2><p><code>bin</code>目录下面有许多的客户端程序,如: <code>mysqladmin</code>,<code>mysqldump</code>,<code>mysqlcheck</code>等等.重点关注名字为 <code>mysql</code> 的可执行文件.</p><p>通过<code>mysql</code>可执行文件常用格式:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql -h主机ip -P端口号 -D数据库名 -u用户名 -p密码<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>-h</th><th align="left">表示<code>mysql</code>服务器程序所在的主机i地址,本地连接可以省略这个参数</th></tr></thead><tbody><tr><td>-P</td><td align="left">表示<code>mysql</code>服务器程序所使用的端口号</td></tr><tr><td>-D</td><td align="left">表示要连接<code>mysql</code>服务器程序中的哪一个数据库</td></tr><tr><td>-u</td><td align="left">使用哪一个用户来链接<code>mysql</code>服务器程序</td></tr><tr><td>-p</td><td align="left">密码</td></tr></tbody></table><p>链接成功后如图:  本地连接省略了部分参数</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/image-20210805224537807.png"></p><p>退出<code>mysql</code>客户端程序: <code>quit</code>,<code>exit</code>,<code>\q</code>等命令都可以退出</p><h3 id="1-4-1-连接注意事项"><a href="#1-4-1-连接注意事项" class="headerlink" title="1.4.1 连接注意事项:"></a>1.4.1 连接注意事项:</h3><ol><li><code>不要显示通过mysql -pxxxx去连接服务器</code>: 通过<code>history</code>,<code>ps</code>之类的命令可以看到</li><li><code>一定要显示连接的话,-p和密码之间不能有空格</code>: <code>-p</code>之后的任何字符都会被认为是密码的一部分,如果密码含有特殊字符还需要转义</li><li><code>参数之间没有顺序要求</code>.</li><li><code>unix系统中,如果不指定-u参数,会使用系统当前用户作为mysql用户去连接服务器,win系统默认是ODBC</code>.</li></ol><h2 id="1-5-客户端与服务端的连接过程"><a href="#1-5-客户端与服务端的连接过程" class="headerlink" title="1.5 客户端与服务端的连接过程:"></a>1.5 客户端与服务端的连接过程:</h2><h3 id="1-5-1-TCP-IP"><a href="#1-5-1-TCP-IP" class="headerlink" title="1.5.1 TCP/IP:"></a>1.5.1 TCP/IP:</h3><p><code>mysql</code>程序是一个<code>c/s</code>架构的程序,底层是依靠<code>tcp/ip</code>网络通信协议来实现<code>c/s</code>之间的通信.<code>tcp/ip</code>协议是通过 <code>ip+端口号</code>来确定一个应用层程序的.而服务端程序则会持续监听<code>默认端口号</code>或者<code>启动时指定的其他端口号</code></p><p><code>mysql</code>服务端程序默认的端口号是: <code>3306</code>.也可以通过 <code>mysqld -P端口号</code>在服务器程序启动的时候使用其他端口作为服务器程序监听的端口号.</p><h3 id="1-5-2-命名管道和共享内存"><a href="#1-5-2-命名管道和共享内存" class="headerlink" title="1.5.2 命名管道和共享内存:"></a>1.5.2 命名管道和共享内存:</h3><p>win系统上可以给客户端程序和服务器程序之间使用<code>命名管道</code>或<code>共享内存</code>进行通信,不过启动时需要添加一些参数:</p><ol><li>使用<code>命名管道</code>进行进程之间通信:<ul><li> 启动服务器程序的时候,需要加上<code>--enable-named-pipe</code>参数</li><li> 启动客户端程序的时候,需要加上 <code>--pipe</code>或者 <code>--prototype=pipe</code></li></ul></li><li>使用<code>共享内存</code>进行进程之间通信:<ul><li>启动服务器,加上<code>--shared-memory</code></li><li>服务器启动之后共享内存就是本地客户端程序默认的链接方式,也可以在启动客户端,加上<code>--protocol=memory</code>来链接</li></ul></li></ol><h3 id="1-5-3-UNIX域套接字"><a href="#1-5-3-UNIX域套接字" class="headerlink" title="1.5.3 UNIX域套接字:"></a>1.5.3 UNIX域套接字:</h3><p>当服务器和客户端都是运行在<code>UNIX系统</code>上的时候,可以使用<code>UNIX域套接字</code>进行进程之间通信</p><p>开启方法: </p><ul><li><p>服务器默认开启: 启动客户端程序的时候 <code>不指定-h参数</code>、<code>-h参数为localhost</code> 或者 <code>指定--protocol=socket</code>都可以开启<code>UNIX域套接字</code>进行进程之间通信.</p></li><li><p>客户端显示开启: <code>mysql -hlocalhost -uroot --socket=文件路径</code></p></li></ul><p>默认的<code>UNIX域套接字文件</code>为 <code>/tmp/mysql.sock</code>,可以通过 <code>mysqld --socket=文件路径</code>修改.</p><h2 id="1-6-服务端程序处理客户端请求"><a href="#1-6-服务端程序处理客户端请求" class="headerlink" title="1.6 服务端程序处理客户端请求:"></a>1.6 服务端程序处理客户端请求:</h2><p>无论客户端进程和服务端进程采用什么方式通信,最后客户端程序的请求都会转换成一段文本(<code>MYSQL语句</code>),服务器进程处理后再向客户端进程响应一段文本<code>处理结果</code></p><p>整个处理过程大致如下: </p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/image-20210805231436699.png"></p><h3 id="1-6-1-处理连接"><a href="#1-6-1-处理连接" class="headerlink" title="1.6.1 处理连接:"></a>1.6.1 处理连接:</h3><p><code>mysql</code>对于处理客户端请求的线程采用了<code>池化</code>思想来管理.每当有客户端请求过来,服务器进程都会创建一个线程专门与这个客户端进行交互; 当客户端与服务器断开连接的时候,线程不会被销毁,而是被集中缓存起来,待后续连接过来继续使用.</p><p>客户端发送给服务端的连接,会携带<code>主机信息</code>,<code>用户名</code>,<code>密码</code>等信息,服务端会对这些信息进行校验,通过的连接服务端才会创建线程与其建立连接.</p><h3 id="1-6-2-解析与优化"><a href="#1-6-2-解析与优化" class="headerlink" title="1.6.2 解析与优化:"></a>1.6.2 解析与优化:</h3><p>连接建立之后,服务端已经获取到了客户端的文本请求,然后开始对文本请求进行处理,比较重要的部分是: <code>查询缓存</code>,<code>语法解析</code>,<code>查询优化</code></p><ol><li>查询缓存: <code>MYSQL</code>服务器会对之前已经处理过的文本请求 和 请求结果进行缓存,如果当前查询是已经处理过的,直接将对应的结果返回给客户端;如果没有处理过就会进行下一步处理.<ul><li>缓存不命中的原因:<ul><li>如果两个查询请求有<code>任何字符上的不同</code>(如: 空格、注释、大小写),都会造成缓存不命中</li><li>如果查询请求中包含某些系统函数,用户自定义变量和函数、系统表,如: <code>mysql</code>、<code>information_schema</code>等</li><li><code>mysql</code>的缓存系统会监测涉及的每张表,只要该表的<code>结构</code>或者<code>数据</code>被修改,那么 与该表关联的所有查询缓存都会被删除</li></ul></li><li>查询缓存的缺点: 查询缓存可以提高查询效率,但是也会存在对缓存数据进行维护的开销<ul><li>每次都要去查询缓存中检索</li><li>查询请求处理完之后要更新缓存数据</li><li>维护该查询缓存对应的内存区域等</li></ul></li></ul></li><li>语法解析: 如果没有命中缓存,就会进行真正的查询处理.<code>MYSQL</code>会对查询请求文本进行解析,判断语法是否正确,然后从文本中将要查询的表、和查询条件提取出来,存放在<code>MYSQL</code>服务器内部使用的结构上</li><li>查询优化: 在语法解析之后,<code>MYSQL</code>会对查询语句进行优化.优化后的结果就是生成一个执行计划.</li></ol><h3 id="1-6-3-存储引擎"><a href="#1-6-3-存储引擎" class="headerlink" title="1.6.3 存储引擎:"></a>1.6.3 存储引擎:</h3><p><code>查询优化</code>之后还没有去访问表中的数据.<code>MYSQL</code>服务器将数据的<code>存储</code>和<code>提取</code>操作都封装到了一个名为 <code>存储引擎</code>的模块里面.</p><p><code>存储引擎</code>主要还是负责 <code>物理上如何表示数据记录</code>、<code>如何从逻辑上的表中读取数据</code>、<code>怎么把数据写入到具体的物理存储器上</code>等</p><p>为了方便管理, <code>MYSQL</code>处理请求的过程大致被分为了两部分: <code>server层</code>(连接管理,查询缓存,语法解析,查询缓存),<code>存储引擎层(存取真实数据的功能)</code>.所以在<code>server层</code>堆语法进行优化完毕之后,只需要按照<code>执行计划</code>去调用底层存储引擎提供的接口获取到数据后返回给客户端.通常是以一条<code>记录</code>为单位.</p><p>以<code>SELECT</code>为例: <code>server层</code>按照执行计划向<code>存储引擎层</code>获取一条<code>记录</code>然后判断是否符合<code>where</code>条件,如果符合就返回给客户端(存入一个缓冲区,缓冲区满了一起flush出去),不符合就跳过该数据,然后向<code>存储引擎层</code>获取下一条数据,以此往复.</p><h2 id="1-7-常用的存储引擎"><a href="#1-7-常用的存储引擎" class="headerlink" title="1.7 常用的存储引擎:"></a>1.7 常用的存储引擎:</h2><table><thead><tr><th align="left">存储引擎</th><th align="center">描述</th></tr></thead><tbody><tr><td align="left">ARCHIVE</td><td align="center">用于数据文档(插入之后不能再被修改)</td></tr><tr><td align="left">BLACKHOLE</td><td align="center">丢弃写操作,读操作会返回空内容</td></tr><tr><td align="left">CSV</td><td align="center">在存储数据的时候,以逗号分隔数据项</td></tr><tr><td align="left">FEDERATED</td><td align="center">用来访问远程表</td></tr><tr><td align="left">InnoDB</td><td align="center">支持事务,行锁,外键</td></tr><tr><td align="left">MyISAM</td><td align="center">只要的非事务处理存储引擎</td></tr><tr><td align="left">MEMORY</td><td align="center">数据存储在内存,不存储在磁盘里面;多用于临时表</td></tr><tr><td align="left">MERGE</td><td align="center">用来管理多个MyISAM表构成的表集合</td></tr><tr><td align="left">NDB</td><td align="center">MySQL集群专用存储引擎</td></tr></tbody></table><p>其中最常用的是 <code>InnoDB</code>,<code>MyISAM</code>和<code>MEMORY</code>.</p><p>支持的功能:</p><table><thead><tr><th align="left">Feature</th><th align="left">MyISAM</th><th align="left">Memory</th><th align="left">InnoDB</th><th align="left">Archive</th><th align="left">NDB</th></tr></thead><tbody><tr><td align="left">B-tree indexes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Backup/point-in-time recovery (note 1)</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Cluster database support</td><td align="left">No</td><td align="left">No</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Clustered indexes</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Compressed data</td><td align="left">Yes (note 2)</td><td align="left">No</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">No</td></tr><tr><td align="left">Data caches</td><td align="left">No</td><td align="left">N/A</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Encrypted data</td><td align="left">Yes (note 3)</td><td align="left">Yes (note 3)</td><td align="left">Yes (note 4)</td><td align="left">Yes (note 3)</td><td align="left">Yes (note 3)</td></tr><tr><td align="left">Foreign key support</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes (note 5)</td></tr><tr><td align="left">Full-text search indexes</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes (note 6)</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Geospatial data type support</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Geospatial indexing support</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes (note 7)</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Hash indexes</td><td align="left">No</td><td align="left">Yes</td><td align="left">No (note 8)</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Index caches</td><td align="left">Yes</td><td align="left">N/A</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Locking granularity</td><td align="left">Table</td><td align="left">Table</td><td align="left">Row</td><td align="left">Row</td><td align="left">Row</td></tr><tr><td align="left">MVCC</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Replication support (note 1)</td><td align="left">Yes</td><td align="left">Limited (note 9)</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Storage limits</td><td align="left">256TB</td><td align="left">RAM</td><td align="left">64TB</td><td align="left">None</td><td align="left">384EB</td></tr><tr><td align="left">T-tree indexes</td><td align="left">No</td><td align="left">No</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Transactions</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Update statistics for data dictionary</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr></tbody></table><h2 id="1-8-关于引擎的一些操作"><a href="#1-8-关于引擎的一些操作" class="headerlink" title="1.8 关于引擎的一些操作:"></a>1.8 关于引擎的一些操作:</h2><h3 id="1-8-1-查询支持的引擎"><a href="#1-8-1-查询支持的引擎" class="headerlink" title="1.8.1 查询支持的引擎:"></a>1.8.1 查询支持的引擎:</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> engines<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/image-20210806000318560.png"></p><ul><li><code>Support</code>: 是否支持该引擎,<code>DEFAULT</code>表示该引擎是默认存储引擎</li><li><code>Comment</code>: 是该引擎的功能概述</li><li><code>Transaction</code>: 表示该引擎是否支持事务</li><li><code>XA</code>: 表示该存储引擎是否支持分布式事务</li><li><code>Saveoptions</code>: 表示该引擎是否支持部分回滚</li></ul><h3 id="1-8-2-设置表的存储引擎"><a href="#1-8-2-设置表的存储引擎" class="headerlink" title="1.8.2 设置表的存储引擎:"></a>1.8.2 设置表的存储引擎:</h3><ol><li><p>建表的时候就设置存储引擎</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t_mysql_study<span class="token punctuation">`</span><span class="token punctuation">(</span>    字段语句<span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span> 存储引擎名字<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>修改已经创建好的表的存储引擎:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 修改表的引擎</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ENGINE</span> <span class="token operator">=</span> 存储引擎名称<span class="token punctuation">;</span><span class="token comment"># 查看建表语句来看引擎是否修改</span><span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>t_mysql_study<span class="token punctuation">`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/1_%E5%88%9D%E8%AF%86MySQL/image-20210806001522467.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3 字符集和比较规则</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/3_%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/3_%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1-字符集和比较规则"><a href="#3-1-字符集和比较规则" class="headerlink" title="3.1 字符集和比较规则:"></a>3.1 字符集和比较规则:</h2><h3 id="3-1-1-字符集介绍"><a href="#3-1-1-字符集介绍" class="headerlink" title="3.1.1 字符集介绍:"></a>3.1.1 字符集介绍:</h3><p>数据在计算机中实际上是以二进制的关系存储的.</p><p><strong>字符集: 是描述某个字符范围的编码规则</strong></p><p>主要是解决两个问题:</p><ul><li>界定字符的范围,就是要将哪些字符转换成二进制数据</li><li>二进制数据和字符之间如何转换,即 编码解码过程</li></ul><h3 id="3-1-2-比较规则简介"><a href="#3-1-2-比较规则简介" class="headerlink" title="3.1.2 比较规则简介:"></a>3.1.2 比较规则简介:</h3><p><strong>比较规则:</strong> 即确定两个字符之间的大小关系.不同字符集在<code>mysql</code>中的比较规则也是不相同的</p><h3 id="3-1-3-一些重要的字符集"><a href="#3-1-3-一些重要的字符集" class="headerlink" title="3.1.3 一些重要的字符集:"></a>3.1.3 一些重要的字符集:</h3><ol><li><p><code>ASCⅡ字符集</code>: 共<code>128</code>个字符,包括空格,标点,数字,大小写字母和一些不可见的字符.<code>一个字节</code>就可以表示所有的<code>ASCⅡ字符</code></p></li><li><p><code>ISO 8859-1字符集</code>:共<code>256</code>个字符,在<code>ASCⅡ</code>的基础上增加了<code>128</code>个西欧常用字符. 也可以使用<code>一个字节</code>表示所有字符</p></li><li><p><code>GB2312字符集</code>: 收录了 <code>汉字</code>以及<code>拉丁字母</code>,<code>希腊字母</code>,<code>日本平假名,片假名</code>,<code>俄语西里尔字母</code>;汉字共<code>6763</code>个,其他文字符号<code>682</code>个. <code>GB2312</code>也兼容了<code>ASCⅡ字符</code>,所以<code>当GB2312字符在ASCⅡ字符范围内,使用一个字节;不在就是用两个字节进行编码</code></p></li><li><p><code>GBK字符集</code>: 对<code>GB2312字符集</code>在字符范围上进行了扩充,编码方式与<code>GB2312字符集</code>相同</p></li><li><p><code>UTF-8字符集</code>: 字符范围几乎涵盖当今世界各个国家/地区所使用的字符.编码方式兼容<code>ASCⅡ</code>,采用变长编码方式,一个<code>UTF8字符</code>可能需要<code>1~4个字节</code></p><blockquote><p><code>UTF-8</code>实际上是<code>Unicode字符集</code>的一种编码方案.</p></blockquote></li></ol><h2 id="3-2-MySQL支持的字符集和比较规则"><a href="#3-2-MySQL支持的字符集和比较规则" class="headerlink" title="3.2 MySQL支持的字符集和比较规则"></a>3.2 MySQL支持的字符集和比较规则</h2><h3 id="3-2-1-utf8和utf8mb4"><a href="#3-2-1-utf8和utf8mb4" class="headerlink" title="3.2.1 utf8和utf8mb4:"></a>3.2.1 <code>utf8</code>和<code>utf8mb4</code>:</h3><p>由于日常常用的字符使用<code>1~3</code>个字节基本就可以表示,为了提高编码效率,MySQL在处理<code>UTF8字符集</code>的时候从字符集名称上做了区分:</p><ul><li><code>utf8mb3</code>: mysql中<code>utf8</code>的别名,通常使用的<code>uft8</code>字符集就是这种,只使用<code>1~3个字节</code>表示字符.</li><li><code>utf8mb4</code>: 真正意义上的<code>utf8</code>字符集,使用<code>1~4</code>个字节表示字符. <code>可以存储emoji表情</code></li></ul><h3 id="3-2-2-查看字符集"><a href="#3-2-2-查看字符集" class="headerlink" title="3.2.2 查看字符集:"></a>3.2.2 查看字符集:</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> <span class="token punctuation">(</span><span class="token keyword">character</span> <span class="token keyword">set</span> <span class="token operator">|</span> <span class="token keyword">charset</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token operator">like</span> <span class="token string">'字符集名称匹配模式'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/3_%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/image-20210808175539113.png" alt="image-20210808175539113"></p><p>说明:</p><ol><li><code>Default collation</code>: 表示该字符集默认的比较规则</li><li><code>Maxlen</code>: 表示该字符集最多使用多少个字节来描述字符.</li></ol><blockquote><p>注意: mysql中字符集名称都是小写的</p></blockquote><h3 id="3-2-3-查看比较规则"><a href="#3-2-3-查看比较规则" class="headerlink" title="3.2.3 查看比较规则:"></a>3.2.3 查看比较规则:</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">show</span> collation <span class="token punctuation">[</span><span class="token operator">like</span> <span class="token string">'字符集匹配模式'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/3_%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/image-20210808180418418.png" alt="image-20210808180418418"></p><p><strong>比较规则的命名:</strong></p><ul><li><p>比较规则都是由与其关联的字符集的名称开头,如图中都是<code>utf8</code>的比较规则</p></li><li><p><code>_</code>之后紧跟的是该规则适用的语种名称.如: <code>utf8_slovak_ci</code>表示斯洛伐克语言的比较规则</p></li><li><p><code>_</code>之后紧跟的是该规则是否区分对应语言中某些性质,如<code>大小写</code>,<code>重音</code>等</p><table><thead><tr><th>后缀</th><th>描述</th></tr></thead><tbody><tr><td>_ai</td><td>不区分重音(accent insensitive)</td></tr><tr><td>_as</td><td>区分重音(accent sensitive)</td></tr><tr><td>_ci</td><td>不区分大小写(case insensitive)</td></tr><tr><td>_cs</td><td>区分大小写(case sensitive)</td></tr><tr><td>_bin</td><td>二进制形式比较(binary)</td></tr></tbody></table></li></ul><blockquote><p>每个字符集都有很多的比较规则,<code>show collation</code>语句查询出来的信息中,<code>default</code>为yes的那一种比较规则就是默认比较规则</p></blockquote><h2 id="3-3-mysql中的应用"><a href="#3-3-mysql中的应用" class="headerlink" title="3.3 mysql中的应用:"></a>3.3 mysql中的应用:</h2><h3 id="3-3-1-不同级别的字符集和比较规则"><a href="#3-3-1-不同级别的字符集和比较规则" class="headerlink" title="3.3.1 不同级别的字符集和比较规则:"></a>3.3.1 不同级别的字符集和比较规则:</h3><p>mysql字符集和比较规则分成了四个级别:</p><ul><li>服务器级别</li><li>数据库级别</li><li>表级别</li><li>列级别</li></ul><h4 id="1-服务器级别"><a href="#1-服务器级别" class="headerlink" title="1. 服务器级别:"></a>1. 服务器级别:</h4><p>服务器级别的字符集和比较规则,通过两个系统变量来设置.</p><ul><li><code>character_set_server</code>: 服务器级别字符集</li><li><code>collation_server</code>: 服务器级别比较规则</li></ul><p><strong>两个变量的查询:</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 查询字符集</span><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'character_set_server'</span><span class="token punctuation">;</span><span class="token comment">-- 查比较规则</span><span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'collation_server'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/3_%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/image-20210808182132027.png" alt="image-20210808182132027"></p><p><strong>两个变量的设置:</strong></p><p>可以通过 <code>SET</code>语句和<code>配置文件</code>的方式设置这两个系统变量</p><h4 id="2-数据库级别"><a href="#2-数据库级别" class="headerlink" title="2. 数据库级别:"></a>2. 数据库级别:</h4><p>数据库级别的字符集和比较规则,通过两个系统变量来设置:</p><ul><li><code>character_set_database</code>: 字符集</li><li><code>collation_database</code>: 比较规则</li></ul><p><strong>变量查询:</strong> 跟服务器级别没区别,只是换下变量名</p><p><strong>变量修改:</strong></p><p>在创建数据库的时候就可以指定字符集和比较规则:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建的时候设置</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 数据库名<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token punctuation">]</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集名<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token punctuation">]</span> COLLATION 比较规则名字<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">-- 修改</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 数据库名<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token punctuation">]</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集名<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token punctuation">]</span> COLLATION 比较规则名字<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意事项:</strong></p><ol><li>如果没有设置数据库级别的字符集和比较规则,那么就会使用服务器级别的字符集和比较规则</li><li><code>character_set_database</code>和<code>collation_database</code>这两个变量只是用来给用户展示当前数据库使用的字符集和比较规则,并不能通过<code>SET</code>这两个变量来改变当前数据库的字符集和比较规则.</li></ol><h4 id="3-表级别"><a href="#3-表级别" class="headerlink" title="3. 表级别:"></a>3. 表级别:</h4><p>表级别没有字符集和比较规则的系统变量</p><p><strong>设置表级别的字符集和比较规则:</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 建表设置</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名 <span class="token punctuation">(</span>列信息<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token punctuation">]</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集名称<span class="token punctuation">]</span><span class="token punctuation">[</span>COLLATION 比较规则名字<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">-- 修改</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token punctuation">(</span>列信息<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token punctuation">]</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集名称<span class="token punctuation">]</span><span class="token punctuation">[</span>COLLATION 比较规则名字<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意事项:</strong></p><ol><li>如果建表的时候没有设置字符集和比较规则,那么就会使用表所在数据库的字符集和比较规则.</li></ol><h4 id="4-列级别"><a href="#4-列级别" class="headerlink" title="4. 列级别:"></a>4. 列级别:</h4><p>列级别没有字符集和比较规则的系统变量</p><p><strong>设置列级别的字符集和比较规则:</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 建表设置</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名 <span class="token punctuation">(</span>    列名 字符串类型 <span class="token punctuation">[</span><span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集名称<span class="token punctuation">]</span> <span class="token punctuation">[</span>COLLATION 比较规则名<span class="token punctuation">]</span><span class="token punctuation">,</span>    其他列信息<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">-- 修改</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">MODIFY</span> 列名 字符串类型 <span class="token punctuation">[</span><span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集名称<span class="token punctuation">]</span> <span class="token punctuation">[</span>COLLATION 比较规则名称<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意事项:</strong></p><ol><li>如果建表的时候没有设置列的字符集和比较规则,那么就会使用列所在表的字符集和比较规则.</li><li>修改列的字符集时,如果列中的数据不能使用修改后的字符集表示,则会发生错误.</li></ol><h4 id="5-仅修改字符集或比较规则"><a href="#5-仅修改字符集或比较规则" class="headerlink" title="5. 仅修改字符集或比较规则:"></a>5. 仅修改字符集或比较规则:</h4><p>字符集和比较规则之间是相互关联的,如果仅仅修改其中某一项,另外一项也会变成对应的值</p><ul><li>仅修改字符集,则 比较规则将变为修改后的字符集默认的比较规则</li><li>仅修改比较规则, 则 字符集将变为修改后的比较规则对应的字符集</li></ul><h3 id="3-3-2-c-s通信过程中使用的字符集"><a href="#3-3-2-c-s通信过程中使用的字符集" class="headerlink" title="3.3.2 c/s通信过程中使用的字符集:"></a>3.3.2 c/s通信过程中使用的字符集:</h3><ol><li><p>客户端向服务器发送数据的时候,会使用一种字符集对数据进行编码,服务器接收到数据之后会对数据进行解码</p></li><li><p>字符集转换: 就是服务器接收到数据之后使用与客户端相同的字符集解码,然后再用其他字符集对数据进行编码</p></li><li><p>一次查询请求字符集的变化:</p><ol><li><p>客户端发送请求: </p><p>客户端在发送查询请求的时候,默认使用的字符集与系统使用的字符集相同,使用该字符集给数据进行编码.</p><blockquote><p>特别的: win系统下,可以使用<code>--defualt-character-set</code>启动项设置客户端使用的字符集,<code>unix系统</code>不行</p></blockquote></li><li><p>服务器接收请求:</p><p>服务器接收到客户端编码之后的二进制字节序列后,会为当前客户端维护一个<code>SESSION范围的变量 --- character_set_client</code>,该变量表示的是客户端在编码数据的时候使用的字符集.</p><p>如果<code>character_set_client</code>表示的字符集不能解码客户端的请求,则 报错</p></li><li><p>服务器处理请求:</p><p>在真正处理之前,会将请求数据使用 <code>character_set_client</code>表示的字符集进行解码,解码之后使用<code>SESSION 范围变量 cahracter_set_connect</code>对数据进行编码,称为一个新的字节序列</p><p><code>character_set_client</code> 变量的作用是: 描述服务器接收到请求数据并解码之后,要想正确表示客户端表达的语义应该使用什么字符集进行编码.</p></li><li><p>服务器响应之前对响应数据进行编码:</p><p>将查询结果通过数据本身在Mysql中使用的字符集进行解码,然后根据<code>SESISION范围变量 character_set_result</code>表示的字符集进行编码,编码之后发送给客户端</p></li><li><p>客户端接收到相应之后:</p><p>使用默认的字符集对数据进行解码,然后展示给用户</p></li></ol></li><li><p>交换过程流程图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/3_%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/image-20210808195044276.png" alt="image-20210808195044276"></p></li><li><p>几个变量的总结:</p><table><thead><tr><th>系统变量(SESSION范围)</th><th>作用</th></tr></thead><tbody><tr><td>character_set_client</td><td>表示请求数据编码使用的字符集</td></tr><tr><td>character_set_connection</td><td>表示请求序列需要被转换的字符集</td></tr><tr><td>character_set_result</td><td>表示客户端希望的响应数据编码时使用的字符集</td></tr></tbody></table><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/3_%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99/image-20210808193922376.png" alt="image-20210808193922376"></p></li></ol><h3 id="3-3-3-比较规则的应用"><a href="#3-3-3-比较规则的应用" class="headerlink" title="3.3.3 比较规则的应用:"></a>3.3.3 比较规则的应用:</h3><p>比较规则主要是应用于 数据字段排序.如果发现数据排序结果与期望不同,就可以考虑是不是比较规则的问题.</p>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4 InnoDB记录存储结构</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="4-2-InnoDB页简介"><a href="#4-2-InnoDB页简介" class="headerlink" title="4.2 InnoDB页简介:"></a>4.2 InnoDB页简介:</h2><p><code>InnoDB</code>引擎是一个将表中的数据存储到磁盘上的存储引擎,也就是说 即使服务器宕机,数据仍然存在于磁盘中.</p><p>由于计算机对于数据的处理都是发生内存中,为了提高效率,<code>InnoDB存储引擎</code>将数据分成若干页,以页作为磁盘和内存之间交互的基本单位.</p><p><code>InnoDB</code>的数据页的大小一般为 <code>16KB</code>,也就是说 一次最少从磁盘中读取<code>16KB</code>的数据到内存中,一次最少从内存中向磁盘写入<code>16KB</code>的数据</p><blockquote><ol><li>系统变量<code>innoDB_page_size</code>表示 <code>InnoDB</code>存储引擎数据页的大小,默认值为 <code>16384B</code></li><li><code>innoDB_page_size</code>变量只能在<code>mysql</code>第一次初始化数据目录的时候通过 <code>mysql --initialize</code>命令指定.服务器运行过程中并不能被修改</li></ol></blockquote><h2 id="4-3-InnoDB行格式"><a href="#4-3-InnoDB行格式" class="headerlink" title="4.3 InnoDB行格式:"></a>4.3 InnoDB行格式:</h2><p>通常插入数据的时候,都是以一行(一条记录)为单位插入,所以记录在磁盘中存放的形式也被称为 <code>行格式</code>或者<code>记录格式</code></p><p><code>行格式</code>总共4种: <code>COMPACT</code>,<code>REDUNDANT</code>,<code>DYNAMIC</code>和 <code>COMPRESSED</code>.</p><h3 id="4-3-1-指定行格式的语法"><a href="#4-3-1-指定行格式的语法" class="headerlink" title="4.3.1 指定行格式的语法:"></a>4.3.1 指定行格式的语法:</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 建表的时候指定</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> table_name <span class="token punctuation">(</span><span class="token keyword">columns</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> ROW_FORMAT<span class="token operator">=</span>行格式名称<span class="token punctuation">;</span><span class="token comment">-- 修改</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name ROW_FORMAT<span class="token operator">=</span>行格式名称<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-2-COMPACT行格式"><a href="#4-3-2-COMPACT行格式" class="headerlink" title="4.3.2 COMPACT行格式:"></a>4.3.2 COMPACT行格式:</h3><p>示例数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> record_format_demo<span class="token punctuation">(</span>c1 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>C2 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>C3 <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    C4 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">CHARSET</span><span class="token operator">=</span><span class="token keyword">asc</span>Ⅱ ROW_FORMAT<span class="token operator">=</span>COMPACT<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> record_format_demo<span class="token punctuation">(</span>c1<span class="token punctuation">,</span>c2<span class="token punctuation">,</span>c3<span class="token punctuation">,</span>c4<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'aaaa'</span><span class="token punctuation">,</span> <span class="token string">'bbb'</span><span class="token punctuation">,</span> <span class="token string">'cc'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token string">'eeee'</span><span class="token punctuation">,</span> <span class="token string">'fff'</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-COMPACT行格式示意图"><a href="#1-COMPACT行格式示意图" class="headerlink" title="1. COMPACT行格式示意图:"></a>1. <code>COMPACT行格式</code>示意图:</h4><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808210035653.png" alt="compact行格式示意图"></p><h4 id="2-字段解释"><a href="#2-字段解释" class="headerlink" title="2. 字段解释:"></a>2. 字段解释:</h4><h5 id="1-记录的额外信息"><a href="#1-记录的额外信息" class="headerlink" title="1. 记录的额外信息:"></a>1. 记录的额外信息:</h5><p>这部分是服务器为了更好的管理记录而不得不额外添加的一些信息.</p><h6 id="1-变长字段长度列表"><a href="#1-变长字段长度列表" class="headerlink" title="1. 变长字段长度列表:"></a>1. 变长字段长度列表:</h6><p>存储长度可以变化的字段的真实长度.比如: <code>VARCHAR</code>, <code>VARBINARY</code>, <code>TEXT</code>, <code>BLOB</code>类型字段的真实长度.</p><p><code>COMPACT</code>行格式中, 所有变长字段真实数据占用的字节数都存放在记录的开头, <code>各列所占字节数按照列的顺序逆序排列起来</code>,形成一个变长字段长度列表</p><p><font color="red">变长字段长度列表只记录非null字段真实数据的长度(占用字节数)</font></p><p><strong>变长字段真实数据占用字节数,使用多少字节表示规则如下:</strong></p><p>假设字符集表示一个字符需要<code>W字节</code>, 变长类型<code>VARCHAR(M)</code>最多能存放<code>M个字符</code>,变长字段内容占用<code>L字节</code>.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">if</span> <span class="token class-name">M</span> <span class="token operator">*</span> <span class="token class-name">W</span> <span class="token operator">&gt;</span> <span class="token number">255</span> <span class="token operator">&amp;&amp;</span>　Ｌ <span class="token operator">&gt;</span> <span class="token number">127</span><span class="token punctuation">{</span><span class="token comment">// 使用两个字节表示变长字段真实数据占用字节数    </span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token comment">// 使用一个字节表示变长字段真实数据占用字节数    </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例数据第一条记录,变长字段长度列表如下: <code>示例数据使用的是 ASCⅡ字符集</code></p><table><thead><tr><th>列名</th><th>存储内容</th><th>内容长度(占用字节数)</th><th>内容长度(16进制)</th></tr></thead><tbody><tr><td>c1</td><td><code>aaaa</code></td><td>4</td><td>0x04</td></tr><tr><td>c2</td><td><code>bbb</code></td><td>3</td><td>0x06</td></tr><tr><td>c4</td><td><code>d</code></td><td>1</td><td>0x01</td></tr></tbody></table><p>变长字段长度列表填入之后,示意图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808214820708.png"></p><h6 id="2-NULL值列表"><a href="#2-NULL值列表" class="headerlink" title="2. NULL值列表:"></a>2. NULL值列表:</h6><p>由于记录中允许存入<code>null值</code>,为了节省空间,<code>COMPACT</code>行格式将一条记录中值为<code>null</code>的列统一管理,存入<code>null值列表</code>中</p><p>处理过程:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808221517085.png"></p><ol><li>统计表中允许值为<code>null</code>的列名.</li><li>如果没有允许值为<code>null</code>的列,<code>null值列表就不存在</code>,否则将 列从后往前分别对应<code>bitMap</code>的一个位置(<code>bitMap</code>从第一位开始),当 <code>bitMap</code>中元素值为 1表示对应列的值为null,值为0表示对应列的值不为null.</li><li>字节填充, <code>MYSQL</code>要求<code>null值列表</code>必须是 <code>8b</code>的整数倍(即 整数)</li></ol><p>null值列表填入后,记录结构为:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808220938727.png"></p><h6 id="3-记录头信息"><a href="#3-记录头信息" class="headerlink" title="3. 记录头信息:"></a>3. 记录头信息:</h6><p><code>记录头信息</code>使用<code>5个字节,40位</code>表示,用于描述记录的一些属性,不同位记录不同的信息.前4位称为 <code>info位</code></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808221601038.png" alt="记录头信息示意图"></p><table><thead><tr><th>名称</th><th>大小(位)</th><th>意义</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_flag</td><td>1</td><td>标记记录是否被删除</td></tr><tr><td>min_rec_flag</td><td>1</td><td>B+树每层非叶子结点中最小的目录项记录都会添加这个标记</td></tr><tr><td>n_owned</td><td>4</td><td>每页数据都会被分成若干组,每个组都有个组长,组长记录的n_owned值表示该组人员数量</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在页面堆中的相对位置</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型,0(普通记录),1(B+树非叶子节点的目录项记录),2(Infimum记录),3(Supremum记录)</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><p>见<a href="5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84.md">字段详解</a></p><p><strong>示例数据的记录头信息:</strong></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808222437030.png"></p><h5 id="2-记录的真实信息"><a href="#2-记录的真实信息" class="headerlink" title="2. 记录的真实信息:"></a>2. 记录的真实信息:</h5><h6 id="1-隐藏字段"><a href="#1-隐藏字段" class="headerlink" title="1. 隐藏字段:"></a>1. 隐藏字段:</h6><p>记录的真实信息里面,由于<code>null值字段</code>已经被位图映射的方式记录在了null值字段表里面,所以真实信息是不包含null值字段的.</p><p>除了一些真实字段数据会被记录在记录的真实信息里面,<code>MySQL</code>还会向里面添加几个隐藏字段:</p><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6字节</td><td>行ID,唯一表示一条记录</td></tr><tr><td>trx_id</td><td>是</td><td>6字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7字节</td><td>回滚指针</td></tr></tbody></table><p>说明:</p><ol><li><p>这三个真实的名字为 <code>DB_ROW_ID</code>,<code>DB_TRX_ID</code>,<code>DB_ROLL_POINTER</code></p></li><li><p><code>row_id</code>这个字段不是必须的原因,在<code>MYSQL</code>无法使用用户自定义字段为主键的时候才添加.</p><p><code>mysql</code>主键生成策略:</p><ol><li>使用用户指定的主键作为主键</li><li>用户没有指定主键,使用<code>非null的UNIQUE键</code>作为主键</li><li>没有<code>非null的UNIQUE键</code>,添加隐藏字段<code>row_id</code>.</li></ol></li><li><p>真实信息里面,不会出现null字段</p></li></ol><h5 id="3-CHAR-M-列的存储格式"><a href="#3-CHAR-M-列的存储格式" class="headerlink" title="3. CHAR(M)列的存储格式:"></a>3. CHAR(M)列的存储格式:</h5><ul><li><code>CHAR(M)</code>类型数据,在使用定长字符集(比如: <code>ascⅡ</code>字符集)的时候,这种类型的字段长度是不会被记录到变长字段长度列表里面.此时变长字段长度列表如图:</li></ul><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808224922203.png"></p><ul><li><p><code>CHAR(M)</code>类型字段,在使用变长字符集(比如: <code>utf8</code>字符集)的时候,这种类型的字段长度是会记录到变长字段长度列表里面.此时变长字段长度列表如图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808225109072.png"></p><blockquote><p>采用变长编码字符集的时候,CHAR(M)类型的数据,至少占用M个字节,即哪怕空串该列也会占用M字节</p></blockquote></li></ul><h4 id="3-示例数据最终的样子"><a href="#3-示例数据最终的样子" class="headerlink" title="3. 示例数据最终的样子:"></a>3. 示例数据最终的样子:</h4><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808224253863.png"></p><h3 id="4-3-3-REDUNDANT行格式"><a href="#4-3-3-REDUNDANT行格式" class="headerlink" title="4.3.3 REDUNDANT行格式:"></a>4.3.3 REDUNDANT行格式:</h3><p>这种格式在 <code>MYSQL5.0</code>之前就在使用了.</p><h4 id="1-REDUNDANT行格式示意图"><a href="#1-REDUNDANT行格式示意图" class="headerlink" title="1. REDUNDANT行格式示意图:"></a>1. <code>REDUNDANT行格式</code>示意图:</h4><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808225311548.png"></p><h4 id="2-字段解释-1"><a href="#2-字段解释-1" class="headerlink" title="2. 字段解释:"></a>2. 字段解释:</h4><p>示例数据具体格式:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808225758037.png"></p><h5 id="1-字段长度偏移列表"><a href="#1-字段长度偏移列表" class="headerlink" title="1. 字段长度偏移列表:"></a>1. 字段长度偏移列表:</h5><p>通过字段长度偏移量的差值表示字段的长度,同样是按照字段顺序逆序存放.</p><h5 id="2-记录头信息"><a href="#2-记录头信息" class="headerlink" title="2. 记录头信息:"></a>2. 记录头信息:</h5><p><code>REDUNDANT行格式</code>的记录头信息占用6字节(48位)</p><table><thead><tr><th>名称</th><th>大小(位)</th><th>意义</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_flag</td><td>1</td><td>标记记录是否被删除</td></tr><tr><td>min_rec_flag</td><td>1</td><td>B+树每层非叶子结点中最小的目录项记录都会添加这个标记</td></tr><tr><td>n_owned</td><td>4</td><td>每页数据都会被分成若干组,每个组都有个组长,<code>组长记录</code>的n_owned值表示该组人员数量</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在页面堆中的相对位置</td></tr><tr><td>n_field</td><td>10</td><td>记录中列的数量</td></tr><tr><td>1byte_offs_flag</td><td>1</td><td>标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><h5 id="3-1byte-offs-flag如何选择"><a href="#3-1byte-offs-flag如何选择" class="headerlink" title="3. 1byte_offs_flag如何选择:"></a>3. 1byte_offs_flag如何选择:</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> length <span class="token operator">=</span> 当前记录总长度<span class="token punctuation">;</span><span class="token keyword">if</span> length <span class="token operator">&lt;=</span> <span class="token number">127</span> <span class="token punctuation">{</span>    <span class="token comment">// 使用一个字节表示,即 1byte_offs_flag = 1</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment">// 使用两个字节表示,即 1byte_offs_flag = 0</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明: </p><p>实际上,当前记录总长度大于127时分成了两种情况: </p><ul><li><code>length &gt; 127 &amp;&amp; lenght &lt;= 32767</code>.</li><li><code>length &gt; 32767</code>. 这种情况下,由于每页只会保存记录前768字节和20字节的溢出页面地址,使用两个字节来表示列的长度偏移量也足够了</li></ul><p>为什么总长度大于127就要使用两个字节.</p><p>原因是: 每个列长度偏移量值 的第一位是用来记录该列是否为null的.第一位为1表示该列为null,所以 非null列数据偏移量的第一位不能为null,但是此时还需要多余的位来记录偏移量信息,于是只能使用第二个字节了.</p><h5 id="4-REDUNDANT行格式null值得处理"><a href="#4-REDUNDANT行格式null值得处理" class="headerlink" title="4. REDUNDANT行格式null值得处理:"></a>4. REDUNDANT行格式null值得处理:</h5><ul><li>对应列偏移量值的第一位是 该列是否为null的标志位,如果第一位为1,则表示该列为null</li><li>如果值为null的列是定长类型的,则真实数据部分也会为其开辟空间,然后使用0值填充</li><li>如果值为null的列是变长类型的,则真实数据部分不会为其开辟空间</li></ul><h5 id="5-CHAR-M-的处理"><a href="#5-CHAR-M-的处理" class="headerlink" title="5. CHAR(M)的处理:"></a>5. CHAR(M)的处理:</h5><p><code>REDUNDANT行格式</code>在处理CHAR(M)类型字段的时候,固定使用 对应字符集表示一个字符最多需要的字节数* M 表示该字段所占用的空间.</p><h3 id="4-3-4-溢出列"><a href="#4-3-4-溢出列" class="headerlink" title="4.3.4 溢出列:"></a>4.3.4 溢出列:</h3><p>示例数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> off_page_demo<span class="token punctuation">(</span>c <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">65532</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8 ROW_FORMAT<span class="token operator">=</span>COMPACT<span class="token punctuation">;</span><span class="token comment">-- REPEAT('a',65532)表示a重复65532次</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> off_page_demo <span class="token punctuation">(</span>c<span class="token punctuation">)</span> VLAUES <span class="token punctuation">(</span><span class="token keyword">REPEAT</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token number">65532</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-溢出列"><a href="#1-溢出列" class="headerlink" title="1. 溢出列:"></a>1. 溢出列:</h4><p>在<code>COMPACT</code>和<code>REDUNDANT</code>行格式中如果某个列占用的字节数非常多,那么在该记录的真实数据处只会存储真实数据的前768字节和 存放其余数据的溢出页的地址(占20字节)</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808234317204.png"></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/4_InnoDB%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/image-20210808234332764.png"></p><h4 id="2-产生溢出页的临界点"><a href="#2-产生溢出页的临界点" class="headerlink" title="2. 产生溢出页的临界点:"></a>2. 产生溢出页的临界点:</h4><p><code>Mysql</code>规定正常页面至少要存放两条记录,溢出页没有这个规定</p><p><code>Mysql页空间的分配</code>:</p><ul><li>除了记录以外的额外信息,占用132字节</li><li>每条记录的额外信息是 27字节<ul><li>2字节用于存放真实数据的长度</li><li>1字节存放列是否为null</li><li>5字节存放记录头信息</li><li>6字节的row_id列信息</li><li>6字节的trx_id列信息</li><li>7字节的roll_pointer列</li></ul></li></ul><p>如果假设一个单列记录真实数据的字节数为n,如果该列不发生溢出现象,n应该满足:  <code>132 + 2* (27*n) &lt;= 16384 </code>,也就是说单列记录不发生溢出现象的最大长度为 8099字节.</p><h3 id="4-3-5-DYNAMIC-COMPRESSED"><a href="#4-3-5-DYNAMIC-COMPRESSED" class="headerlink" title="4.3.5 DYNAMIC COMPRESSED"></a>4.3.5 DYNAMIC COMPRESSED</h3><p><code>MySQL5.7版本</code>默认的行格式为 <code>DYNAMIC</code>:</p><p>这两个行格式和<code>COMPACT</code>格式基本相同,只是处理溢出列上不同: 不会存储溢出列真实数据的前768字节,而是将所有真实数据都存放在溢出页中,在真实数据部分只会存放溢出页的地址.</p><p>COMPRESSED行格式会采用压缩算法对页面进行压缩,以节省空间.DYNAMIC行格式不会压缩页面.</p>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5 InnoDB数据页结构</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="5-1-不同类型的页简介"><a href="#5-1-不同类型的页简介" class="headerlink" title="5.1 不同类型的页简介:"></a>5.1 不同类型的页简介:</h2><p>页是<code>InnoDB存储引擎</code>管理存储空间的基本单位, 一个页的基本单位是16KB.</p><p>InnoDB为了不同目的而设计了多种不同类型的页,比如:  <code>存放表空间头部信息的页</code>, <code>存放change buffer 信息的页</code>,<code>存放INODE信息的页</code>,<code>存放undo日志信息的页</code>等等</p><p>本章节主要是介绍<code>存放表中记录的页</code>,官方称之为 : <code>索引页index</code>,为了方便理解 称之为 <code>数据页</code>.</p><h2 id="5-2-数据页结构简介"><a href="#5-2-数据页结构简介" class="headerlink" title="5.2 数据页结构简介:"></a>5.2 数据页结构简介:</h2><p><code>Mysql</code>将数据页这块16KB大小的存储空间大致被划分成了 7个部分,不同部分有不同的功能.  如图所示: </p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809223800797.png" alt="单页数据页构成图"></p><p>各部分大致存储什么内容,如下表所示:</p><table><thead><tr><th>名称</th><th>中文名</th><th>占用空间(字节)</th><th>功能概述</th></tr></thead><tbody><tr><td>File Header</td><td>文件头部</td><td>38</td><td>页的通用信息</td></tr><tr><td>Page Header</td><td>页面头部</td><td>56</td><td>数据页的专有信息</td></tr><tr><td>Infimum+Supremum</td><td>页面中最小记录和最大记录</td><td>26</td><td>两个虚拟记录</td></tr><tr><td>User Record</td><td>用户记录</td><td>不确定</td><td>用户存放的记录</td></tr><tr><td>Free Space</td><td>空闲空间</td><td>不确定</td><td>页中尚未使用的空间</td></tr><tr><td>Page Directory</td><td>页目录</td><td>不确定</td><td>页中某些记录的相对位置</td></tr><tr><td>File Trailer</td><td>文件尾部</td><td>8</td><td>校验页是否完整</td></tr></tbody></table><h2 id="5-3-记录在页中的存储"><a href="#5-3-记录在页中的存储" class="headerlink" title="5.3 记录在页中的存储:"></a>5.3 记录在页中的存储:</h2><p>在数据页的7个部分中,用户自己存入的记录会按照指定的行格式存储到<code>User Records</code>部分中.</p><p>在数据页生成的时候实际上是没有<code>User Records</code>这部分的,每当一条数据插入进来的时候,就会去<code>Free Space</code>部分申请记录需要的空间,然后与之前的<code>User Records</code>合并.当<code>Free Space</code>使用完之后就会去申请新的数据页.</p><p>数据存入大致流程:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809223836259.png" alt="数据存入数据页大致流程"></p><p><strong>示例数据:</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> page_demo <span class="token punctuation">(</span>c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>c2 <span class="token keyword">INT</span><span class="token punctuation">,</span>    c3 <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">CHARSET</span><span class="token operator">=</span>ascii ROW_FORMART<span class="token operator">=</span>COMPACT<span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> page_demo <span class="token keyword">VALUES</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'bbbb'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">300</span><span class="token punctuation">,</span><span class="token string">'cccc'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token string">'dddd'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>COMPACT</code>行格式中,<code>记录头信息</code>包含以下内容:</p><table><thead><tr><th>名称</th><th>大小(位)</th><th>意义</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>delete_flag</td><td>1</td><td>标记记录是否被删除</td></tr><tr><td>min_rec_flag</td><td>1</td><td>B+树每层非叶子结点中最小的目录项记录都会添加这个标记</td></tr><tr><td>n_owned</td><td>4</td><td>每页数据都会被分成若干组,每个组都有个组长,组长记录的n_owned值表示该组人员数量</td></tr><tr><td>heap_no</td><td>13</td><td>表示当前记录在页面堆中的相对位置</td></tr><tr><td>record_type</td><td>3</td><td>表示当前记录的类型,0(普通记录),1(B+树非叶子节点的目录项记录),2(Infimum记录),3(Supremum记录)</td></tr><tr><td>next_record</td><td>16</td><td>表示下一条记录的相对位置</td></tr></tbody></table><p>为了屏蔽干扰,后续示例数据行格式图都只给出<code>记录头信息</code>和<code>数据真实部分</code>,如图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809232737709.png" alt="记录头与真实数据部分"></p><p>向<code>page_demo</code>表插入四条数据之后,<code>User Records</code>部分如图所示: </p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809233733977.png" alt="插入4条示例数据后记录示意图"></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809235722131.png" alt="实际数据在磁盘中的结构"></p><p><font color="red"><strong>从上图可以看出来,记录在数据页中是按照主键大小依次排列紧挨着排列的</strong> </font></p><h3 id="5-3-1-记录头信息各个字段的含义"><a href="#5-3-1-记录头信息各个字段的含义" class="headerlink" title="5.3.1 记录头信息各个字段的含义:"></a>5.3.1 记录头信息各个字段的含义:</h3><h4 id="1-delete-flag"><a href="#1-delete-flag" class="headerlink" title="1. delete_flag:"></a>1. delete_flag:</h4><p><code>delete_flag</code>: 是用于标记该记录是否被删除,占用1位, <code>值为0表示记录没有被删除</code>,值 为1表示记录被删除.</p><p><code>MySQL</code>在删除数据的时候,实际上采用了<code>逻辑删除</code>的思想, 通过标记位标记记录是否被删除,当有新记录要插入进来的时候,复用这些被删除记录占用的空间,而不是将数据从磁盘中删除掉,然后对所有记录按照主键进行重排序.这样做的好处是<font color="#green"><strong>避免了重排序和空间开辟的性能消耗,又不浪费空间</strong>&nbsp;</font>.</p><p>被删除的数据还会通过记录头中的<code>next_record</code>将当前页中被删除的记录形成一个链表.</p><h4 id="2-min-rec-flag"><a href="#2-min-rec-flag" class="headerlink" title="2. min_rec_flag:"></a>2. min_rec_flag:</h4><p><code>min_rec_flag</code>: B+树每层非叶子结点中的最小的目录项记录都会添加这个标记.</p><h4 id="3-o-owned"><a href="#3-o-owned" class="headerlink" title="3. o_owned:"></a>3. o_owned:</h4><p><code>o_owned</code>: <code>Mysql</code>会将数据页中的记录按照一定的规则分成多个小组,每个小组中主键值最大的记录就是组长,只有组长的记录头信息中的<code>o_owned</code>字段记录着这个分组中有多少个成员(包括组长).</p><h4 id="4-heap-no"><a href="#4-heap-no" class="headerlink" title="4. heap_no:"></a>4. heap_no:</h4><p>记录在数据页中真实的情况是按照主键大小紧密无间的排列,<code>MySQL</code>将这种结构称为 <code>heap堆</code>.</p><p><code>heap_no字段</code>: 表示记录在堆中的编号,即堆中第几条记录.</p><p>两个特殊的记录:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210809235809341.png" alt="Infimum和Superemum"></p><ul><li><code>Infimum记录</code>: <code>MySQL</code>自动给数据页中插入的<code>Mysql规定的当前页</code>最小的记录. <font color="yellow"><strong>并且<code>MySQL</code><strong>规定</strong> <code>Infimum记录</code>记录头信息中<code>heap_no字段值为0</code>,<code>next_record</code>永远指向用户自己添加的记录中主键最小的那一条记录.</strong> </font></li><li><code>Supremum记录</code>: <code>MySQL</code>自动给数据页中插入的<code>MySQL规定的当前页面</code>最大的记录.<font color="yellow"><strong>并且<code>MySQL</code><strong>规定</strong>,<code>Supremum记录</code>记录头信息中<code>heap_no字段的值为1</code>, 用户自己添加的记录中主键最大的那一条记录的<code>next_record</code>永远指向<code>Supremum记录</code></strong> </font></li></ul><blockquote><ol><li>这两条特殊记录共同组成了数据页中<code>Infimum+Spremium</code>部分</li><li>对于一条完整的记录来说,比较记录的大小就是比较主键的大小. 一条完整的记录,一条完整的记录,一条完整的记录</li></ol></blockquote><p>用户自己插入的记录是普通记录,普通记录根据记录的大小从2开始递增作为其记录头信息<code>heap_no字段</code>的值.</p><p><font color="red">**&nbsp;<code>heap_no字段</code>因为是表示记录在堆中的编号,一旦在分配了之后就不会改变,哪怕那条记录被删除了**&nbsp;</font></p><h4 id="5-record-type"><a href="#5-record-type" class="headerlink" title="5. record_type:"></a>5. record_type:</h4><p><code>record_type</code>: 表示当前记录的类型.<code>MySQL</code>中一共4中类型 — 0表示普通类型,1表示B+树非叶子结点的目录项记录,2表示Infimum记录,3表示Supremum记录.</p><h4 id="6-next-record"><a href="#6-next-record" class="headerlink" title="6. next_record:"></a>6. next_record:</h4><p><code>next_record</code>: 表示当前记录的真实数据到下一条记录的真实数据的距离.</p><p><code>next_record</code>值的符号表示方向,如果值为负数表示下一条记录的真实数据在当前记录真实数据的前面,如果值为整数,表示下一条记录的真实数据在当前记录的真实数据的后面.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210810002933353.png" alt="记录在数据页中形成的单链表"></p><p>为什么<code>next_word</code>表示的是 到下一条记录真实数据的距离,而不是下一条记录开始的位置?</p><p>因为<code>next_record</code>指向这里刚刚好,向前就是记录的头信息,向后就是记录的真实数据,而且行格式中,<code>变长字段列表</code>和<code>null值列表</code>都是按照逆序存放的,这样可以使记录中位置靠前的字段和他们对应的字段长度信息在内存中的距离更近,可能会提高高速缓存的命中率</p><h2 id="5-4-Page-Directory"><a href="#5-4-Page-Directory" class="headerlink" title="5.4 Page Directory:"></a>5.4 Page Directory:</h2><p>由于<code>Mysql</code>中的记录是按照主键值从小到大排列的,通过记录头信息中<code>next_record</code>字段可以定位到下一个记录,从而形成一个单向链表,单向链表在查找的时候效率不高,于是<code>Mysql</code>通过目录的形式快速定位某个区间,然后逐一去排查的方式来快输定位.</p><h3 id="5-4-1-实现过程如下"><a href="#5-4-1-实现过程如下" class="headerlink" title="5.4.1 实现过程如下:"></a>5.4.1 实现过程如下:</h3><ol><li><p>将所有记录(包含: <code>Infimum</code>和<code>Spremum</code>)划分成多个小组.</p></li><li><p>因为每个记录都是按照主键值从小到大依次排列,将小组中最后一条记录选为目录项(即组长),在其记录头信息的<code>o_owned</code>字段中记录该小组有多少条记录</p></li><li><p>将目录项在页面中的地址偏移量(就是该记录的真实数据与页面第0个字节之间的距离),单独提取出来,按在分组的先后顺序从最靠近页尾部的地方开始存放起来.存放目录项地址偏移量的地方被称为<code>槽</code>,是一个2字节大小的空间.</p></li><li><p>这些槽构成页面中的<code>Page Directory</code>部分.</p><blockquote><p>对于小组,<code>mysql</code>规定: </p><ol><li><code>Infimum</code>记录,单独为一个小组,即 <code>Infimum</code>记录所在的小组只能有一条记录</li><li><code>Spremum</code>记录所在的小组记录条数只能在 <code>1~8</code>条之间</li><li>其他小组记录条数只能在<code>4~8</code>条之间</li></ol><p>关于槽:</p><ul><li>槽的顺序: 分组的时候先从主键值小的记录开始向后分,槽表示的记录越小就越靠近<code>File Tailer</code>部分</li><li>槽如何排列的: <code>Page Directory</code>部分实际上就是一个<code>指针数组</code>,数组中的元素连续分布. </li></ul><p>为什么槽只需要两个字节:</p><p>因为页面大小为16KB,范围在<code>0 ~ 16384</code>字节之间,2个字节可以表示的范围在 <code>0 ~ 65535</code>之间,所以两个字节够了.</p></blockquote></li></ol><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210811224713628.png" alt="页目录中的槽指向分组中主键最大的元素"></p><h3 id="5-4-2-分组的过程"><a href="#5-4-2-分组的过程" class="headerlink" title="5.4.2 分组的过程:"></a>5.4.2 分组的过程:</h3><ol><li><p>数据页在还没有插入记录的时候,实际上只有两个分组,一个 <code>Infimum</code>代表的分组和<code>Spremum</code>代表的分组.</p><p>页目录也只有两个槽,分别指向<code>Infimum</code>和<code>Spremum</code>的真实数据开始的位置.</p></li><li><p>之后每插入一个记录都会从页目录中找到槽指向记录的主键值比待插入主键值大但是差值最小的槽.然后将槽指向记录的记录头信息中<code>o_owned</code>字段+1,表示本组新增一条记录,直到该组中记录数等于8个.</p></li><li><p>当小组中记录数目等于8个的时候,再向组内插入记录,该组就会分裂成两个小组,一个组4个一个组5个元素.然后给新增的小组分配一个新的槽位,来记录新增小组中组长真实数据的地址偏移量.</p></li></ol><h3 id="5-4-3-查找演示"><a href="#5-4-3-查找演示" class="headerlink" title="5.4.3 查找演示:"></a>5.4.3 查找演示:</h3><p>示例数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">Insert</span> <span class="token keyword">into</span> page_demo <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token string">'bbbb'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">300</span><span class="token punctuation">,</span><span class="token string">'cccc'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token string">'dddd'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token string">'eeee'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">600</span><span class="token punctuation">,</span><span class="token string">'ffff'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">700</span><span class="token punctuation">,</span><span class="token string">'gggg'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">800</span><span class="token punctuation">,</span><span class="token string">'hhhh'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">900</span><span class="token punctuation">,</span><span class="token string">'iiii'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token string">'jjjj'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">1100</span><span class="token punctuation">,</span><span class="token string">'kkkk'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">1200</span><span class="token punctuation">,</span><span class="token string">'llll'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">1300</span><span class="token punctuation">,</span><span class="token string">'mmmm'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">1400</span><span class="token punctuation">,</span><span class="token string">'nnnn'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">1500</span><span class="token punctuation">,</span><span class="token string">'oooo'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">1600</span><span class="token punctuation">,</span><span class="token string">'pppp'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>假设目前分组如图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210811230743354.png" alt="记录分组示意图"></p><p>现在想要查找主键值为6的元素,因为<code>Page Directory</code>实际上就是个指针数组,并且指向的值还是按照大小逆序的,所以可以使用2分发查找:</p><ol><li>计算中间槽位: (0+４)／2 = 2,槽2指向记录的主键值为8,比6大,所以要查找的6在槽2的前面.调整high=2,low不变</li><li>重新计算中间槽位: (0+2)/2 =1,槽1指向记录的主键值为4,比6小,所以要查找的6在槽1的后面.</li><li>此时high-low=1,表示中间没有槽位了,所以主键为6的记录应该是在槽2对应的小组里面.由于记录在数据页中是按照主键从小到大依次根据<code>next_record</code>形成的一条单向链表,虽然知道槽2对应分组最大的记录但是也无法从其找到需要的记录,所以应该从槽1指向的记录通过<code>next_record</code>开始遍历找到需要的记录.</li></ol><h2 id="5-5-Page-Header"><a href="#5-5-Page-Header" class="headerlink" title="5.5 Page Header:"></a>5.5 Page Header:</h2><p><code>Page Header</code>主要是用来存储数据页中记录的状态信息的,比如: 数据页已经存了多少条记录,<code>Free Space</code>在页中的偏移量,页目录中存储了多少个槽位等.固定<code>56字节</code>.</p><p><strong>Page Header 各部分及作用:</strong></p><table><thead><tr><th>状态名称</th><th>占用空间(字节)</th><th>作用</th></tr></thead><tbody><tr><td>PAGE_N_DIR_SLOTS</td><td>2</td><td>页目录中槽的数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2</td><td>当前Free Space开始的地址</td></tr><tr><td>PAGE_N_HEAP</td><td>2</td><td>第一位表示本页记录是否为紧凑型记录,其余位本页堆中记录的数量(包含Infimum,Supremum,被标记为<code>已删除</code>的记录)</td></tr><tr><td>PAGE_FREE</td><td>2</td><td>表示的是 <code>已删除记录</code>形成的单向链表中头结点记录在页面的偏移量.</td></tr><tr><td>PAGE_GARBAGE</td><td>2</td><td><code>已删除记录</code>占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2</td><td>最后插入的记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2</td><td>一个方向连续插入记录的数量</td></tr><tr><td>PAGE_N_RECS</td><td>2</td><td>本页用户记录数量(不含: <code>Infimum</code>,<code>Supremum</code> 以及 <code>已删除记录</code>)</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8</td><td>本页最大的事务id,这个值仅在二级索引页面中定义</td></tr><tr><td>PAGE_LEVEL</td><td>2</td><td>本页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8</td><td>索引ID,表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10</td><td>B+树叶子结点段的头部信息,仅在B+树的根页面中定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10</td><td>B+树非叶子结点段的头部信息,仅在B+树的根页面中定义</td></tr></tbody></table><blockquote><ol><li><code>PAGE_DIRECTION</code>: 待插入记录的主键值比上一条记录的主键值大,则 待插入记录的插入方向就是右边,否则为左边.<code>PAGE_DIRECTION</code>就是记录这个方向</li><li><code>PAGE_N_DIRECTION</code> : 如果连续插入几条记录<code>PAGE_DIRECTION</code>都是一样的,<code>Mysql</code>就会记录沿着同一个方向插入的记录条数.如果如果方向改变<code>PAGE_N_DIRECTION</code>就会被清零重新统计</li></ol></blockquote><h2 id="5-6-File-Header"><a href="#5-6-File-Header" class="headerlink" title="5.6 File Header:"></a>5.6 File Header:</h2><p><code>File Header</code>通用于个类型的页,它描述一些通用于各种页的信息,比如本页编号,上一页,下一页等,固定占用<code>38字节</code></p><p><strong>File Header</strong>各部分及其作用:</p><table><thead><tr><th>状态名称</th><th>占用空间大小(字节)</th><th>描述</th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHKSUM</td><td>4</td><td>本页校验和</td></tr><tr><td>FIL_PAGH_OFFSET</td><td>4</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4</td><td>上一页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4</td><td>下一页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8</td><td>本页被最后修改时对应的LSN(Log Sequence Number,日志序列号)</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2</td><td>本页类型</td></tr><tr><td>FIL_PAGE_FILE_FLSH_LSN</td><td>8</td><td>仅在系统表空间的第一个页中定义,表示文件至少被刷新到了对应的LSN</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4</td><td>页属于哪个表空间</td></tr></tbody></table><ul><li><p><code>FIL_PAGH_OFFSET</code>: 页的唯一标识,<code>MySQL</code>通过页号唯一确定一个页</p></li><li><p><code>FIL_PAGE_NEXT</code>和<code>FIL_PAGE_PREV</code>: 由于一张表可能存储成千上万条数据,所以肯定无法分配连续的空间来存储,那么就需要将一张表的数据页关联起来.<code>MySQL</code>就是通过<code>FIL_PAGE_NEXT</code>和<code>FIL_PAGE_PREV</code>分别指向下一页和上一页,以页为结点形成一个双向链表.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/5_InnoDB%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84/image-20210812001008664.png" alt="数据页之间形成的双向链表"></p></li></ul><p><strong>页的类型:</strong></p><table><thead><tr><th>类型</th><th>16进制</th><th>含义</th></tr></thead><tbody><tr><td>FIL_PAGE_TYPE_ALLOCATED</td><td>0x0000</td><td>刚分配还未使用</td></tr><tr><td>FIL_PAGE_UNDO_LOG</td><td>0x0002</td><td>undo日志页</td></tr><tr><td>FIL_PAGE_INODE</td><td>0x0003</td><td>存储段的信息</td></tr><tr><td>FIL_PAGE_IBUF_FREE_LIST</td><td>0x0004</td><td>Change buffer空闲列表</td></tr><tr><td>FIL_PAGE_IBUF_BITMAP</td><td>0x0005</td><td>Change Buffer的一些属性</td></tr><tr><td>FIL_PAGE_TYPE_SYS</td><td>0x0006</td><td>存储一些系统数据</td></tr><tr><td>FIL_PAGE_TYPE_TRX_SYS</td><td>0x0007</td><td>事务的系统数据</td></tr><tr><td>FIL_PAGE_TYPE_FSP_HDR</td><td>0x0008</td><td>表空间的头部信息</td></tr><tr><td>FIL_PAGE_TYPE_XDES</td><td>0x0009</td><td>存储区的一些属性</td></tr><tr><td>FIL_PAGE_TYPE_BLOB</td><td>0x000A</td><td>溢出页</td></tr><tr><td>FIL_PAGE_INDEX</td><td>0x45BF</td><td>索引页(即数据页)</td></tr></tbody></table><h2 id="5-7-File-Trailer"><a href="#5-7-File-Trailer" class="headerlink" title="5.7 File Trailer:"></a>5.7 File Trailer:</h2><p><code>File Trailer</code>: 由于数据操作实际上都是在内存中,操作完成之后需要将结果刷新到磁盘里面去,为了防止数据没有被完全刷新的情况,<code>Mysql</code>通过<code>File Trailer</code>来校验一个数据页是否是完整的.<code>File Trailer</code>通用于所有类型的页,由<code>8字节</code>组成:</p><ul><li><code>前四字节</code>表示页的校验和: 这部分与<code>File Header</code>中的校验和是相对应的. 每当一个页在内存中操作完成,写回磁盘的时候都是先写<code>File Header</code>,在最后校验和也会被写入到<code>File Trailer</code>.如果写回磁盘的过程中,出现了只写了<code>File Header</code>中的校验和,没来得及写<code>FIle Trailer</code>中的校验和,那么就会出现在校验的时候<code>File Header</code>中的校验和是新的,而<code>File Trailer</code>中的校验和是旧的,导致出现问题</li><li><code>后四字节</code>表示页面被修改时对应的LSN的后四字节,正常情况下,<code>File Header</code>的<code>FILE_PAGE_LSN</code>字段的后四字节相同.</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6 B+树索引</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813231933719.png"></p><p>前面说过,每页都有一个<code>page directory</code>作为页中记录的目录,可以通过二分法快速定位页中某条记录,现在可以快速定位页中的记录了,但是如何定位到页就成了问题,索引就是解决这个问题的</p><h2 id="6-1-没有索引如何查找"><a href="#6-1-没有索引如何查找" class="headerlink" title="6.1 没有索引如何查找"></a>6.1 没有索引如何查找</h2><h3 id="6-1-1-在页中查找"><a href="#6-1-1-在页中查找" class="headerlink" title="6.1.1 在页中查找:"></a>6.1.1 在页中查找:</h3><p>在页中查找一般是分为两种情况:</p><ul><li>以主键为搜索条件: 页目录中的槽快速定位某个主键,然后根据主键去快速定位某条记录</li><li>以其他列作为条件: 对非主键列的查找无法通过页目录中的槽定位主键,只能从<code>Infimum</code>开始一个一个的遍历.</li></ul><p>在很多页中查找:</p><p>在很多页中查找首先需要定位数据在那一页,然后才能在数据页中查找到数据.如果没有引入索引的话,无论是以主键为条件,或者以其他列为条件都无法快速定位数据在那一页,只能从第一页开始沿着双端链表逐一遍历.</p><h2 id="6-2-索引"><a href="#6-2-索引" class="headerlink" title="6.2 索引:"></a>6.2 索引:</h2><h3 id="6-2-1-一个简易的索引方案"><a href="#6-2-1-一个简易的索引方案" class="headerlink" title="6.2.1 一个简易的索引方案:"></a>6.2.1 一个简易的索引方案:</h3><p>为了演示效果,数据示意图将会以下面的形式出现:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813234348296.png"></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813234402899.png"></p><p>示例数据:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>index_demo<span class="token punctuation">`</span><span class="token punctuation">(</span>c1 <span class="token keyword">INT</span><span class="token punctuation">,</span>    C2 <span class="token keyword">INT</span><span class="token punctuation">,</span>    C3 <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    PRIMERY <span class="token keyword">KEY</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">Insert</span> <span class="token keyword">into</span> <span class="token punctuation">`</span>index_demo<span class="token punctuation">`</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'U'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token string">'D'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'Y'</span><span class="token punctuation">)</span><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token punctuation">`</span>index_demo<span class="token punctuation">`</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">'a'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了演示效果,假设一个数据页中只能存放3条数据,大于3条就要开辟新的页来存放数据. 所以在插入上面三条记录之后,在页面中已经形成一条单向链表,且已经满了在执行第二条插入语句的时候,就会形成下面这种情况:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813234416566.png"></p><blockquote><ol><li>新生成的页号为什么是28? 因为在磁盘中多次申请磁盘空间可能不是连续的,因此页号页可能不是连续的</li><li><code>Mysql</code>规定页号大的数据页中数据主键值要比页号小的数据页中数据主键值大,否则就需要将不满足要求的数据与旧数据页中满足要求的数据进行交换</li></ol></blockquote><p>为了满足页 号大的数据页中数据主键值要比页号小的数据页中数据主键值大,交换的过程如下:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813235037699.png"></p><p>多次向 <code>index_demo</code>表中插入数据之后,如图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813235310187.png"></p><p>由于数据页之间是一个双端链表的结构,想要定位数据页只能逐一遍历,为了提高定位数据的效率,给数据页建立对应的目录,每个目录包含下列两部分:</p><ul><li>页的用户记录中最小的主键值,用 <code>key</code> 来表示;</li><li>页号,用 <code>page_no</code> 表示</li></ul><p>加上目录后如图:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210813235608778.png"></p><p>为了能够像<code>page directory</code>中访问槽一样的访问, 数据页的目录项, 我们需要将这些目录项在<code>物理存储器</code>上连续存储.这个时候在<code>多页中定位数据的步骤</code>为:</p><ul><li>先从根据二分法快速定位目录项,从而找到记录所在的数据页</li><li>然后去数据页中找数据</li></ul><h3 id="6-2-2-InnoDB中索引方案"><a href="#6-2-2-InnoDB中索引方案" class="headerlink" title="6.2.2 InnoDB中索引方案:"></a>6.2.2 InnoDB中索引方案:</h3><p>上面说到为了快速定位数据页从而给数据页的搞了一个目录项,并且要求目录项在物理存储中是可以连续存放的,但是会出现两个问题:</p><ul><li><code>InnoDB</code>使用页作为管理存储空间的基本单位,即 最多只能保证16KB的连续空间来存放数据. 如果记录数量一旦特别多,所有的目录项连续存储可能会出现问题</li><li>我们可能会经常对数据进行增删改操作,如果某个页面中的数据都删除了,那么该页也没有存在的必要了,就意味着存放目录项的连续空间需要把之后的目录项都向前移动一下.太影响效率</li></ul><p><code>MySQL</code>对于这一问题的解决方案是 复用存储用户记录的数据页来存储目录项,将目录项当成用户记录分页存储(<code>只不过将用户记录换成了只有主键列和页号列的目录项</code>),以保证目录向是连续的,在每一页中同样会按照目录向记录中的主键值进行排列.</p><p>为了区分目录项和用户记录, <code>Mysql</code>将目录项统称为<code>目录项记录</code>,即 在记录头信息中<code>record_type</code>字段的值设置为1.</p><p>将目录项记录存放进数据页中之后,整个结构如图:</p><p> <img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814004524301.png"></p><p><font color="red">目录项记录和用户记录的区别与联系:</font></p><ul><li>区别:<ul><li>目录项记录头的<code>record_type</code>值为1,用户记录记录头的<code>record_type</code>值为0.</li><li>目录记录只有索引列和页编号两列,用户记录可能有多个列(<code>用户自定义列</code>,<code>mysql添加的隐藏列</code>)</li><li>每页目录记录中最小的那一条记录的记录头信息中<code>min_rec_flag</code>字段值为1.用户记录记录头<code>min_rec_flag</code>字段值为0</li></ul></li><li>联系:<ul><li>除了上面几点不同之外,其余的性质并没有区别.使用的是一样的数据页,<code>页面类型都在FILE HEADER中,值为 0x45BF</code>,页的结构也是一样的,主键同样会生成对应的页目录.</li></ul></li></ul><blockquote><p>目录记录的真实数据只会存放两个值, 一个是索引列的值,一个是页码</p></blockquote><p>有了目录项记录的数据页之后,举个查询主键为20的记录的例子,此时查询的过程为:</p><ul><li>在存放<code>目录项记录</code>的数据页中通过<code>页目录</code>定位到具体的目录项记录,然后根据目录项记录中的数据页页码,找到对应存放<code>用户记录</code>的数据页(即9页)</li><li>再到9页中通过<code>页目录</code>定位到主键为20的记录,完成查找.</li></ul><p>一旦目录项多了超出了页面能存放的范围,就会像用户记录一样申请新的数据页来存放目录项,<code>多个存放目录项的数据页的结构如图</code>:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814010439409.png"></p><p>如果存放目录项的数据也变得非常多了,<code>Mysql</code>就会为这些存放目录项的数据页,创建他们对应的目录项,生成一个更高级的目录,以此类推逐渐形成一颗树一样的结构 —- 这就是<code>B+</code>树结构.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814010955356.png"></p><p><strong>B+树,示意图:</strong></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814011024445.png"></p><blockquote><p><code>mysql</code>规定B+树的叶子结点为0层,之后逐渐+1.</p></blockquote><p>假设一个数据页能够存放10条用户记录,所存放目录项记录的数据页能够存放1000条,那么B+树每层存储数据数量为:</p><ul><li>如果B+树只有1层,也就只有1个数据页,那么只能存储100条</li><li>如果B+树有2层,那么记录数为 1000 * 100 = 100,000条</li><li>如果B+树有3层,那么记录数为 1000 * 1000 * 100 = 100,000,000条</li><li>如果B+树有4层,那么记录数为 1000 * 1000 * 1000 * 100 = 100,000,000,000条</li></ul><p>可以发现B+树4层就能够存储很多的数据,<code>mysql</code>在日常使用中B+树的层数是不会超过4层的,也就是只需要去4个数据页(3个目录项数据页,1个用户记录数据页)中就能够找到指定数据(<code>要以主键为条件</code>)</p><h4 id="1-聚簇索引"><a href="#1-聚簇索引" class="headerlink" title="1. 聚簇索引:"></a>1. 聚簇索引:</h4><p>前面介绍的以主键大小来排序的B+树本身就是一个目录,或者本身就是一个索引,具有以下特点:</p><ul><li>使用记录主键值的大小进行记录和页的排序:<ul><li>数据页中的任何记录都是按照主键值的大小顺序排成一个单向链表,页内记录被分成若干组,每个组里中主键值最大的记录的偏移量当做目录存放页<code>页目录</code>的槽里面</li><li>存放记录的数据页也是按照页中记录的主键大小顺序排成一个双向链表</li><li>存放目录记录的数据页分为不同层级,在同一层级的页也是按照页中目录记录的主键大小排成一个双端链表</li></ul></li><li>B+树的叶子结点存放的是 <code>完整的用户记录</code>(完整的用户记录是指: 这个记录中存储了所有列的值,包括隐藏列).</li></ul><p>具有这两个特点的索引就是<code>聚簇索引</code>,<code>InnoDB</code>默认就是聚簇索引.并且在<code>InnoDB</code>中聚簇索引就是数据的存储方式(<code>所有用户数据存放于叶子结点中</code>), 即<code>索引即数据,数据即索引</code></p><h4 id="2-二级索引"><a href="#2-二级索引" class="headerlink" title="2. 二级索引:"></a>2. 二级索引:</h4><p>当我们不以主键为索引创建出来的索引,具有以下特点:</p><ul><li>以普通列x的大小为记录和页的排序依据:<ul><li>页内记录都是按照x值的大小顺序形成单链表,记录被分成多个小组,将组内x值最大的记录的偏移量存放在<code>页目录</code>中.</li><li>每个数据页都是按照x值的大小顺序形成一个双向链表</li><li>存放目录项的数据页都会按照目录项记录中索引列的值大小顺序形成一个双向链表</li></ul></li><li>B+树的叶子结点存放的并不是完整的用户记录,真实的数据部分只有两个值,一个是索引列的值,一个是主键列的值.</li></ul><p>具有以上特点的索引就是 <code>二级索引</code>. <code>二级索引</code>是一个新的B+树,并不是主键形成的B+树,也就是说每个<code>二级索引</code>都是一颗B+树.</p><p><code>二级索引</code>的查找过程:</p><ol><li><p>根据索引值快速定位到索引值所在的非叶子节点,如果该叶子结点没有满足条件的<code>不完整的用户记录</code>,就会沿着双向链表去下一个叶子结点中找是否有满足索引条件的用户记录</p></li><li><p>在非叶子结点中找到了符合条件的用户记录, 就会根据主键值去主键形成的聚簇索引中查找到<code>完整的用户记录</code></p></li><li><p>如果<code>二级索引</code>没有唯一性的约束,那么在主键聚簇索引中找到了一条<code>完整的记录</code>后还要回到<code>二级索引</code>中沿着叶子结点形成的双向链表中继续寻找下一个满足搜索条件的<code>不完整记录</code>,然后再一次去主键聚簇索引中查找,以此往复.</p><blockquote><p>根据<code>二级索引</code>非叶子节点中<code>不完整的用户记录</code>存储的主键值去主键聚簇索引中查找<code>完整用户记录</code>的过程 称为 <code>回表</code>.</p></blockquote></li></ol><h4 id="3-联合索引"><a href="#3-联合索引" class="headerlink" title="3. 联合索引:"></a>3. 联合索引:</h4><p><code>联合索引</code>本质上也就是一个<code>二级索引</code></p><p>处理可以使用单列作为索引,还可以使用多个列作为索引,不过他们之间是有排序优先级的,比如(a,b)这样的联合索引,会先以a为标准排序,如果a相同才会以b为标准进行排序.</p><p>以示例数据来讲: 按照(c2,c3)构成的联合索引,如图</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814015627353.png" alt="联合索引示意图"></p><p>说明:</p><ul><li>联合索引的每条目录项的真实数据部分都包含 c2,c3, 页号这三个数据.</li><li>c2先排序,c2相同再比较c3</li><li>联合索引叶子结点中用户记录的真实数据部分包含 c2,c3 ,主键值这三个数据</li><li>联合索引只会建立一个B+树,而不是创建多个B+树</li></ul><h3 id="6-2-3-B-树索引注意事项"><a href="#6-2-3-B-树索引注意事项" class="headerlink" title="6.2.3 B+树索引注意事项:"></a>6.2.3 B+树索引注意事项:</h3><h4 id="1-根页面永远不动"><a href="#1-根页面永远不动" class="headerlink" title="1. 根页面永远不动:"></a>1. 根页面永远不动:</h4><p>B+树的形成过程:</p><ol><li>为每个表创建B+树索引的时候, 最开是都会创建一个根节点页面.最开始没有数据的时候,根节点页面是什么都没有的</li><li>随后插入数据的过程中,先向根页面中插入数据.</li><li>当根页面中的可用空间使用完了,就会将根节点中所有数据复制到新分配的页面a中,然后对这个新页面进行页分裂作用,得到另一个页面b.然后将新插入数据按照主键值插入到页面a或者页面b中.<code>根结点升级为存储目录项的目录页面</code>.</li></ol><blockquote><p>从整个过程来看,根节点变化的只是页面内的数据,根节点在创建之后页码就不会变化.页号会被记录下来,然后当<code>mysql</code>需要使用这个索引的时候,就会查询出对应索引根节点的页号,然后进行操作.</p></blockquote><h4 id="2-非叶子节点中目录项的唯一性"><a href="#2-非叶子节点中目录项的唯一性" class="headerlink" title="2. 非叶子节点中目录项的唯一性:"></a>2. 非叶子节点中目录项的唯一性:</h4><p>前面简单的将<code>二级索引</code>认为是 <code>索引列 + 页号</code>的搭配,但是会出现下面这个问题:</p><p>以示例数据 c2列为索引的时候,会形成下图所示的索引:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814022636149.png" alt="二级索引不唯一会产生的问题"></p><p>当插入新数据 (9,1,c)的时候, 会发现根节点中所有的目录向索引列的值都是一样的,这样就无法定位新插入数据应该插入页4还是页5.</p><p>实际上<code>二级索引</code>的目录项还是会将<code>主键存储下来</code>,用于处理上面这个问题. 即当索引列相同的时候,比较主键从而决定记录的大小.所有的二级索引都是这样的,哪怕是<code>UNIQUE</code>类型的二级索引,也是这样的(因为<code>UNIQUE列可能出现多个null值</code>,或者多条记录键值相同的情况<code>MVCC</code>)</p><h4 id="3-一个页面至少容纳两条数据"><a href="#3-一个页面至少容纳两条数据" class="headerlink" title="3. 一个页面至少容纳两条数据:"></a>3. 一个页面至少容纳两条数据:</h4><p>主要是为了避免B+树层级增长过高.</p><h3 id="6-2-4-MyISAM索引方案简介"><a href="#6-2-4-MyISAM索引方案简介" class="headerlink" title="6.2.4 MyISAM索引方案简介:"></a>6.2.4 MyISAM索引方案简介:</h3><p>MyISAM的索引方案与InnoDB的索引方案,最大的区别就是</p><ul><li>MyISAM中索引和数据分开存储,即 <code>索引是索引,数据是数据</code></li><li>InnoDB中索引和数据是存储在一起的,即 <code>索引即数据,数据即索引</code></li></ul><p>MyISAM索引方案主要包含两部分:</p><ul><li><p>数据文件: 将表中的记录按照记录插入的顺序单独存储在一个文件中, 这个文件就称为<code>数据文件</code>.</p><p>数据文件并不划分如同<code>InnoDB</code>中数据页一样的结构,而是来多少数据就往数据文件中存多少数据.</p><p>MyISAM中数据在数据文件中是不会按照主键大小顺序排列的,而是按照插入的顺序排列.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/6_B+%E6%A0%91%E7%B4%A2%E5%BC%95/image-20210814112858780.png" alt="MyISAM表中记录排列示意图"></p></li><li><p>索引文件: MyISAM会把索引信息单独存放到一个文件中,这个文件称为<code>索引文件</code>.</p></li><li><p>主键索引: MyISAM会为主键单独创建一个索引,但是主键索引叶子结点中用户记录存放的<code>不再是完整的用户记录</code>,而是主键值与行号</p></li><li><p>非主键索引: MyISAM也可以创建非主键索引,与<code>InnoDB</code>中的二级索引结构差不多.只不过</p><p>在叶子结点中用户记录存放的是 索引列,主键列,记录在数据文件中的行号.</p></li></ul><blockquote><ol><li>叶子结点中记录的是索引列+主键值+被查询数据在数据文件中的行号或者偏移量</li><li>MyISAM的索引全是二级索引包括主键索引, 所以都会去进行一次回表操作,只不过由于索引叶子结点记录的是查询记录在数据文件中的行号,或者是偏移量,所以可以直接定位被查询操作,速度是不需要担心的.</li><li><code>MyISAM</code>中,对于定长记录格式,直接使用行号来标记某条记录在数据文件中的精确位置.对于变长类型记录格式,在叶子结点中使用的是偏移量来精确定位数据文件中的位置.</li></ol></blockquote><h3 id="6-2-5-索引sql"><a href="#6-2-5-索引sql" class="headerlink" title="6.2.5 索引sql:"></a>6.2.5 索引sql:</h3><p>创建索引:</p><ul><li><p>建表的时候同时创建索引:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">`</span>表名<span class="token punctuation">`</span><span class="token punctuation">(</span>列<span class="token punctuation">,</span>    <span class="token punctuation">(</span><span class="token keyword">KEY</span> <span class="token operator">|</span> <span class="token keyword">INDEX</span><span class="token punctuation">)</span> 索引名 <span class="token punctuation">(</span>需要加索引的列<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对已经存在的表,新增索引:</p><pre class="line-numbers language-SQL" data-language="SQL"><code class="language-SQL">-- alter语句ALTER TABLE 表名 ADD (KEY|INDEX) 索引名 (需要加索引的列)-- create语句CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name    [index_type]    ON tbl_name (key_part,...)    [index_option]    [algorithm_option | lock_option] ...  key_part: 需要加索引的列,可以指定排序规则    col_name [(length)] [ASC | DESC]index_option: {    KEY_BLOCK_SIZE [=] value  | index_type  | WITH PARSER parser_name  | COMMENT 'string'}index_type: 索引类型    USING {BTREE | HASH} algorithm_option:    ALGORITHM [=] {DEFAULT | INPLACE | COPY}lock_option:    LOCK [=] {DEFAULT | NONE | SHARED | EXCLUSIVE}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除索引:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">DROP</span> <span class="token punctuation">(</span><span class="token keyword">KEY</span><span class="token operator">|</span><span class="token keyword">INDEX</span><span class="token punctuation">)</span> 索引名<span class="token number">2</span><span class="token punctuation">)</span> 使用 <span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> 语句语法格式：<span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> <span class="token operator">&lt;</span>索引名<span class="token operator">&gt;</span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span>语法说明如下：<span class="token operator">&lt;</span>索引名<span class="token operator">&gt;</span>：要删除的索引名。<span class="token operator">&lt;</span>表名<span class="token operator">&gt;</span>：指定该索引所在的表名。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>修改索引:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 没有直接操作的语法,都是先删除原索引再新增索引</span><span class="token comment">-- 先删除</span><span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token keyword">user</span><span class="token keyword">drop</span> <span class="token keyword">index</span> idx_user_username<span class="token punctuation">;</span><span class="token comment">--再以修改后的内容创建同名索引</span><span class="token keyword">create</span> <span class="token keyword">index</span> idx_user_username <span class="token keyword">ON</span> <span class="token keyword">user</span> <span class="token punctuation">(</span>username<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>索引查看:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> table_name<span class="token punctuation">;</span>纵向查看：<span class="token keyword">show</span> <span class="token keyword">index</span> <span class="token keyword">from</span> table_name\G<span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">show</span> <span class="token keyword">keys</span> <span class="token keyword">from</span> table_name<span class="token punctuation">;</span>纵向查看：<span class="token keyword">show</span> <span class="token keyword">keys</span> <span class="token keyword">from</span> table_name\G<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7 B+树索引的使用</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="7-1-B-树索引示意图的简化"><a href="#7-1-B-树索引示意图的简化" class="headerlink" title="7.1 B+树索引示意图的简化:"></a>7.1 B+树索引示意图的简化:</h2><h3 id="示例数据"><a href="#示例数据" class="headerlink" title="示例数据:"></a>示例数据:</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span><span class="token punctuation">(</span><span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>    key1 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    key2 <span class="token keyword">int</span><span class="token punctuation">,</span>    key3 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    key_part1 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    key_part2 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    key_part3 <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 主键索引(聚簇索引)</span>    <span class="token keyword">key</span> idx_key1 <span class="token punctuation">(</span>key1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 二级索引(唯一索引)</span>    <span class="token keyword">unique</span> uk_key2 <span class="token punctuation">(</span>key2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 二级索引</span>    <span class="token keyword">key</span> idx_key3 <span class="token punctuation">(</span>key3<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">-- 二级索引</span>    <span class="token keyword">key</span> idx_key_part <span class="token punctuation">(</span>key_part1<span class="token punctuation">,</span>key_part2<span class="token punctuation">,</span>key_part3<span class="token punctuation">)</span> <span class="token comment">-- 联合索引</span><span class="token punctuation">)</span><span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">charset</span><span class="token operator">=</span>utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第6章画出了详细的B+树索引结构,现在对索引结构进行简化如下图: <font color="red">里面的数据是假设的</font></p><p><strong>主键索引:</strong> 只画出了叶子结点中的记录真实数据部分</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814183104661.png"></p><p><strong>二级索引:</strong></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814183400595.png"></p><h2 id="7-2-索引的代价"><a href="#7-2-索引的代价" class="headerlink" title="7.2 索引的代价:"></a>7.2 索引的代价:</h2><h3 id="7-2-1-空间代价"><a href="#7-2-1-空间代价" class="headerlink" title="7.2.1 空间代价:"></a>7.2.1 空间代价:</h3><p>每一个索引都是一颗B+树,而B+树的结点都是一个最大为16KB的数据页,如果数据量很大的话,那么会使用很多的数据页来存储B+树的结点.占用空间很多</p><h3 id="7-2-2-时间代价"><a href="#7-2-2-时间代价" class="headerlink" title="7.2.2 时间代价:"></a>7.2.2 时间代价:</h3><ul><li><p>排序代价:</p><p>B+树中,每层结点都是按照索引列值的大小顺序排列形成一个双向链表,数据页中的记录同样是按照索引列值的大小顺序形成一个单向链表.</p><p>当我们在执行写操作的时候,必然会对记录造成修改,从而会影响到数据页中记录和数据页之间的顺序,然后存储引擎就需要去做一些额外的<code>页分裂</code>,<code>页回收</code>等操作.</p><p>如果索引创建过多,这样的时间消耗就很大.</p></li><li><p>索引选择时间消耗代价:</p><p>在执行查询操作的时候,首先会生成一个查询计划,而一般情况下,<code>mysql</code>在执行过程中只会使用一个二级索引,在执行<code>sql</code>语句的时候会去计算不同索引执行查询时所需要的时间,最后选取时间最少的索引执行.</p><p>如果索引过多,就会花很多的时间去分析.</p></li></ul><h1 id="7-3-B-树索引的应用"><a href="#7-3-B-树索引的应用" class="headerlink" title="7.3 B+树索引的应用:"></a>7.3 B+树索引的应用:</h1><h3 id="7-3-1-用于查询"><a href="#7-3-1-用于查询" class="headerlink" title="7.3.1 用于查询:"></a>7.3.1 用于查询:</h3><p>如果想要使用某个索引执行查询,但是又无法通过查询条件形成合适的扫描区间来减少需要扫描的记录数量时,则不考虑是使用这个索引来执行查询</p><p><strong>全表扫描:</strong> </p><ul><li><p>对于某个查询来说简单粗暴的方式就是扫描表中的所有的记录,判断每一条记录是否符合搜索.如果符合,就返回结果,不符合就跳过该条记录.</p></li><li><p>对于<code>InnoDB</code>搜索引擎的表来说,全表扫描就是从聚簇索引中叶子结点第一条记录依次遍历下去,直到最后一条记录</p></li></ul><p><strong>区间扫描:</strong></p><ul><li><p>由于B+树叶子结点中的记录是按照索引列值的大小顺序进行排列的,可以利用B+树查找索引列值等于某个值的第一条记录,向前或者向后的某个区间内进行记录扫描,来减少记录扫描的范围.</p></li><li><p>比如:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> id <span class="token operator">&gt;=</span> <span class="token number">2</span> <span class="token operator">and</span> id <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个语句意义是寻找 id 在区间[2,100]的数据, <code>mysql</code>会通过聚簇索引首先定位id = 2 的用户记录,然后沿着叶子结点向后扫描,直到id &gt; 100.</p><p><code>扫描区间</code>: 在这个<code>select</code>语句中[2,100] 就是扫描区间</p><p><code>边界条件</code>: <code>id &gt;= 2 and id &lt;= 100</code>就是形成扫描区间的边界条件</p><p>对于<code>全表扫描</code>来说,这是一个特殊的<code>区间扫描</code>,因为他扫描的区间涵盖了所有的数据,即 <code>(-∞,+∞)</code>.</p></li><li><p>生成扫描区间的<code>sql</code>举例:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token number">1438</span><span class="token punctuation">,</span><span class="token number">6328</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key2 <span class="token operator">&gt;=</span> <span class="token number">38</span> <span class="token operator">and</span> key2 <span class="token operator">&lt;=</span> <span class="token number">79</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个语句<code>where</code>条件后面使用的key2列,之前的示例数据中,又为key2列创建了索引<code>uk_key2</code>,会形成下面这三个区间:</p><ul><li><p>[1438,1438] : 边界条件是 <code>key2 in (1438)</code> , 这种扫描区间中只有一个值的称为 <code>单点扫描区间</code></p></li><li><p>[6382,6382] : 边界条件是 <code>key2 in (6382)</code></p></li><li><p>[38,79] : 边界条件是 <code>key2 &gt;= 38 and key2 &lt;= 79</code> , 这种扫描区间中含有多个值的区间称为 <code>范围扫描区间</code></p></li><li><p>对应到数轴上就是:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814212755388.png"></p></li></ul></li><li><p>无法生成扫描区间<code>sql</code>举例:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">&lt;</span> <span class="token string">'a'</span> <span class="token operator">and</span> key3 <span class="token operator">&gt;</span> <span class="token string">'z'</span> <span class="token operator">and</span> common_field <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>如果使用<code>idx_key1</code>去查询:</p><p>那么扫描区间为 <code>(-∞,'a')</code>,边界条件是 <code>key1 &lt; 'a'</code>,  key3 &gt; ‘z’ and common_field = ‘abc’ 只是普通搜索条件,普通搜索条件在获取到<code>idx_key1</code>的二级索引记录之后,回表查询获取到完整的用户记录后才能判断是否符合普通搜索条件.</p></li><li><p>如果使用<code>idx_key3</code>去查询:</p><p>那么扫描区将为<code>('z',+∞)</code>,边界条件是 <code>key3 &gt; 'z'</code>, 普通条件 key1 &lt; ‘a’ and common_field = ‘abc’. </p></li></ul></li></ul><p><strong>如何产生扫描区间:</strong></p><p>对于B+索引,只要索引列 和 常量 使用 <code>=</code>, <code>&lt;=&gt;</code>,<code>IN</code>, <code>NOT IN</code>, <code>IS NULL</code>, <code>IS NOT NULL</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&lt;&gt;</code>, <code>BETWEEN</code>, <code>LIKE</code>连接起来就能产生扫描区间.</p><p>注意:</p><ul><li><p><code>IN</code> 的语义 和 若干个等值匹配操作之间使用 <code>OR</code> 连接起来是一样的</p></li><li><p><code>!=(&lt;&gt;)</code>产生 的扫描区间比较特殊:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 生成的扫描区间为: (-∞,'a') ∪ ('a',+∞)</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">!=</span> <span class="token string">'a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>LIKE</code>操作只有在完全匹配和前缀匹配才能产生扫描区间</p></li></ul><p><strong>如何从若干个OR或者AND连接的语句之间提取扫描区间:</strong></p><h5 id="1-所有查询条件都可以生成合适的扫描区间"><a href="#1-所有查询条件都可以生成合适的扫描区间" class="headerlink" title="1. 所有查询条件都可以生成合适的扫描区间:"></a>1. 所有查询条件都可以生成合适的扫描区间:</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">and</span> key2 <span class="token operator">&gt;</span> <span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的扫描区间为:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814221320446.png"></p><blockquote><p>and连接的查询条件是对两个扫描区间取交集</p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">or</span> key2 <span class="token operator">&gt;</span> <span class="token number">200</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>生成的扫描区间为:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814221405324.png"></p><blockquote><p>or连接的查询条件是对两个扫描区间取并集</p></blockquote><h5 id="2-部分查询条件能够生成扫描区间"><a href="#2-部分查询条件能够生成扫描区间" class="headerlink" title="2. 部分查询条件能够生成扫描区间:"></a>2. 部分查询条件能够生成扫描区间:</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">and</span> common_field <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果使用<code>uk_key2</code>索引进行查询:</p><ul><li>查询条件<code>key2 &gt; 100</code>生成的扫描范围是 (100,+∞)</li><li>查询条件<code>common_field = 'abc'</code>由于<code>uk_key2</code>索引中的二级索引记录根本就不按照<code>common_field列</code>进行排列所以这个查询条件根本就不能使扫描范围减小.也就是产生的扫描范围是: <code>(-∞,+∞)</code>.</li><li>最终产生的扫描范围是 (100,+∞)</li></ul><p>如果将sql中<code>and</code>连接换成<code>or</code>连接,产生的扫描范围是 (-∞,+∞)</p><h5 id="3-复杂查询条件中找出扫描范围"><a href="#3-复杂查询条件中找出扫描范围" class="headerlink" title="3. 复杂查询条件中找出扫描范围:"></a>3. 复杂查询条件中找出扫描范围:</h5><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'xyz'</span> <span class="token operator">and</span> key2 <span class="token operator">=</span> <span class="token number">738</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">&lt;</span> <span class="token string">'abc'</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'lmn'</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">like</span> <span class="token string">'%suf'</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'zzz'</span> <span class="token operator">and</span> <span class="token punctuation">(</span>key2 <span class="token operator">&lt;</span> <span class="token number">8000</span> <span class="token operator">or</span> common_field <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>分析思路:</p><ul><li><p>找出where中使用了哪些列,以及表中创建了哪些索引.</p><p>在这个sql中查询条件使用了 key1,key2,common_field列,key1列有<code>idx_key1</code>,key2列有<code>uk_key2</code>.</p></li><li><p>将可能使用到的索引进行假设,分析他们的扫描区间</p></li></ul><p><strong>假设使用<code>idx_key1</code>索引:</strong></p><p>首先分析哪些搜索条件是不能产生扫描范围的:</p><p>比如上面的sql,<code>key2 = 738</code>, <code>key2 &lt; 8000</code>, <code>common_field = 'abc'</code>以及<code>key1 like '%suf'</code>是不能产生扫描范围的,直接将他们替换成<code>true</code>,则sql为:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'xyz'</span> <span class="token operator">and</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">&lt;</span> <span class="token string">'abc'</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'lmn'</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'zzz'</span> <span class="token operator">and</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- 简化:</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'xyz'</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">&lt;</span> <span class="token string">'abc'</span> <span class="token operator">and</span> key1 <span class="token operator">&gt;</span> <span class="token string">'lmn'</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'zzz'</span><span class="token punctuation">)</span> <span class="token comment">-- key1 &lt; 'abc' and key1 &gt; 'lmn'永远是false</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'xyz'</span><span class="token punctuation">)</span> <span class="token operator">or</span>  <span class="token punctuation">(</span>key1 <span class="token operator">&gt;</span> <span class="token string">'zzz'</span><span class="token punctuation">)</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为’xyz’ &lt; ‘zzz’ , 又是使用or连接, 取二者之间的并集, 所以产生的扫描范围是: (‘xyz’,+∞)</p><p><strong>假设使用<code>uk_key2</code>索引:</strong></p><p>替换掉不能差生扫描范围的查询条件之后sql为:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">and</span> key2 <span class="token operator">=</span> <span class="token number">738</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">and</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">or</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">and</span> <span class="token boolean">true</span> <span class="token operator">and</span> <span class="token punctuation">(</span>key2 <span class="token operator">&lt;</span> <span class="token number">8000</span> <span class="token operator">or</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- key2 &lt; 8000 or true 一定为true</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> single_table <span class="token keyword">where</span> key2 <span class="token operator">=</span> <span class="token number">738</span> <span class="token operator">or</span> <span class="token boolean">true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为查询条件恒成立,那么就是个全表扫描,扫描范围是: (-∞,+∞).但是使用了二级索引,比主键全表扫描还多了一次回表操作,所以显然不适合使用<code>uk_key2</code>作为查询索引</p><h5 id="4-使用联合索引执行查询索引时的扫描范围"><a href="#4-使用联合索引执行查询索引时的扫描范围" class="headerlink" title="4. 使用联合索引执行查询索引时的扫描范围:"></a>4. 使用联合索引执行查询索引时的扫描范围:</h5><p>联合索引的排序规则:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">key</span> idx_key_part <span class="token punctuation">(</span>key_part1<span class="token punctuation">,</span>key_part2<span class="token punctuation">,</span>key_part3<span class="token punctuation">)</span> <span class="token comment">-- 联合索引</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上面这个索引为例:</p><ul><li>先对<code>key_part1</code>列的值进行排序</li><li><code>key_part1</code>相同,再根据<code>key_part2</code>列的值进行排序</li><li><code>key_part1</code>和<code>key_part2</code>列的值都相同的情况下,再使用<code>key_part3</code>列的值进行排序</li></ul><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210814233953955.png"></p><p>举例</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用联合索引确定的扫描范围为 <code>['a','a']</code>,扫描边界为<code>key_part = 'a'</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part2 <span class="token operator">=</span> <span class="token string">'b'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用联合索引确定的扫描范围为 <code>[('a','b'),('a','b')]</code>,扫描边界为<code>key_part1 = 'a' and key_part2 = 'b'</code>.</p><p><code>[('a','b'),('a','b')]</code>表示: 在<code>idx_key_part</code>索引中,从第一条满足边界条件,到最后一条满足边界条件为止的所有二级索引记录</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part2 <span class="token operator">=</span> <span class="token string">'b'</span> <span class="token operator">and</span> key_part3 <span class="token operator">=</span> <span class="token string">'c'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 使用联合索引确定的扫描范围为 <code>[('a','b','c'),('a','b','c')]</code>,扫描边界为<code>key_part1 = 'a' and key_part2 = 'b' and key_part3 = 'c'</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">&lt;</span> <span class="token string">'a'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 使用联合索引确定的扫描范围为 <code>(-∞,'a')</code>,扫描边界为<code>key_part1 = 'a' and key_part2 = 'b' and key_part3 = 'c'</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part2 <span class="token operator">&gt;</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part2 <span class="token operator">&lt;</span> <span class="token string">'d'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 使用联合索引确定的扫描范围为 <code>(('a','a'),('a','d'))</code>,扫描边界为<code>key_part1 = 'a' and key_part2 &gt; 'a' and key_part2 &lt; 'd'</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part2 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为联合索引排序优先级第一位的并不是<code>key_part2</code>列,所以无法减少扫描范围,因此这条sql不适合使用<code>idx_key_part</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part3 <span class="token operator">=</span> <span class="token string">'c'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条sql能够通过<code>key_part1 = 'a'</code>减少扫描范围,但是由于<code>key_part='a'</code>之后是按照<code>key_part2</code>列的值大小顺序排列的,所以<code>key_part3 = 'c'</code>并不能减少扫描范围.</p><p>所以实际得到的扫描范围是: <code>['a','a']</code>.边界条件是 <code>key_part1 = 'a'</code></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">&lt;</span> <span class="token string">'b'</span> <span class="token operator">and</span> key_part2 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个比较特殊,先看下叶子结点中二级索引的排列, 如果数据为红字的情况就会造成 <code>key_part1 &lt; 3 and key_part2 = 2</code>的查询条件,在使用符合索引的时候,只走key_part1,而不走key_part2,这是因为在<code>key_part1 &lt; 3</code>的前提下二级索引记录根本不是按照<code>key_part2</code>列的值排列的.</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/7_B+%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/image-20210815001847253.png"></p><p>所以实际上对扫描范围起到作用的只有查询条件<code>key_part1 &lt; 'b'</code>.扫描范围为: <code>[-∞,'b')</code>.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part1 <span class="token operator">&lt;=</span> <span class="token string">'b'</span> <span class="token operator">and</span> key_part2 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这条sql跟上面那条sql基本上是一个意思,但是在<code>key_part1 = 'b'</code>的时候,二级索引是按照<code>key_part2</code>值的顺序进行排列的,但是在<code>key_part1 &lt; 'b'</code>的时候,<code>key_part2</code>仍然是起不到作用的.生成的扫描范围是:</p><ul><li><p><code>[-∞,'b')</code>,边界条件: <code>key_part1 &lt; 'b'</code></p></li><li><p><code>[('b','a'),('b','a')]</code>,边界条件: <code>key_part1 = 'b' and key_part2 = 'a'</code></p></li></ul><p>两个扫描范围求并集: <code>((-∞,-∞),('b','a'))</code></p><h3 id="7-3-2-用于排序"><a href="#7-3-2-用于排序" class="headerlink" title="7.3.2 用于排序:"></a>7.3.2 用于排序:</h3><p>由于查询出来的数据不一定是按照我们需要的顺序进行排序的,就需要对数据进行重新排序,<code>mysql</code>中通常是将记录加载到内存中,通过排序算法进行排序操作,如果记录太多甚至还会借助磁盘空间来存放排序结果,在排序操作完成后再把排好序的结果返回给客户端.</p><p><code>文件排序(filesort)</code>: 在内存或者磁盘中进行排序的方式统称为文件排序.文件排序会影响查询速度.</p><blockquote><p> 如果<code>order by</code>后面的字段加上了索引,就可以避免<code>filesort</code></p></blockquote><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">order</span> <span class="token keyword">by</span> key_part1<span class="token punctuation">,</span>key_part2<span class="token punctuation">,</span>key_part3 <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于二级索引中索引记录本身就是按照索引列进行排列的,也就是说数据本身就是按照<code>order by</code>后面的顺序排列的自然无序再次进行额外的排序.</p><h4 id="1-使用索引进行排序时的注意事项"><a href="#1-使用索引进行排序时的注意事项" class="headerlink" title="1. 使用索引进行排序时的注意事项:"></a>1. 使用索引进行排序时的注意事项:</h4><ul><li><p>如果要想使用联合索引优化排序过程,那么必须要将<code>order by</code>后面排序列的顺序按照联合索引声明的顺序.</p></li><li><p>使用联合索引进行排序的时候,可以使用部分联合索引进行排序,比如: (part1,part2,part3),只使用<code>part1</code>,或者<code>part1,part2</code>进行排序,用来排序的列一定要是从左边开始连续的</p></li><li><p>如果使用联合索引进行排序时,查询条件是联合索引从左开始并且连续的常量,那么就可以使用剩下的索引进行排序,比如:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key_part <span class="token operator">=</span> <span class="token string">'a'</span> <span class="token operator">and</span> key_part <span class="token operator">=</span> <span class="token string">'b'</span> <span class="token keyword">order</span> <span class="token keyword">by</span> key_part3 <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询结果已经按照<code>key_part1</code>,<code>key_part2</code>的顺序排列好了,按照联合索引的排列规则,数据实际上已经按照<code>key_part3</code>排列好了,使用<code>order by key_part3</code>进行排序自然不需要额外的排序.</p></li></ul><h4 id="2-无法使用索引进行排序的情况"><a href="#2-无法使用索引进行排序的情况" class="headerlink" title="2. 无法使用索引进行排序的情况:"></a>2. 无法使用索引进行排序的情况:</h4><ol><li><p>排序规则(ASC,DESC)混用:</p><p>使用联合索引进行排序,要求各排序列的排序规则是一致的,即 <code>要么都是ASC,或者要么都是DESC</code>.</p></li><li><p>排序列包不是同一个索引:</p></li><li><p>排序列在同一个索引中,但是不是按照声明的顺序连续出现:</p></li><li><p>用来形成扫描区间的索引列和排序列不同:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">=</span> <span class="token number">2</span> <span class="token keyword">order</span> <span class="token keyword">by</span> key2 <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>排序列不是以单独列名的形式出现在order by 语句中:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">order</span> <span class="token keyword">by</span> UPPER<span class="token punctuation">(</span>key1<span class="token punctuation">)</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结:"></a>3. 总结:</h4><p>将索引用于排序,主要是利用索引中的数据都是按照索引列值顺序排列好了的,不需要在进行额外的排序,这一特点.</p><h3 id="7-3-3-索引用于分组"><a href="#7-3-3-索引用于分组" class="headerlink" title="7.3.3 索引用于分组:"></a>7.3.3 索引用于分组:</h3><p>规则与用于排序差不多,分组列必须与索引列的顺序一致,也只能使用索引列中左边连续的列进行分组.</p><h2 id="7-4-回表的代价"><a href="#7-4-回表的代价" class="headerlink" title="7.4 回表的代价:"></a>7.4 回表的代价:</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">&gt;</span> <span class="token string">'a'</span> <span class="token operator">and</span> key1 <span class="token operator">&lt;</span> <span class="token string">'c'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>全表扫描:</p><p>扫描全部的聚簇索引,然后逐一对聚簇索引记录进行条件判断,不满足就跳过,满足就返回给客户端</p></li><li><p>使用<code>idx_key1</code>索引进行查询:</p><p>在使用<code>idx_key1</code>索引进行查询时 将数据扫描的范围缩小到了(‘a’,’c’)之间, 但是由于查询的是用户记录所有的列,而二级索引记录中只存放了索引列和主键值,所以必须要根据主键值进行重新去聚簇索引中查询(回表).</p><p><code>Mysql</code>中使用页作为空间管理的基本单位,对于<code>InnoDB</code>引擎的表,索引中的数据页必须是存放在磁盘中的,在需要的时候通过页号对应数据页在磁盘中的偏移量加载到内存中来.<code>Mysql</code>会尽量保证数据页是按照页号顺序进行排列的,因此一次磁盘I/O就可以加载很多的二级索引记录到内存中,扫描二级索引记录的代价就不会太大.</p><p>但是在执行回表操作的时候,二级索引记录中存储的主键值是丝毫没有顺序的,极端的情况下,扫描区间中的二级索引记录有n条,主键值存在对应的数据页就有n页,因此可能要执行n次磁盘i/0.磁盘i/o的时间消耗是特别大的</p><p><code>mysql</code>在执行查询的时候,首先会进行查询语句的优化,查询优化器会对表中的记录事先进行一些计算,通过计算出来的统计数据,或者访问少量的记录来获得查询时的回表数量,如果回表数量特别多,就选择<code>全表扫描</code>,否则选择索引.</p><blockquote><p>为了避免全表扫描:</p><ol><li>通过<code>limit</code>减少返回的数量,从而减少回表次数,让查询走索引</li><li>通过<code>limit</code>减少返回的数量,也可以让排序使用索引</li></ol></blockquote></li></ul><h2 id="7-5-更好的创建和使用索引"><a href="#7-5-更好的创建和使用索引" class="headerlink" title="7.5 更好的创建和使用索引:"></a>7.5 更好的创建和使用索引:</h2><h3 id="7-5-1-只为查询-排序-分组列创建索引"><a href="#7-5-1-只为查询-排序-分组列创建索引" class="headerlink" title="7.5.1 只为查询,排序,分组列创建索引:"></a>7.5.1 只为查询,排序,分组列创建索引:</h3><p>通常只会为<code>where</code>字句中的列,连接字句中的连接列,分组列或者排序列创建索引.</p><p>只出现在查询列表中的列就没有必要创建索引了,比如: </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> common_field<span class="token punctuation">,</span> key_part4 <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个sql中<code>common_field</code>,<code>key_part4</code>就没有必要创建索引了.</p><h3 id="7-5-2-考虑索引列值不重复的数量"><a href="#7-5-2-考虑索引列值不重复的数量" class="headerlink" title="7.5.2 考虑索引列值不重复的数量:"></a>7.5.2 考虑索引列值不重复的数量:</h3><p>如果索引列重复值太多,那么在通过该索引进行查询的时候,一个常量查询条件都有可能有很多条,这样会造成大量的回表操作,从而导致效率不如全表扫描.</p><p>如果想要加索引的列,值重复数率太高就不要给他加索引了.</p><h3 id="7-5-3-索引列尽量选择占用空间小的类型"><a href="#7-5-3-索引列尽量选择占用空间小的类型" class="headerlink" title="7.5.3 索引列尽量选择占用空间小的类型:"></a>7.5.3 索引列尽量选择占用空间小的类型:</h3><p><code>mysql</code>都是以页为单位进行磁盘I/O加载数据的,如果数据类型占用的空间越小,一页中存放的记录数就越多.<code>在取值范围允许的情况下</code>,索引列尽量选择占用空间小的类型</p><p><font color="red">尤其是主键列,主键列不仅仅是聚簇索引中会记录主键值,所有的二级索引记录都会保存主键值,因此主键列更应该选择占用空间小的类型</font></p><h3 id="7-5-4-为列前缀建立索引"><a href="#7-5-4-为列前缀建立索引" class="headerlink" title="7.5.4 为列前缀建立索引:"></a>7.5.4 为列前缀建立索引:</h3><p>处于减少二级索引记录中存放索引值长度,从而增加数据页中存放索引的数量,减少磁盘I/O的目的,可以列值前缀建立索引.</p><p>比如:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 先删除在重新创建索引</span><span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">drop</span> <span class="token keyword">index</span> idx_key1<span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">add</span> <span class="token keyword">index</span> idx_key1<span class="token punctuation">(</span>key1<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>因为索引列值的字符串前缀实际上也是排好序的,所以可以在二级索引记录中只保留字符串前面几个字符.根据字符串前缀定位出二级索引记录中以索引值为前缀的记录,然后在判断他是否完整的匹配查询条件.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">=</span> <span class="token string">'abcdefghijklmn'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>首先会定位出以<code>abcdefghij</code>为前缀的二级索引记录,然后判断他们是否完全匹配<code>abcdefghijklmn</code></p><p><font color="red">这种索引无法用于排序.排序对于字符串比较的是整个字符串的全部字符,但是这种二级索引只是按照字符串的前面几个字符排好顺序</font></p><h3 id="7-5-5-覆盖索引"><a href="#7-5-5-覆盖索引" class="headerlink" title="7.5.5 覆盖索引:"></a>7.5.5 覆盖索引:</h3><p><code>覆盖索引</code>: 查询列表中的列包含在索引中,就称这种查询方式为 覆盖索引.</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> key1<span class="token punctuation">,</span>id <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key1 <span class="token operator">=</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>通过<code>idx_key1</code>进行查询的时候,二级索引记录中包含了 <code>key1</code>,<code>id</code>这两列的值,所以在定位到叶子结点中的二级索引记录时就获取到了查询结果,无需进行回表操作.</p><h3 id="7-5-6-索引列名单独出现在查询条件中"><a href="#7-5-6-索引列名单独出现在查询条件中" class="headerlink" title="7.5.6 索引列名单独出现在查询条件中:"></a>7.5.6 索引列名单独出现在查询条件中:</h3><p>单独出现的意思是: 不要让索引列在查询条件中参与运算</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 不走索引:</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token comment">-- 走索引:</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">`</span>single_table<span class="token punctuation">`</span> <span class="token keyword">where</span> key2 <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token operator">/</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>sql 1 会被<code>mysql</code>认为 key2*2 是一个列,从而不会走<code>idx_key2</code></p><h3 id="7-5-7-新插入记录时主键大小对效率的影响"><a href="#7-5-7-新插入记录时主键大小对效率的影响" class="headerlink" title="7.5.7 新插入记录时主键大小对效率的影响:"></a>7.5.7 新插入记录时主键大小对效率的影响:</h3><p>主键值大小(新插入数据的主键值)对插入效率的影响,主要问题出现在无序插入,如果插入时刚好要插入的数据页满了,待插入记录的主键值又恰好位于该数据页的中间,就会造成页分裂,从而导致插入效率降低.</p><h3 id="7-5-8-冗余和重复索引"><a href="#7-5-8-冗余和重复索引" class="headerlink" title="7.5.8 冗余和重复索引:"></a>7.5.8 冗余和重复索引:</h3><p>尽量避免冗余和重复的索引,比如不要对联合索引包含的索引再创建单独的索引</p>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2 重要系统变量</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/2_%E9%87%8D%E8%A6%81%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/2_%E9%87%8D%E8%A6%81%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="2-1-启动选项和配置文件"><a href="#2-1-启动选项和配置文件" class="headerlink" title="2.1 启动选项和配置文件"></a>2.1 启动选项和配置文件</h2><p>任何程序都可以通过配置文件和程序启动参数设置该程序在运行的时候的一些默认值和必要参数的值.</p><h3 id="2-1-1-在命令行上使用选项"><a href="#2-1-1-在命令行上使用选项" class="headerlink" title="2.1.1  在命令行上使用选项:"></a>2.1.1  在命令行上使用选项:</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 在启动的时候使用选项的通用格式:</span>可执行文件 --启动选项1<span class="token punctuation">[</span><span class="token operator">=</span>值1<span class="token punctuation">]</span> --启动选项2<span class="token punctuation">[</span><span class="token operator">=</span>值2<span class="token punctuation">]</span> --启动选项3<span class="token punctuation">[</span><span class="token operator">=</span>值3<span class="token punctuation">]</span> <span class="token punctuation">..</span>. --启动选项n<span class="token punctuation">[</span><span class="token operator">=</span>值n<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在命令行中,可以将各个启动选项写到一行里面,每个启动选项使用<code>--</code>表示开始,选项之间使用空格分开.</p><p><strong>选项的长形式和短形式</strong>: <code>--</code>为参数的长形式,<code>MYSQL</code>对于某些常用的参数提供了短形式<code>-</code>,比如: <code>mysql -p</code>启动的时候确定要连接的服务器端</p><p><strong>注意事项:</strong></p><ol><li>在命令行中指定选项值得时候需要注意, <code>选项名</code>、<code>=</code>和<code>值</code>这三者之间是不能有空格的.</li><li>长形式和短形式之间的区别是: 长形式前缀为 <code>--</code>,短形式为 <code>-</code>;长形式的选项名是单词,短形式的选项名是字母</li><li>选项名是区分大小写的: <code>-p</code> — 表示密码 和<code>-P</code> — 表示端口号 这两个之间是不一样的.</li><li><code>可执行文件 --help</code>: 可以看到该可执行文件支持的启动选项</li></ol><h3 id="2-1-2-配置文件中使用选项"><a href="#2-1-2-配置文件中使用选项" class="headerlink" title="2.1.2 配置文件中使用选项:"></a>2.1.2 配置文件中使用选项:</h3><p><font color="red">推荐使用选项的方式.</font></p><ol><li><p>配置文件的路径:</p><p><code>mysql</code>会从多个路径下面的配置文件去寻找相关配置信息.<code>unix系统</code>下的配置文件路径为:</p><table><thead><tr><th>/etc/my.cnf</th><th></th></tr></thead><tbody><tr><td>/etc/mysql/my.cnf</td><td></td></tr><tr><td>SYSCONFDIR/my.cnf</td><td></td></tr><tr><td>#MYSQL_HOME/my.cnf</td><td>特定服务器的悬系那个(仅限服务器)</td></tr><tr><td>defaults-extra-file</td><td>命令行指定的额外配置文件路径</td></tr><tr><td>~/.my.cnf</td><td>特定于用户的选项</td></tr><tr><td>~/.mylogin.cnf</td><td>特定于用户的登录路径选项(仅限客户端)</td></tr></tbody></table><p>说明:</p><ul><li>SYSCONFDIR: 表示使用CMake构建MySQL时使用SYSCONFDIR选项指定的目录</li><li>MYSQL_HOME: 就是配置好的系统环境变量.</li><li>除了<code>.mylogin,cnf</code>(只能存放客户端的一些选项), <code>$MYSQL_HOME/my.cnf</code>(只能存放服务器相关选项)外,其余配置文件即可以存放客户端,也可以存放服务器相关的选项.</li><li><code>~</code>: 表示当前用户目录,<code>unix系统</code>的概念</li><li><code>default-extra-file</code>: 表示程序启动的时候可以通过指定<code>default-extra-file</code>启动选项的值来添加额外的配置文件路径</li><li><code>.mylogin.cnf</code>是一个特殊的配置文件,私有<code>mysql_config_editor</code>实用程序创建的加密文件.该文件只能包含一些在启动客户端程序时用于连接服务器的选项.</li></ul></li><li><p>配置文件的内容:</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">[mysqld](具体的启动选项....)[client](具体的启动选项....)[mysql](具体的启动选项....)[mysqld]<span class="token comment"># binlog 配置</span><span class="token attr-name">log-bin</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql/logs/mysql-bin.log</span><span class="token attr-name">expire-logs-days</span><span class="token punctuation">=</span><span class="token attr-value">14</span><span class="token attr-name">max-binlog-size</span><span class="token punctuation">=</span><span class="token attr-value">500M</span><span class="token attr-name">server-id</span><span class="token punctuation">=</span><span class="token attr-value">1</span><span class="token comment"># GENERAL</span><span class="token attr-name">basedir</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql</span><span class="token attr-name">datadir</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql/data</span><span class="token attr-name">socket</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql/mysql.sock</span><span class="token attr-name">user</span><span class="token punctuation">=</span><span class="token attr-value">mysql</span><span class="token attr-name">default-storage-engine</span><span class="token punctuation">=</span><span class="token attr-value">InnoDB</span><span class="token attr-name">character-set-server</span><span class="token punctuation">=</span><span class="token attr-value">utf8</span><span class="token attr-name">lower_case_table_names</span> <span class="token punctuation">=</span> <span class="token attr-value">1</span><span class="token attr-name">explicit_defaults_for_timestamp</span><span class="token punctuation">=</span><span class="token attr-value">true</span>[mysqld_safe]<span class="token attr-name">log-error</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql/mysql-error.log</span><span class="token attr-name">pid-file</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql/mysqld.pid</span>[client]<span class="token attr-name">socket</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql/mysql.sock</span>[mysql]<span class="token attr-name">default-character-set</span><span class="token punctuation">=</span><span class="token attr-value">utf8</span><span class="token attr-name">socket</span><span class="token punctuation">=</span><span class="token attr-value">/usr/local/mysql/mysql.sock</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>说明:</p><ul><li><p>配置文件只能使用长形式的选项来设置,且<code>不能使用--前缀</code></p></li><li><p><code>选项</code>、<code>=</code>和<code>值</code>之间不能有空格</p></li><li><p><code>[]</code>: 表示一个选项组,名称和可执行文件相对应,特别地:</p><ul><li><code>[server]</code>: 下面的启动选项将作用于所有的服务器程序</li><li><code>[client]</code>: 下面的启动选项将作用于所有的客户端程序</li></ul></li><li><p>程序对应类别和能读取的选项组:</p><table><thead><tr><th>程序名</th><th>类别</th><th>能读取的组</th></tr></thead><tbody><tr><td>mysqld</td><td>服务器程序</td><td>[mysqld]  [server]</td></tr><tr><td>mysqld_safe</td><td>服务器程序</td><td>[mysqld] [server] [mysqld_safe]</td></tr><tr><td>mysql.server</td><td>服务器程序</td><td>[mysqld] [server] [mysql.server]</td></tr><tr><td>mysql</td><td>客户端程序</td><td>[mysql] [client]</td></tr><tr><td>mysqladmin</td><td>客户端程序</td><td>[mysqladmin] [client]</td></tr><tr><td>mysqldump</td><td>客户端程序</td><td>[mysqldump] [client]</td></tr></tbody></table></li></ul></li></ol><p>   配置文件设置系统变量举例:</p>   <pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">[server]skiping-networking<span class="token attr-name">default-storage-engine</span><span class="token punctuation">=</span><span class="token attr-value">MyISAM</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>   配置文件,如上,然后通过 <code>mysqld</code>启动服务器:</p><p>   虽然在启动的时候,并没有设置任何的启动项,但是<code>mysql</code>会去默认路径下面读取相关的配置文件,上面的这个配置文件就会被读取出来,并且<code>mysqld</code>是可以读取<code>[server]</code>组下面的配置的.所以上面两个配置通过<code>mysqld</code>是可以生效的.</p><p>   <font color="red">如果上面配置文件中的<code>[server]</code>改成<code>[client]</code>,那么设置的启动项是不会生效的</font></p><ol start="3"><li><p>特定<code>mysql</code>版本的专用选项组:</p><p>在具体的选项组上面加上<code>mysql</code>的版本号,就可以让该选项组只能被对应<code>mysql</code>版本的可执行文件才能读取到.</p><p>比如: <code>[mysqld-5.7] </code>就只能由5.7版本的<code>mysql</code>中的可执行文件 <code>mysqld</code>读取到</p></li><li><p>配置文件的优先级:</p><p>如果创建了多个配置文件,配置文件将按照下图从上到下的顺序依次读取配置文件:</p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/2_%E9%87%8D%E8%A6%81%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F/image-20210807171454760.png"></p><p><font color="red">注意: 如果不同的配置文件中设置了相同的配置项,那么后面加载的配置文件中的配置项,会将先加载的配置文件中的配置项覆盖.即<code>多个配置文件,相同配置,以最后加载的为准</code></font></p></li><li><p>同一个配置文件中多个组的优先级:</p><p>在同一个配置文件中,可执行文件会从上到下依次读取多个组的配置文件,如果多个组中存在相同的配置项,以后面读取到的配置项为准.</p></li><li><p>default-file的使用:</p><p>default-file: 在程序启动的时候指定配置文件的加载路径,<font color="red">注意: default-file指定了之后,就只会从指定的文件路径中去加载配置,程序不再去默认的配置文件加载配置</font></p><p>default-extra-file: 在程序启动的时候指定配置文件<code>额外</code>的加载路径,<font color="red">注意: default-extra-file指定的是额外的配置文件路径,也就是说程序还是会去默认的配置文件路径加载配置</font></p></li><li><p>命令行和配置文件中启动选项的区别:</p><p>除了部分专门为<code>命令行</code>设计的启动选项外,大部分启动选项都可以写入配置文件中.如果 命令行和配置文件出现了相同的配置项,那么以<code>命令行中的配置项为准</code></p></li></ol><h2 id="2-2-系统变量"><a href="#2-2-系统变量" class="headerlink" title="2.2 系统变量:"></a>2.2 系统变量:</h2><p>一些会影响<code>mysql</code>程序行为的变量,被称为<code>系统变量</code>.</p><p>比如: </p><ul><li><code>max_connects:</code> 控制同时连接的客户端数量</li><li><code>default_storage_engine:</code>控制表的默认存储引擎</li><li><code>query_cache_size:</code>控制查询缓存的默认大小</li></ul><h3 id="2-2-1-查看系统变量"><a href="#2-2-1-查看系统变量" class="headerlink" title="2.2.1 查看系统变量:"></a>2.2.1 查看系统变量:</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 建议使用模糊匹配去查询需要的系统变量</span><span class="token keyword">show</span> variables <span class="token punctuation">[</span>liske 匹配的模式<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-2-2-设置系统变量"><a href="#2-2-2-设置系统变量" class="headerlink" title="2.2.2 设置系统变量:"></a>2.2.2 设置系统变量:</h3><h4 id="1-通过启动项设置"><a href="#1-通过启动项设置" class="headerlink" title="1. 通过启动项设置:"></a>1. 通过启动项设置:</h4><ul><li><p>通过命令行设置系统变量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqld --default-storage-engine<span class="token operator">=</span>MyISAM --max-connections<span class="token operator">=</span><span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>通过配置文件设置系统变量:</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties">[server]<span class="token attr-name">default-storage-engine</span><span class="token punctuation">=</span><span class="token attr-value">InnoDB</span><span class="token attr-name">max_connections</span><span class="token punctuation">=</span><span class="token attr-value">1000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="2-服务器程序运行过程中设置"><a href="#2-服务器程序运行过程中设置" class="headerlink" title="2. 服务器程序运行过程中设置:"></a>2. 服务器程序运行过程中设置:</h4><p>在服务器程序运行过程中可以动态修改变量而且无需停止并启动服务器.</p><p><strong>系统变量的作用范围:</strong></p><p><code>GLOBAL(全局范围)</code>: 影响服务器的整体操作.具有<code>GLOBAL</code>作用范围的系统变量可以称为全局变量</p><p><code>SESSION(会话范围)</code>: 影响某个客户端链接的操作.具有<code>SESSION</code>作用范围的变量可以称为会话变量</p><p><strong>系统变量初始化的过程</strong></p><ol><li><p>服务器在启动的时候,会将每个全局变量按照配置设置全局变量的默认值.</p></li><li><p>客户端连接到服务器,服务器会为每个连接维护一组会话变量,初始值为同名的全局变量的值,(有部分的特殊会话变量不会按照全局变量的值进行初始化)</p></li></ol><p>举个例子: 以默认存储引擎为例</p><ol><li><p>服务器启动,会将<code>default-storage-engine</code>按照配置设置成为一个作用范围为<code>GLOBAL</code>的全局变量.</p></li><li><p>之后,每一个客户端成功连接,服务器都会为其分配一个名字为 <code>default-storage-engine</code>,作用范围为<code>SESSION</code>的会话变量,且这个会话变量的初始值为 <code>作用范围为GLOBAL的同名全局变量的值</code></p></li></ol><p><strong>设置系统变量:</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">set</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">]</span> 系统变量名 <span class="token operator">=</span> 值<span class="token keyword">set</span> <span class="token punctuation">[</span>@@<span class="token punctuation">(</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">]</span>系统变量名 <span class="token operator">=</span> 值<span class="token comment">-- 设置全局默认存储引擎:</span><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> <span class="token keyword">default</span><span class="token operator">-</span>storage<span class="token operator">-</span><span class="token keyword">engine</span> <span class="token operator">=</span> MyISAM<span class="token keyword">SET</span> @<span class="token variable">@GLOBAL.default</span><span class="token operator">-</span>storage<span class="token operator">-</span><span class="token keyword">engine</span> <span class="token operator">=</span> MyISAM<span class="token comment">-- 设置当前会话默认存储引擎</span><span class="token keyword">SET</span> <span class="token keyword">GLOBAL</span> <span class="token keyword">default</span><span class="token operator">-</span>storage<span class="token operator">-</span><span class="token keyword">engine</span> <span class="token operator">=</span> MyISAM<span class="token keyword">SET</span> @<span class="token variable">@GLOBAL.default</span><span class="token operator">-</span>storage<span class="token operator">-</span><span class="token keyword">engine</span> <span class="token operator">=</span> MyISAM<span class="token keyword">SET</span> <span class="token keyword">default</span><span class="token operator">-</span>storage<span class="token operator">-</span><span class="token keyword">engine</span> <span class="token operator">=</span> MyISAM<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实际上,<code>GLOBAL</code>影响的是之后新客户端连接到服务器时 该系统变量取什么值,<code>SESSION</code>影响的是 当前客户端连接到服务器时 该系统变量取什么值.</p><p><font color="red"><b>注意:</b></font></p><ol><li> 如果不指定作用范围,默认是<code>SESSION</code>范围</li><li> 改变<code>GLOBAL</code>作用范围的变量值,不会影响服务器为已经连接的客户端分配好了,作用范围为<code>SESSION</code>的对应变量值,只会影响后续连接到服务器的客户端<code>SESSION</code>范围的值.</li></ol><p><strong>查看不同作用范围的值</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">]</span> VARIABLES <span class="token punctuation">[</span><span class="token operator">LIKE</span> <span class="token string">'匹配模式'</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意:</p><ul><li>如果查询的是<code>GLOBAL</code>全局变量,如果改变量没有<code>GLOBAL</code>作用范围是不会显示出来的</li><li>同理,变量没有<code>SESSION</code>作用范围,也不会显示</li><li>如果不指定作用范围,默认查询的是<code>SESSION</code>作用范围</li></ul><h4 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3. 注意事项:"></a>3. 注意事项:</h4><ol><li><p><code>关于作用范围</code>:  并不是所有的系统变量都既有<code>GLOBAL</code>范围又有<code>SESSION</code>范围,可能只有其中一种范围.</p></li><li><p>有些系统变量是只读的,是不能被设置的</p></li><li><p>启动项和系统变量的区别:</p><p><code>启动项</code>是程序启动时由用户传递的一些参数,<code>系统变量</code>是影响服务器程序运行行为的变量.</p><ul><li>大部分系统变量都可以通过启动项进行传参</li><li>有些系统变量是程序运行过程中生成的,不能当做启动项来设置</li><li>部分启动项也不是系统变量</li></ul></li></ol><h2 id="2-3-状态变量"><a href="#2-3-状态变量" class="headerlink" title="2.3 状态变量:"></a>2.3 状态变量:</h2><p><code>状态变量</code>: 是为了让我们更好了解服务器程序运行情况的信息数据</p><p>状态变量是用来展示服务器程序运行情况的信息数据,只能由服务器程序自己设置,不能人为设置.</p><p>查询语法:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SHOW</span> <span class="token punctuation">[</span><span class="token keyword">GLOBAL</span><span class="token operator">|</span><span class="token keyword">SESSION</span><span class="token punctuation">]</span> <span class="token keyword">STATUS</span> <span class="token punctuation">[</span><span class="token operator">LIKE</span> <span class="token string">'匹配模式'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8 MySQL数据目录</title>
      <link href="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/8_MySQL%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/"/>
      <url>/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/8_MySQL%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="8-1-数据库和文件系统的关系"><a href="#8-1-数据库和文件系统的关系" class="headerlink" title="8.1 数据库和文件系统的关系:"></a>8.1 数据库和文件系统的关系:</h2><p><code>Mysql</code>中像<code>InnoDB</code>和<code>MyISAM</code>这类存储引擎都是将数据存储在磁盘中,操作系统通过文件系统来管理磁盘,换句话说: 数据是存储在文件系统中的.</p><p>读数据是从文件系统中将数据读取到内存中,写数据是从内存中将数据写入到文件系统.</p><h2 id="8-2-Mysql的数据目录"><a href="#8-2-Mysql的数据目录" class="headerlink" title="8.2 Mysql的数据目录:"></a>8.2 Mysql的数据目录:</h2><p>Mysql服务器在启动的时候会从文件系统中的某个目录下加载一些数据,之后在运行过程中产生的数据也会存储到这个目录下的某些文件中.这个目录就是<code>数据目录</code>.</p><h3 id="8-2-1-数据目录和安装目录的区别"><a href="#8-2-1-数据目录和安装目录的区别" class="headerlink" title="8.2.1 数据目录和安装目录的区别:"></a>8.2.1 数据目录和安装目录的区别:</h3><p><code>安装目录</code>: 安装目录是mysql程序运行文件存放的地方</p><p><code>数据目录</code>: 数据目录是mysql程序在运行过程中产生的一些 <code>用户数据</code>,<code>程序运行状态数据</code>等数据存储的地方</p><h3 id="8-2-2-数据目录在哪儿"><a href="#8-2-2-数据目录在哪儿" class="headerlink" title="8.2.2 数据目录在哪儿:"></a>8.2.2 数据目录在哪儿:</h3><p><code>show variables like 'datadir'</code></p><p><img src="/MySQL/MySQL%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%90%E8%A1%8C%E7%9A%84/8_MySQL%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95/image-20210829003423480.png" alt="查看Mysql数据目录"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL是怎样运行的 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
