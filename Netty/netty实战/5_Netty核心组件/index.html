<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="5 Netty核心组件, pounds">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>5 Netty核心组件 | pounds</title>
    <link rel="icon" type="image/svg+xml" href="/medias/surprise-regular.svg">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>
<style type="text/css">
        .uk-alert {
            margin-bottom: 15px;
            padding: 10px;
            background: #ebf7fd;
            color: #2d7091;
            border: 1px solid rgba(45, 112, 145, 0.3);
            border-radius: 4px;
            text-shadow: 0 1px 0 #ffffff;
        }
        .uk-alert-success {
            background: #e8ece2;
            color: #659f13;
            border-left: 6px solid rgba(120, 199, 9);
            font-weight: 600;
        }
        .uk-alert-warning {
            background: #fff1f0;
            color: rgb(73, 59, 156);
            border-left: 6px solid rgb(83, 27, 184, 0.3);
            font-weight: 600;
        }
        .uk-alert-danger {
            background: #f8f8f6;
            color: #eb360d;
            border-left: 6px solid#eb360d;
            font-weight: 600;
        }
 </style>



<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/battle-net-brands.svg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">pounds</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/battle-net-brands.svg" class="logo-img circle responsive-img">
        
        <div class="logo-name">pounds</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/20.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description post-title">5 Netty核心组件</h1>
                </div>
                <div class="post-info">
                    
                        <div class="post-date info-break-policy">
                            <i class="far fa-check-circle"></i>发布日期:&nbsp;&nbsp;
                            2021-08-29
                        </div>
                    

                    
                        <div class="post-date info-break-policy">
                            | <i class="fas fa-history fa-fw"></i>更新日期:&nbsp;&nbsp;
                            2021-08-29
                        </div>
                    

                    
                        <div class="info-break-policy">
                            | <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                            9.5k
                        </div>
                    

                    

                    
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/netty/">
                                <span class="chip bg-color">netty</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/netty%E5%AE%9E%E6%88%98/" class="post-category">
                                netty实战
                            </a>
                        
                    </div>
                    
                </div>
            </div>
        </div>
        <!-- 文章顶部下划线 -->
        <!-- <hr class="clearfix"> -->

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="5-1-核心组件概述"><a href="#5-1-核心组件概述" class="headerlink" title="5.1 核心组件概述:"></a>5.1 核心组件概述:</h2><ol>
<li>Channel:<br><code>Channel</code>是NIO 三大核心组件之一, Channel是输入输出硬件设备与内存之间的一个通道的抽象,channel当做是 数据传输的载体,因此 channel可以被打开或者关闭,<br>可以连接或者断开连接.</li>
<li>ByteBuf:<br><code>ByteBuf</code>是Netty在Nio的ByteBuffer基础上的扩展,Netty的核心数据容器.</li>
<li>ChannelHandler和ChannelPipeline:<br><code>ChannelPipeline</code>: channel包裹的数据处理链,本质是个双向链表,结点元素是ChannelHandlerContext.而ChannelHandlerContext又与数据处理器<br><code>ChannelHandler</code>关联.<br><code>ChannelHandler</code>: 数据处理器,对数据的处理逻辑都在这个对象中完成.</li>
<li>EventLoopGroup和EventLoop:<br><code>EventLoopGroup</code>事件循环组: 本质是一个线程池,里面的线程与<code>EventLoop</code>事件循环相关联.</li>
<li>Future和Promise:<br><code>回调</code>: 本质是一个方法,一个指向已经被提供给其他方法的方法的引用<br><code>Future</code>: future可以看做是一个异步操作结果的占位符,future会在未来的某一个时刻完成,并提供对一步操作结果访问的途径.<br><code>Promise</code>: promise是对future的扩展,future本身是不提供对异步操作结果设置的途径,promise则提供了对异步操作设置结果的途径.</li>
</ol>
<h2 id="5-2-Channel"><a href="#5-2-Channel" class="headerlink" title="5.2 Channel:"></a>5.2 Channel:</h2><h3 id="5-2-1-Channel概述"><a href="#5-2-1-Channel概述" class="headerlink" title="5.2.1 Channel概述:"></a>5.2.1 Channel概述:</h3><ol>
<li><p>基本的I/O操作(bind,connect,read,write)依赖于底层网络传输提供的原语(Socket).Netty提供了自己的Channel及其子类,大大的降低了直接使用socket的复杂性.</p>
</li>
<li><p>通过channel可以获得当前网络连接的通道的状态</p>
</li>
<li><p>通过channel可以获得当前网络连接的配置参数(比如: 接口缓冲区的大小等)</p>
</li>
<li><p>channel提供异步的网络I/O操作(建立连接,读写,绑定端口等),异步调用意味着任何I/O都将立即返回,并且不保证在调用结束时所有的I/O操作已经完成</p>
</li>
<li><p>channel支持关联I/O操作与对应的处理程序(即handler)</p>
</li>
<li><p>不同的协议,不同阻塞类型的连接都有不同的channel与之对应,常见的Channel类型<code>不仅限与下列实现类</code>为:  </p>
<table>
<thead>
<tr>
<th align="left">Channel实现类</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NioSocketChannel</td>
<td>异步的客户端TCP连接</td>
</tr>
<tr>
<td align="left">NioServerSocketChannel</td>
<td>异步的服务端TCP连接</td>
</tr>
<tr>
<td align="left">NioDatagramChannel</td>
<td>异步udp连接</td>
</tr>
<tr>
<td align="left">NioSctpChannel</td>
<td>异步客户端Sctp连接</td>
</tr>
<tr>
<td align="left">NioSctpServerChannel</td>
<td>异步服务端Sctp连接</td>
</tr>
<tr>
<td align="left">OioSocketChannel</td>
<td>阻塞的客户端tcp连接</td>
</tr>
<tr>
<td align="left">EmbeddedChannel</td>
<td>内置的channel 用于测试channel</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="5-2-2-Channel的层次结构、常用方法"><a href="#5-2-2-Channel的层次结构、常用方法" class="headerlink" title="5.2.2 Channel的层次结构、常用方法:"></a>5.2.2 Channel的层次结构、常用方法:</h3><h4 id="5-2-2-1-层次结构"><a href="#5-2-2-1-层次结构" class="headerlink" title="5.2.2.1 层次结构:"></a>5.2.2.1 层次结构:</h4>   <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Channel</span> <span class="token keyword">extends</span> <span class="token class-name">AttributeMap</span><span class="token punctuation">,</span> <span class="token class-name">ChannelOutboundInvoker</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Channel</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/channel%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="channel的层次结构"><br>   说明:  </p>
<ol>
<li>每一个Channel在初始化的时候都将会被分配一个ChannelPipeLine和ChannelConfig.</li>
<li>每一个Channel都是独一无二的,Channel实现了java.lang.Comparable接口,从而保证了Channel的顺序.</li>
<li>ChannelConfig包含了该channel的所有设置,并且支持了更新,可以通过<code>实现ChannelConfig的子类来给Channel设置某些特殊的设置</code>  </li>
<li>ChannelPipeLine是实现Channel只执行I/O操作所有逻辑的容器,里面包含了许多 实际处理数据的handler了, 本质是一个 双向链表,表头表位分别表示入站出站的起点.</li>
<li>Netty的Channel是线程安全的,所以可以使用多线程对channel进行操作</li>
<li>通过Channel.write()操作,数据将从链表表尾开始向链表表头移动,通过ChannelHandlerContext.write()是将数据传递给下一个ChannelHandler开始沿着链表移动.  </li>
</ol>
<h4 id="5-2-2-2-常见方法"><a href="#5-2-2-2-常见方法" class="headerlink" title="5.2.2.2 常见方法"></a>5.2.2.2 常见方法</h4><ol>
<li><p><code>Channel read()</code>: 从当前Channel中读取数据到第一个inbound缓冲区,如果数据读取成功,触发<code>ChannelHandler.channelRead(ChannelHandlerContext ctx, Object msg)事件</code>.<code>read()操作</code>完毕之后,紧接着触发<code>ChannelHandler.channelReadComplete(ChannelHandlerContext ctx)事件</code>.<br>如果该channel读请求被挂起,后续的读操作会被忽略.</p>
</li>
<li><p><code>ChannelFuture write(Object msg)</code>: 请求将当前的msg通过ChannelPipeLine(<code>从pipeline的链表尾开始流动</code>)写入到Channel中.</p>
<blockquote>
<p>注意: write只是将数据存放于channel的缓冲区中,并不会将数据发送出去.要发送数据必须使用flush()方法  </p>
</blockquote>
</li>
<li><p><code>ChannelFuture write(Object msg, ChannelPromise promise)</code>: 与 <code>方法2</code> 作用相同,参数 <code>promise</code>是用来写入 <code>write方法</code>的执行结果.  </p>
</li>
<li><p><code>ChannelFuture writeAndFlush(Object msg)</code>: 与 <code>方法2</code> 作用类似, 不过 <code>会立即将msg发送出去</code>  </p>
</li>
<li><p><code>ChannelFuture writeAndFlush(Object msg, ChannelPromise promise)</code>: 与 <code>方法4</code> 作用相同, 参数 <code>promise</code>是用来写入 <code>write方法</code>的执行结果.</p>
</li>
<li><p><code>ChannelOutboundInvoker flush()</code>: 将所有带发送的数据(<code>存放于channel缓冲区中的数据</code>),发送出去</p>
</li>
<li><p><code>ChannelFuture close()</code>: 关闭<code>channel</code>无论 <code>close</code>操作是成功还是失败,都会通知一次<code>channelFuture对象</code>(即触发ChannelFuture.<br>operationComplete方法). <code>close操作</code>会级联触发该channel关联的<code>channePipeLine</code>中所有 <code>出站handler(继承了xxxOutBoundHandler)的close方法</code>.</p>
<blockquote>
<p>注意: 一旦channel 被关闭之后,就无法再使用了</p>
</blockquote>
</li>
<li><p><code>ChannelFuture disconnect()</code>: 断开与远程通信对端的连接. <code>disconnect方法</code>会级联触发该channel关联的<code>channePipeLine</code>中所有 <code>出站handler(继承了xxxOutBoundHandler)的close方法</code></p>
</li>
<li><p><code>ChannelFuture disconnect(ChannelPromise promise)</code>: 断开与远程通信对端的连接,并级联触发所有出站handler的<code>disconnect方法</code>,参数<code>promise</code>用于设置<br><code>diaconnect方法</code>的执行结果.  </p>
</li>
<li><p><code>ChannelFuture connect(SocketAddress remoteAddress)</code>: 客户端使用指定的服务端地址remoteAddress发起连接请求,如果连接因为应答超时而失败,<br>ChannelFuture中的 <code>connect方法</code>执行结果就是<code>ConnectTimeoutException</code>,连接被拒绝就是<code>ConnectException</code>.<br><code>connection方法</code>会级联触发该channel关联的<code>pipeline</code>中所有<code>出站handler</code>中的<code>connect方法</code>.  </p>
<blockquote>
<p>connect方法有很多的重载方法,可以既连接远程,又绑定本地地址等…  </p>
</blockquote>
</li>
<li><p><code>ChannelFuture bind(SocketAddress localAddress)</code>: 绑定本地的socket地址,并级联触发所有<code>出站handler</code>中的<code>bind (ChannelHandlerContext, SocketAddress, ChannelPromise)方法</code>  </p>
<blockquote>
<p>重载方法多了一个参数 <code>promise</code>,支持对bind操作执行结果的设置  </p>
</blockquote>
</li>
<li><p>channel信息获取方法:  </p>
</li>
</ol>
   <pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ChannelConfig</span> <span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 获取channel的配置信息,如: 连接超时时间</span>
<span class="token class-name">ChannelMetadata</span> <span class="token function">metadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 获取channel的元数据描述信息,如TCP配置信息等</span>
<span class="token keyword">boolean</span> <span class="token function">isOpen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// channel是否已经打开</span>
<span class="token keyword">boolean</span> <span class="token function">isRegistered</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// channel 是否已经注册到EventLoop中</span>
<span class="token keyword">boolean</span> <span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// channel是否已经处于激活状态</span>
<span class="token keyword">boolean</span> <span class="token function">isWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// channel是否可写</span>
<span class="token class-name">SocketAddress</span> <span class="token function">localAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// channel本地绑定地址</span>
<span class="token class-name">SocketAddress</span> <span class="token function">remoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// channel 远程通信的远程地址</span>
<span class="token class-name">ChannelPipeline</span> <span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取channel关联的pipeline  </span>
<span class="token class-name">ByteBufAllocator</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取channel缓冲区的分配对象,用于分配缓冲区大小  </span>
<span class="token class-name">EventLoop</span> <span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取channel绑定的eventLoop(唯一分配一个I/O事件的处理线程)</span>
<span class="token class-name">ChannelId</span> <span class="token function">id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取channel的唯一标识</span>
<span class="token class-name">Channel</span> <span class="token function">parent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// serverChannel.parent()返回null,socketChannel返回serverSocketChannel </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-2-3-Channel的源码分析"><a href="#5-2-3-Channel的源码分析" class="headerlink" title="5.2.3 Channel的源码分析:"></a>5.2.3 Channel的源码分析:</h3><p>   TODO</p>
<h2 id="5-3-ByteBuf"><a href="#5-3-ByteBuf" class="headerlink" title="5.3 ByteBuf:"></a>5.3 ByteBuf:</h2><h3 id="5-3-1-ByteBuf概述"><a href="#5-3-1-ByteBuf概述" class="headerlink" title="5.3.1 ByteBuf概述:"></a>5.3.1 ByteBuf概述:</h3><ol>
<li><p>ByteBuf优化:<br>NIO中ByteBuffer的缺点:  </p>
<ul>
<li><code>长度固定</code>: 一旦ByteBuffer分配完成,其容量就不能动态扩展或者收缩, 容易出现数组越界异常.</li>
<li><code>操作繁琐</code>: ByteBuffer所有的读写操作都是基于<code>position</code>作为定位指针进行操作,读写操作切换的时候需要使用<code>flip()</code>或者<code>rewind()</code>方法</li>
<li><code>功能有限</code>: ByteBuffer的API功能有限, 一些高级和实用的特性不支持,需要手动实现  </li>
</ul>
<p>Netty中ByteBuf的优点:  </p>
<ul>
<li>可以被用户自定义的缓冲区类型扩展</li>
<li>通过内置的复合缓冲区实现了透明的零拷贝  </li>
<li>容量可以按需增长(类似于StringBuilder)  </li>
<li>读写操作使用不同的索引,读写都有专门的api无需来回切换</li>
<li>支持方法的链式调用  </li>
<li>支持引用计数</li>
<li>支持池化  </li>
</ul>
</li>
</ol>
<h3 id="5-3-2-ByteBuf工作原理"><a href="#5-3-2-ByteBuf工作原理" class="headerlink" title="5.3.2 ByteBuf工作原理:"></a>5.3.2 ByteBuf工作原理:</h3><ol>
<li><p>ByteBuf的数据结构:  </p>
<ul>
<li><code>初始化时</code>:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/ByteBuf%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="ByteBuf数据结构">  </li>
<li><code>写入部分数据之后</code>:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E8%AF%BB%E5%86%99%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E4%B9%8B%E5%90%8E.png" alt="ByteBuf数据结构"><br>说明:  <ul>
<li>ByteBuf维护了两个不同的指针: 一个用于读(readerIndex),一个用于写(writeIndex).</li>
<li>ReadIndex 和 WriteIndex 的起始位置都是数组下标为0的位置. </li>
<li>凡是 <code>read</code> 或者 <code>write</code>开头的api都会让 <code>readerIndex</code> 或者 <code>writeIndex</code>递增,而 <code>get</code> 或者 <code>set</code>开头的api不会.</li>
<li>ByteBuf有默认的最大长度限制 <code>Integter.MAX_VALUE</code>.在这个范围之内可以定义ByteBuf的最大容量,通过<code>capacity(int) </code>或者<code>ensureWritable(int)</code>方法扩容如果超出最大容量会抛出异常.</li>
<li>试图读 <code>writeIndex</code>之后的数据,或者视图在<code>最大容量</code>之外写数据,会发生数组越界异常  </li>
</ul>
</li>
</ul>
</li>
<li><p>ByteBuf的使用模式:  </p>
<ul>
<li><p><code>堆缓冲区</code>:<br>最常用模式,将数据存放在JVM的对空间里面.这种模式又被称为是 <code>支撑数组</code>.<br><code>优点</code>: 能够在没有使用 <code>池化</code> 的情况下提供快速的分配和释放.<code>非常适合有遗留数据需要处理的情况</code><br><code>缺点</code>: 当需要发送堆缓冲区的数据时,JVM需要在内部把 <code>堆缓冲区</code> 中的数据复制到 <code>直接缓冲区</code>中.<br>使用示例:  </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 通过netty提供的工具类Unpooled获取Netty的数据容器,ByteBuf</span>
<span class="token class-name">ByteBuf</span> byteBuf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">copiedBuffer</span><span class="token punctuation">(</span><span class="token string">"hello netty"</span><span class="token punctuation">,</span> <span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         
<span class="token comment">// 相关方法</span>
<span class="token comment">// public abstract boolean hasArray();判断ByteBuf的使用模式(hasArray判断的是 byteBuf是否在堆空间有一个支撑数组),</span>
<span class="token comment">// 即数据存放的位置在哪儿 堆/直接缓存区/复合缓冲区</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">hasArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//  获取byteBuf的支撑数组</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> byteBuf<span class="token punctuation">.</span><span class="token function">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         
    <span class="token comment">// 把字节数组转换成字符串</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span><span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         
    <span class="token comment">// 获取支撑数组的一些信息:</span>
    <span class="token comment">// 获取支撑数组的偏移量</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">arrayOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取支撑数组的可读索引位置</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取支撑数组的可写索引位置</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">writerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取支撑数组的容量</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">capacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 获取支撑数组中剩余可读元素占多少个字节,这个的大小是相对于readerIndex位置的,</span>
    <span class="token comment">// 比如下面这个读取方法会导致readerIndex的移动,从而导致readableBytes()变化</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">readByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 但是getByte方法是不会造成readerIndex移动的</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p><code>直接缓冲区</code>:<br><code>网络数据传输最理想的选择</code>,直接缓冲区中的数据是常驻在常规会被JVM进行垃圾回收的堆空间之外.<br>优点: 由于数据是存储在JVM堆空间之外的直接内存中,在进行网络传输的时候,无需把数据从堆空间复制到直接内存中,提高网络传输时的性能.<br>缺点: 1.分配和释放的开销都十分昂贵;2.如果数据不仅仅是用作网络传输的数据,在服务端还可能对齐进行访问的话,必须要将数据从<code>直接内存</code>复制到<code>堆空间中</code>来.</p>
<blockquote>
<p>建议: 如果缓冲区中的数据,需要被访问的话,堆缓冲区是更好的选择.</p>
</blockquote>
<p>使用示例:  </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ByteBuf</span> directBuf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">directBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// public abstract boolean hasArray();判断ByteBuf的使用模式(hasArray判断的是 byteBuf是否在堆空间有一个支撑数组),</span>
<span class="token comment">// 如果不是那么就是直接缓冲区</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>directBuf<span class="token punctuation">.</span><span class="token function">hasArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> directBuf<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
    directBuf<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>directBuf<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 业务逻辑处理</span>
    <span class="token function">handleArray</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p><code>复合缓冲区</code>:<br><code>多个ByteBuf的聚合视图</code>,可以根据需要添加或者删除ByteBuf实例.Netty通过ByteBuf子类 — <code>CompositeByteBuf</code>实现<code>复合缓冲区模式</code>,<br>其提供一个将多个缓冲区表示为单个合并缓冲区的虚拟表示.</p>
<blockquote>
<p>ps:  <code>CompositeByteBuf</code>中的byteBuf实例可能同时包含 <code>直接缓冲区</code>或者<code>非直接缓冲区</code>,此时<code>hasArray()</code>方法在只有一个实例的时候,回去判断该实例是否有支撑数组,<br>存在多个实例的时候<code>hasArray方法</code>总是返回<code>false</code></p>
</blockquote>
<p>使用示例:  模拟一个HTTP协议传输的消息,包含两部分 头部和主题,分别由不同的模块生成,在发送数据的时候进行组装.如图:<code>可以使用CompositeByteBuf来消除每条消息都重复创建这两个缓冲区</code><br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/CompositeByteBuf%E7%A4%BA%E4%BE%8B.png" alt="Composite实例"></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//  -------------------------------  构造 复合缓冲区  -----------------------------</span>
<span class="token class-name">CompositeByteBuf</span> composited <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">compositeBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 也可以是堆缓冲区</span>
<span class="token class-name">ByteBuf</span> headerBuf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">directBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 也可以是直接缓冲区,buffer()返回的是一个堆缓冲区</span>
<span class="token class-name">ByteBuf</span> bodyBuf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">buffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          
<span class="token comment">// 添加缓冲区到复合缓冲区</span>
composited<span class="token punctuation">.</span><span class="token function">addComponents</span><span class="token punctuation">(</span>headerBuf<span class="token punctuation">,</span>bodyBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
          
<span class="token comment">//  .... 业务逻辑</span>
          
<span class="token comment">// 删除某个buf,按照添加的顺序,在本例子中,0为headBuf</span>
composited<span class="token punctuation">.</span><span class="token function">removeComponent</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 遍历获取每一个buf</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuf</span> buf <span class="token operator">:</span> composited<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>   
          
<span class="token comment">// ------------------------------  访问复合缓冲区  --------------------------------</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">byteBufCompositeArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">CompositeByteBuf</span> compBuf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">compositeBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//获得可读字节数</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> compBuf<span class="token punctuation">.</span><span class="token function">readableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//分配一个具有可读字节数长度的新数组</span>
    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//将字节读到该数组中</span>
    compBuf<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>compBuf<span class="token punctuation">.</span><span class="token function">readerIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//使用偏移量和长度作为参数使用该数组</span>
    <span class="token function">handleArray</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ol>
<h3 id="5-3-3-字节级别操作"><a href="#5-3-3-字节级别操作" class="headerlink" title="5.3.3 字节级别操作:"></a>5.3.3 字节级别操作:</h3><p>工作时通常ByteBuf的数据结构图:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E8%AF%BB%E5%86%99%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E4%B9%8B%E5%90%8E.png" alt="ByteBuf数据结构"></p>
<h4 id="5-3-3-1-几种不同的字节区间"><a href="#5-3-3-1-几种不同的字节区间" class="headerlink" title="5.3.3.1 几种不同的字节区间:"></a>5.3.3.1 几种不同的字节区间:</h4><ol>
<li><p><code>可丢弃字节区间</code>:<br>在ByteBuf中,已经被读取过的字节都会被视为是 <code>可丢弃的字节</code>, <code>0</code>到 <code>readerIndex</code>之间就是 <code>可丢弃区间</code>,通过<code>discardReadBytes()</code>可以丢弃他们并回收空间.<br><code>discardReadBytes()</code>方法会将 <code>readerIndex</code>重新指向 <code>byteBuf</code>数组开始元素的位置,<code>writerIndex</code>会减少相应的数量.<br><code>discardReadBytes()</code>调用之后的数据结构:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/discardReadBytes%E8%B0%83%E7%94%A8%E4%B9%8B%E5%90%8E.png" alt="ByteBuf数据结构"></p>
<blockquote>
<p>注意:</p>
<ol>
<li>由于<code>discardReadBytes()</code>方法只是移动了<code>writerIndex</code>和<code>可读字节</code>,但是没有对其他数组空间进行数据擦除,所以可写部分的数据是<code>没有任何保证的</code>.</li>
<li>在非必要时刻(内存极低紧张)的时候,不要使用 <code>discardReadBytes()</code>将<code>可丢弃字节区间</code>转化为<code>可写区间</code>,因为该方法必须将<code>可读区间</code>中的数据转移到数组开始位置去,这个操作很有可能会发生<code>内存复制</code></li>
</ol>
</blockquote>
</li>
<li><p><code>可读字节区间</code>:<br>ByteBuf的可读字节是存储实际数据的区间.<code>新分配</code>、<code>包装</code>、<code>复制</code>的缓冲区默认的<code>readerIndex</code>为<code>0</code>.<br>任何 <code>read</code> 或者 <code>skip</code> 开头的方法都会将造成<code>readerIndex</code>增加已读字节. 如果 <code>readBytes(ByteBuf dest)</code>读取并写入到<code>dest</code>会造成 <code>dest</code>的<code>writerIndex</code><br>增加相应的数量.</p>
<blockquote>
<p>读取 <code>writerIndex</code>之外的数据将造成数组越界异常</p>
</blockquote>
</li>
<li><p><code>可写字节区间</code>:<br>可写字节区间是指一个拥有未定义内容的,写入就绪的内存区域.<code>新分配</code>的缓冲区默认的<code>readerIndex</code>为<code>0</code>.<br>任何以 <code>write</code> 开头的方法都会造成 <code>writerIndex</code>增加以写入字节数.<br>如果 <code>writeBytes(Bytes dest)</code>读取并写入到<code>dest</code> 会造成 <code>调用</code> 这个方法的缓冲区的 <code>readerIndex</code>增加相应的数量.</p>
</li>
</ol>
<h4 id="5-3-3-2-索引管理"><a href="#5-3-3-2-索引管理" class="headerlink" title="5.3.3.2 索引管理:"></a>5.3.3.2 索引管理:</h4><ol>
<li><p><code>随机访问索引</code>: <code>get或者set</code>开头的方法来随机<code>访问或者写入</code>数据 ByteBuf与普通数组一样,索引总是从 <code>0</code>开始,到<code>capacity - 1</code>截至.</p>
<blockquote>
<p>注意:</p>
<ol>
<li><code>get或者set</code>开头的方法不会造成读写索引的移动</li>
<li>通过<code>需要索引值为入参</code>的方法来访问缓冲区,同样不会造成读写索引的移动</li>
<li>在需要的时候可以通过 readerIndex(index) 或者 writerIndex(index) 来移动读写索引</li>
</ol>
</blockquote>
</li>
<li><p><code>顺序访问索引</code>: <code>read()或者write()</code>方法来顺序 <code>读取或者写入</code> 数据</p>
</li>
<li><p><code>索引管理</code>:<br>调用 <code>markReaderIndex()</code>, <code>markWriterIndex()</code> 来标记读写索引<br>调用 <code>resetWriterIndex()</code>, <code>resetReaderIndex()</code> 来重置读写索引到标记的位置<br>调用 <code>readerIndex(index)</code>, <code>writerIndex(index</code> 来指定读写索引的位置<br>调用 <code>clear()</code> 将读写索引重新指向 <code>数组起始位置</code>  </p>
<blockquote>
<ol>
<li><code>clear()</code>方法仅仅是重置读写索引为0,不会对buf中的数据进行清除  </li>
<li>相对于 <code>discardReadBytes()</code>方法,<code>clear()</code>方法更为效率,因为它只是将读写索引重置为了0,不会引发任何的数据复制.</li>
</ol>
</blockquote>
</li>
</ol>
<h4 id="5-3-3-3-派生缓冲区"><a href="#5-3-3-3-派生缓冲区" class="headerlink" title="5.3.3.3 派生缓冲区:"></a>5.3.3.3 派生缓冲区:</h4><p>派生缓冲区为ByteBuf提供以专门的方式呈现 <code>缓冲区数据</code> 的视图,常见方法为:  </p>
<ul>
<li><code>duplicate()</code>: 返回一个与调用<code>duplicate()</code>的缓冲区<code>共享所有空间</code>的缓冲区  </li>
<li><code>slice()</code>: 返回调用<code>slice()</code>的缓冲区<code>整个可读字节区间</code>的切片  </li>
<li><code>slice(int,int)</code>: 返回调用<code>slice()</code>的缓冲区<code>部分可读字节区间</code>的切片</li>
<li><code>readSlice(int length)</code>: 返回调用<code>slice()</code>的缓冲区<code>可读字节区间中 readerIndex + length</code>的切片,会将<code>readerIndex</code>增加length长度.</li>
<li><code>order(ByteOrder)</code>:  </li>
<li><code>Unpooled.unmofifiableBuffer(..)</code>:  </li>
</ul>
<blockquote>
<p>注意:</p>
<ol>
<li>上面的方法只是将数据展示出来了,但是与原buffer使用的是同一份数据,修改派生缓冲区的数据也会改变原缓冲区的数据.(<code>如同ArrayList.subList</code>)</li>
<li>如果想要复制一份独立的数据副本,请使用<code>copy()</code>,<code>copy(int,int)</code>  </li>
</ol>
</blockquote>
<p>测试:  </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// ----------------------   非共享  -----------------------------------------</span>

<span class="token class-name">Charset</span> utf8 <span class="token operator">=</span> <span class="token class-name">Charset</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//创建 ByteBuf 以保存所提供的字符串的字节</span>
<span class="token class-name">ByteBuf</span> buf <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">copiedBuffer</span><span class="token punctuation">(</span><span class="token string">"Netty in Action rocks!"</span><span class="token punctuation">,</span> utf8<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//创建该 ByteBuf 从索引 0 开始到索引 15 结束的分段的副本</span>
<span class="token class-name">ByteBuf</span> copy <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//将打印"Netty in Action"</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>copy<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>utf8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//更新索引 0 处的字节</span>
buf<span class="token punctuation">.</span><span class="token function">setByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token string">'J'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//将会成功，因为数据不是共享的</span>
<span class="token keyword">assert</span> buf<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">!=</span> copy<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ----------------------   共享  -----------------------------------------</span>
<span class="token comment">//创建一个用于保存给定字符串的字节的 ByteBuf</span>
<span class="token class-name">ByteBuf</span> bufForSlice <span class="token operator">=</span> <span class="token class-name">Unpooled</span><span class="token punctuation">.</span><span class="token function">copiedBuffer</span><span class="token punctuation">(</span><span class="token string">"Netty in Action rocks!"</span><span class="token punctuation">,</span> utf8<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//创建该 ByteBuf 从索引 0 开始到索引 15 结束的一个新切片</span>
<span class="token class-name">ByteBuf</span> sliced <span class="token operator">=</span> bufForSlice<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//将打印"Netty in Action"</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sliced<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>utf8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//更新索引 0 处的字节</span>
bufForSlice<span class="token punctuation">.</span><span class="token function">setByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token string">'J'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//将会成功，因为数据是共享的，对其中一个所做的更改对另外一个也是可见的</span>
<span class="token keyword">assert</span> bufForSlice<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> sliced<span class="token punctuation">.</span><span class="token function">getByte</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-3-3-4-查找字节所在的位置"><a href="#5-3-3-4-查找字节所在的位置" class="headerlink" title="5.3.3.4 查找字节所在的位置:"></a>5.3.3.4 查找字节所在的位置:</h4><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C.png" alt="1"><br>一般的字节可以通过 <code>indexOf()</code> 方法来查找指定的字节,或者通过传入 <code>ByteProcessor参数</code> 设定<code>中止字符</code>来配合<code>forEachByte()方法</code>帮助查找.</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**
 * Aborts on a {@code NUL (0x00)}.
 */</span>
<span class="token class-name">ByteProcessor</span> FIND_NUL <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexOfProcessor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Aborts on a non-{@code NUL (0x00)}.
 */</span>
<span class="token class-name">ByteProcessor</span> FIND_NON_NUL <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexNotOfProcessor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Aborts on a {@code CR ('\r')}.
 */</span>
<span class="token class-name">ByteProcessor</span> FIND_CR <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexOfProcessor</span><span class="token punctuation">(</span>CARRIAGE_RETURN<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Aborts on a non-{@code CR ('\r')}.
 */</span>
<span class="token class-name">ByteProcessor</span> FIND_NON_CR <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexNotOfProcessor</span><span class="token punctuation">(</span>CARRIAGE_RETURN<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Aborts on a {@code LF ('\n')}.
 */</span>
<span class="token class-name">ByteProcessor</span> FIND_LF <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexOfProcessor</span><span class="token punctuation">(</span>LINE_FEED<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Aborts on a non-{@code LF ('\n')}.
 */</span>
<span class="token class-name">ByteProcessor</span> FIND_NON_LF <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexNotOfProcessor</span><span class="token punctuation">(</span>LINE_FEED<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Aborts on a semicolon {@code (';')}.
 */</span>
<span class="token class-name">ByteProcessor</span> FIND_SEMI_COLON <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexOfProcessor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">';'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Aborts on a comma {@code (',')}.
 */</span>
<span class="token class-name">ByteProcessor</span> FIND_COMMA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexOfProcessor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Aborts on a ascii space character ({@code ' '}).
 */</span>
<span class="token class-name">ByteProcessor</span> FIND_ASCII_SPACE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexOfProcessor</span><span class="token punctuation">(</span>SPACE<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Aborts on a {@code CR ('\r')} or a {@code LF ('\n')}.
 */</span>
<span class="token class-name">ByteProcessor</span> FIND_CRLF <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">byte</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value <span class="token operator">!=</span> CARRIAGE_RETURN <span class="token operator">&amp;&amp;</span> value <span class="token operator">!=</span> LINE_FEED<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Aborts on a byte which is neither a {@code CR ('\r')} nor a {@code LF ('\n')}.
 */</span>
<span class="token class-name">ByteProcessor</span> FIND_NON_CRLF <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">byte</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value <span class="token operator">==</span> CARRIAGE_RETURN <span class="token operator">||</span> value <span class="token operator">==</span> LINE_FEED<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Aborts on a linear whitespace (a ({@code ' '} or a {@code '\t'}).
 */</span>
<span class="token class-name">ByteProcessor</span> FIND_LINEAR_WHITESPACE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">byte</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value <span class="token operator">!=</span> SPACE <span class="token operator">&amp;&amp;</span> value <span class="token operator">!=</span> HTAB<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Aborts on a byte which is not a linear whitespace (neither {@code ' '} nor {@code '\t'}).
 */</span>
<span class="token class-name">ByteProcessor</span> FIND_NON_LINEAR_WHITESPACE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteProcessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span><span class="token keyword">byte</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value <span class="token operator">==</span> SPACE <span class="token operator">||</span> value <span class="token operator">==</span> HTAB<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-3-4-ByteBuf常见API总结"><a href="#5-3-4-ByteBuf常见API总结" class="headerlink" title="5.3.4 ByteBuf常见API总结:"></a>5.3.4 ByteBuf常见API总结:</h3><h4 id="5-3-4-1-顺序读操作"><a href="#5-3-4-1-顺序读操作" class="headerlink" title="5.3.4.1 顺序读操作:"></a>5.3.4.1 顺序读操作:</h4><p>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%93%8D%E4%BD%9C1.png"><br>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%93%8D%E4%BD%9C2.png"><br>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%93%8D%E4%BD%9C3.png"><br>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E8%AF%BB%E6%93%8D%E4%BD%9C4.png">   </p>
<h4 id="5-3-4-2-顺序写操作"><a href="#5-3-4-2-顺序写操作" class="headerlink" title="5.3.4.2 顺序写操作:"></a>5.3.4.2 顺序写操作:</h4><p>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E5%86%99%E6%93%8D%E4%BD%9C1.png"><br>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E5%86%99%E6%93%8D%E4%BD%9C2.png"><br>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E5%86%99%E6%93%8D%E4%BD%9C3.png"><br>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%A1%BA%E5%BA%8F%E5%86%99%E6%93%8D%E4%BD%9C4.png">  </p>
<h4 id="5-3-4-3-随机写操作"><a href="#5-3-4-3-随机写操作" class="headerlink" title="5.3.4.3 随机写操作:"></a>5.3.4.3 随机写操作:</h4><p>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%9A%8F%E6%9C%BA%E5%86%99%E6%93%8D%E4%BD%9C.png">  </p>
<h4 id="5-3-4-4-随机读操作"><a href="#5-3-4-4-随机读操作" class="headerlink" title="5.3.4.4 随机读操作:"></a>5.3.4.4 随机读操作:</h4><p>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E9%9A%8F%E6%9C%BA%E8%AF%BB%E6%93%8D%E4%BD%9C.png"></p>
<h4 id="5-3-4-5-其他操作"><a href="#5-3-4-5-其他操作" class="headerlink" title="5.3.4.5 其他操作:"></a>5.3.4.5 其他操作:</h4><p>   <img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C.png"></p>
<h3 id="5-3-5-ByteBuf辅助工具类"><a href="#5-3-5-ByteBuf辅助工具类" class="headerlink" title="5.3.5 ByteBuf辅助工具类:"></a>5.3.5 ByteBuf辅助工具类:</h3><h4 id="5-3-5-1-ByteBufHolder接口"><a href="#5-3-5-1-ByteBufHolder接口" class="headerlink" title="5.3.5.1 ByteBufHolder接口:"></a>5.3.5.1 ByteBufHolder接口:</h4><p><code>ByteBufHolder</code>是<code>ByteBuf</code>的容器,除了实际数据装载之外,我们还需要存储各种属性值.比如HTTP的请求和响应都可以携带消息体,在Netty中消息体就是用<code>ByteBuf</code>来表示;<br>但是由于不同的协议之间会包含不同的协议字段和功能,这部分数据并不适合写在实际数据中,所以Netty抽象出了一个 <code>ByteBufHolder接口</code>持有一个<code>ByteBuf</code>用以装载实际数据,<br>同时携带不同协议的协议字段和功能. (ByteBufHolder的实现类实现不同协议的协议字段和功能描述).<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E4%B8%8D%E5%90%8C%E5%8D%8F%E8%AE%AE%E7%9A%84ByteBufHolder%E5%AE%9E%E7%8E%B0%E7%B1%BB.png"><br>说明:  </p>
<ul>
<li><code>ByteBufHolder</code>为Netty的高级特性提供了支持,比如缓冲区池化,其中可以从池中借用ByteBuf,并且在需要时自动释放.  </li>
<li><code>通常用作需要存储实际数据的消息对象接口</code></li>
<li><code>常用方法</code>:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/ByteBufHolder%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png">  </li>
</ul>
<h4 id="5-3-5-2-ByteBuf内存空间分配"><a href="#5-3-5-2-ByteBuf内存空间分配" class="headerlink" title="5.3.5.2 ByteBuf内存空间分配:"></a>5.3.5.2 ByteBuf内存空间分配:</h4><ol>
<li><p><code>按需分配 --- ByteBufAllocator接口</code>:  </p>
<ol>
<li><p>为了降低分配和释放的内存开销,Netty通过<code>interface ByteBufAllocator</code>实现了缓冲区池化,<code>ByteBufAllocator</code>可以用来分配我们所描述过得任意类型的ByteBuf实例.<br><code>池化</code>不会改变<code>ByteBuf</code>api 的语义,只是新的数据需要使用ByteBuf来存储的时候,可以从缓冲池中取出一个 <code>ByteBuf实例</code> 来存储数据.</p>
</li>
<li><p>常用方法:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/ByteBufAllocator%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png">  </p>
</li>
<li><p>说明:  </p>
<ul>
<li><p>可以通过 <code>channel</code>(每个都可以有一个不同的ByteBufAllocator实例) 或者 绑定到<br><code>channelHandler</code>的<code>ChannelHandlerContext</code>获取到一个<code>ByteBufAllocator</code>的引用.  </p>
</li>
<li><p>Netty提供了  ByteBufAllocator 的实现:<br><code>PooledByteBufAllocator</code>:  池化ByteBuf实例,提高性能并最大限度的减少内存碎片.使用的是jemalloc技术实现的内存分配.<br><code>UnpooledByteBufAllocator</code>:  非池化ByteBuf实例分配,每一次调用都会返回一个新的byteBuf实例.  </p>
<blockquote>
<ol>
<li>netty4.1版本默认使用的是 <code>PooledByteBufAllocator</code>, 4.0版本默认使用的则是 <code>UnpooledByteBufAllocator</code>.</li>
<li>可以通过<code>ChannelConfig</code>或者<code>Bootstrap</code>配置 使用什么类型的 <code>ByteBufAllocator</code>.</li>
</ol>
</blockquote>
</li>
<li><p><code>ioBuffer()</code>: 这个方法在使用的时候,如果当前运行环境有 sun.misc.Unsafe 支持的时候, 返回的是 <code>Direct ByteBuf</code>,否则返回的是 <code>Heap ByteBuf</code>.<br>当使用 <code>PreferHeapByteBufAllocator</code>的时候, 只会返回 <code>Heap ByteBuf</code>.</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><code>Unpooled缓冲区</code>:<br>在某些情况下,如果未能获取到一个 <code>ByteBufAllocator</code>的引用.可以通过工具类 <code>Unpooled</code> 来创建未池化的 <code>ByteBuf实例</code>.<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/Unpooled%E5%B7%A5%E5%85%B7%E7%B1%BB.png">  </p>
</li>
<li><p><code>ByteBufUtil类</code>:<br><code>ByteBufUtil</code> 提供了用于操作 <code>ByteBuf</code> 的静态的辅助方法。因为这个API是通用的，并且和池化无关，所以这些方法已然在分配类的外部实现。<br>这些静态方法中最有价值的可能就是 hexdump()方法，它以十六进制的表示形式输出<code>ByteBuf</code> 的内容。这在各种情况下都很有用，例如，出于调试的目的记录 <code>ByteBuf</code> 的内容。十<br>六进制的表示通常会提供一个比字节值的直接表示形式更加有用的日志条目，此外，十六进制的版本还可以很容易地转换回实际的字节表示。<br>另一个有用的方法是 <code>boolean equals(ByteBuf, ByteBuf)</code>，它被用来判断两个 <code>ByteBuf</code>实例的相等性。</p>
</li>
</ol>
<h3 id="5-3-6-引用计数"><a href="#5-3-6-引用计数" class="headerlink" title="5.3.6 引用计数:"></a>5.3.6 引用计数:</h3><ul>
<li><p><code>引用计数</code>: 一种通过在某个对象所持有的资源不再被其他对象引用时,释放该对象所持有的资源来优化内存使用和性能的技术.(<code>类似于JVM的引用计数算法</code>)  </p>
</li>
<li><p>Netty 在第 4 版中为 <code>ByteBuf</code> 和 <code>ByteBufHolder</code> 引入了引用计数技术，它们都实现了 <code>interface ReferenceCounted</code>.  </p>
</li>
<li><p><code>引用计数实现的大致思路</code>: 它主要涉及跟踪到某个特定对象的活动引用的数量。一个 <code>ReferenceCounted</code> 实现的实例将通常以活动的引用计数为 <code>1</code>作为开始。只要<code>引用计 数</code>大于 <code>0</code>，就能保证对象不会被释放。当活动引用的数量减少到 0 时，该实例就会被释放。</p>
<blockquote>
<p>注意: 虽然释放的确切语义可能是特定于实现的，但是至少已经释放的对象应该不可再用了。</p>
</blockquote>
</li>
<li><p><code>引用计数</code>对于 <code>池化实现</code>（如 PooledByteBufAllocator）来说是至关重要的，它降低了内存分配的开销。</p>
</li>
<li><p>试图访问一个已经被<code>释放(或者说是 引用计数为 0)</code>的引用计数的对象，将会导致一个 <code>IllegalReferenceCountException</code>。  </p>
</li>
<li><p><code>谁来释放</code>: 一般是由 最后访问资源的一方 来负责释放 资源.  </p>
</li>
</ul>
<blockquote>
<p>一个特定的（ReferenceCounted 的实现）类，可以用它自己的独特方式来定义它的引用计数规则。例如，我们可以设想一个类，其 <code>release()</code> 方法的实现总是将引用计数设为<br>零，而不用关心它的当前值，从而一次性地使所有的活动引用都失效。  </p>
</blockquote>
<h3 id="5-3-7-ByteBuf源码分析"><a href="#5-3-7-ByteBuf源码分析" class="headerlink" title="5.3.7 ByteBuf源码分析:"></a>5.3.7 ByteBuf源码分析:</h3><p>TODO</p>
<h2 id="5-4-ChannelHandler和ChannelPipeline"><a href="#5-4-ChannelHandler和ChannelPipeline" class="headerlink" title="5.4 ChannelHandler和ChannelPipeline:"></a>5.4 ChannelHandler和ChannelPipeline:</h2><h3 id="5-4-1-ChannelHandler和ChannelPipeline的概述"><a href="#5-4-1-ChannelHandler和ChannelPipeline的概述" class="headerlink" title="5.4.1 ChannelHandler和ChannelPipeline的概述:"></a>5.4.1 ChannelHandler和ChannelPipeline的概述:</h3><p><code>Channel,ChannelPipeline,ChannelContext,ChannelHandler之间的关系</code>:  </p>
<p><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/channelhandler%E5%85%B3%E7%B3%BB.png"></p>
<p>Netty的ChannelPipeline和ChannelHandler机制类似于Servlet和Filter过滤器,这类拦截器实际上是责任链模式的一种变形,主要是为了方便事件的拦截和用户业务逻辑的定制.<br><code>ChannelHandler</code>: 从应用程序开发人员的角度来看,Netty的主要组件是ChannelHandler,它充当了所有处理入站和出站数据的应用程序逻辑的容器,ChannelHandler可以适用于任何逻辑操作.<br><code>ChannelPipeline</code>: Netty将Channel的数据管道抽象为 <code>ChannelPipeline</code>,消息在 <code>ChannelPipeline</code>中流动和传递.<br><code>ChannelPipeline</code>持有I/O事件拦截器<code>ChannelHandler</code>的链表, 由 <code>ChannelHandler</code> 对I/O事件进行拦截和处理,可以方便的通过增删handler来实现不同业务逻辑的定制,不需要对已有<br>handler修改,就能实现对修改封闭和对扩展的支持.<br><code>ChannelHandlerContext</code>: 当<code>ChannelHandler</code>每一次被分配到一个<code>ChannelPipeline</code>的时候,都会创建一个新的<code>ChannelHandlerContext</code>与<code>ChannelHandler</code>关联起来,<br>其表示<code>ChannelHandler</code>与<code>ChannelPipeline</code>的绑定关系.</p>
<h3 id="5-4-2-ChannelHandler"><a href="#5-4-2-ChannelHandler" class="headerlink" title="5.4.2 ChannelHandler:"></a>5.4.2 ChannelHandler:</h3><h4 id="5-4-2-1-Channel的生命周期"><a href="#5-4-2-1-Channel的生命周期" class="headerlink" title="5.4.2.1 Channel的生命周期:"></a>5.4.2.1 Channel的生命周期:</h4><p><code>Channel</code>接口定义了一组和 <code>ChannelInBoundHandler</code>api 密切相关的简单但是功能强大的状态模型.<code>Channel的4个状态</code> :<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/Channel%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="channel生命周期"><br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/CHANNEL%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="channel状态模型"><br>说明:  </p>
<ul>
<li>只要<code>Channel</code>没有关闭,<code>Channel</code>就可以再次被注册到<code>EventLoop</code>组件上.</li>
<li>当图片中的状态一旦发生改变的时候,就会生成对应的事件,这些事件会被转发给 <code>ChannelPipeline</code> 中的 <code>ChannelHandler</code>处理.  </li>
</ul>
<h4 id="5-4-2-2-ChannelHandler的生命周期"><a href="#5-4-2-2-ChannelHandler的生命周期" class="headerlink" title="5.4.2.2 ChannelHandler的生命周期:"></a>5.4.2.2 ChannelHandler的生命周期:</h4><p><code>ChannelHandler</code>定义的生命周期操作,<code>ChannelHandler</code>被添加到<code>channelPipeline</code>或者从<code>channelPipeline</code>中移除的时候会触发这些操作.<br>每个方法都会接收一个<code>ChannelHandlerContext</code>作为参数<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/handler%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="ChannelHandler生命周期"><br><code>channelHandler</code>两个重要的子接口:  </p>
<ul>
<li><code>ChannelInboundHandler</code> : 处理入栈数据以及各种状态变化</li>
<li><code>ChannelOutboundHandler</code> : 处理出站数据并且允许拦截所有的操作</li>
</ul>
<h4 id="5-4-2-3-ChannelInboundHandler接口"><a href="#5-4-2-3-ChannelInboundHandler接口" class="headerlink" title="5.4.2.3 ChannelInboundHandler接口:"></a>5.4.2.3 <code>ChannelInboundHandler</code>接口:</h4><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/inboundHandler%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="ChannelInboundHandler"><br>说明:  </p>
<ul>
<li>上面是 <code>ChannelInboundHandler</code>的生命周期方法,channel中的<code>数据被读取</code>或者<code>channel状态发生变化</code>的时候被调用.</li>
<li>当 <code>ChannelInboundHandler</code>的子类类重写了<code>channelRead()</code>方法的时候,需要手动通过 <code>ReferenceCountUtil.release()</code>来手动释放与<code>池化ByteBuf有关的内存 (即参数msg)</code></li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Sharable</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DiscardHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span><span class="token class-name">Object</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 如果不手动释放,Netty会通过日志的形式记录msg未释放的实例</span>
        <span class="token class-name">ReferenceCountUtil</span><span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>也可以通过 <code>SimpleChannelInboundHandler</code>来自动释放资源,ps: 不要试图把 <code>SimpleChannelInboundHandler</code>中的数据存放起来,以便后期使用.</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Sharable</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DiscardHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span><span class="token class-name">Object</span> msg<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 在这里就不需要手动释放msg所占用的byteBuf空间了</span>
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-4-2-3-ChannelOutboundHandler接口"><a href="#5-4-2-3-ChannelOutboundHandler接口" class="headerlink" title="5.4.2.3 ChannelOutboundHandler接口:"></a>5.4.2.3 <code>ChannelOutboundHandler</code>接口:</h4><p>出站操作和数据将由 <code>ChannelOutboundHandler</code>处理.<code>ChannelOutboundHandler</code>的方法将会被 <code>Channel</code> , <code>ChannelPipeline</code> ,以及<br><code>ChannelHandlerContext</code> 调用.<br><code>ChannelOutboundHandler</code> 可以按照需要<code>推迟操作</code> 或者 <code>推迟事件</code>, 这可以通过一些复杂的方法来处理请求.<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/outbound%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="ChannelOutboundHandler">  </p>
<h4 id="5-4-2-4-ChannelHandlerAadptor"><a href="#5-4-2-4-ChannelHandlerAadptor" class="headerlink" title="5.4.2.4 ChannelHandlerAadptor:"></a>5.4.2.4 <code>ChannelHandlerAadptor</code>:</h4><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/adaptor%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="ChannelHandlerAdaptor"><br>说明:  </p>
<ul>
<li><code>ChannelInboundHandlerAdapter</code> 和 <code>ChannelOutboundHandlerAdapter</code> 类分别提供了 <code>ChannelInboundHandler</code>和 <code>ChannelOutboundHandler</code><br>的基本实现。通过扩展抽象类 <code>ChannelHandlerAdapter</code>，它们获得了它们共同的超接口 ChannelHandler 的方法。  </li>
<li><code>ChannelHandlerAdapter</code> 还提供了实用方法 <code>isSharable()</code>。如果其对应的实现被标注为 <code>@Sharable</code>，那么这个方法将返回 <code>true</code>，表示它可以被添加到多个<br><code>ChannelPipeline</code>中.</li>
<li>在 <code>ChannelInboundHandlerAdapter</code> 和 <code>ChannelOutboundHandlerAdapter</code> 中所提供的方法体调用了其相关联的 <code>ChannelHandlerContext</code> 上的等效方法(<br>fireXXX())， 从而将事件转发到了 <code>ChannelPipeline</code> 中的下一个 <code>ChannelHandler</code> 中。</li>
</ul>
<h4 id="5-4-2-5-防止内存泄露"><a href="#5-4-2-5-防止内存泄露" class="headerlink" title="5.4.2.5 防止内存泄露:"></a>5.4.2.5 防止内存泄露:</h4><ul>
<li><p>每当通过调用 <code>ChannelInboundHandler.channelRead()</code>或者 <code>ChannelOutboundHandler.write()</code>方法来处理数据时，都需要保证不会出现资源泄漏(buf没有释放)。<br>Netty 使用引用计数来处理池化的 ByteBuf。所以在完全使用完某个 ByteBuf 后，调整其引用计数是很重要的。  </p>
</li>
<li><p>Netty提供了class ResourceLeakDetector ， 它将对你应用程序的缓冲区分配做大约 1%的采样来检测内存泄露。<br>Netty定义的4种<code>泄漏检测级别</code>:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B%E7%BA%A7%E5%88%AB.png" alt="netty内存检测级别"></p>
<blockquote>
<p>可以通过启动命令: <code>java -Dio.netty.leakDetectionLevel=ADVANCED</code> 来设置内存检测级别</p>
</blockquote>
<p>检测结果: <code>存在内存泄漏</code>如图<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E6%A3%80%E6%B5%8B%E7%BB%93%E6%9E%9C.png" alt="netty内存检测结果"></p>
</li>
</ul>
<h3 id="5-4-3-ChannelPipeline"><a href="#5-4-3-ChannelPipeline" class="headerlink" title="5.4.3 ChannelPipeline:"></a>5.4.3 ChannelPipeline:</h3><ul>
<li><p><code>ChannelPipeline</code> : 是一个流经Channel的入站和出站事件的ChannelHandler实例双向链表.</p>
</li>
<li><p><code>ChannelPipeline</code>在<code>Channel</code>创建的时候,就会分配给<code>Channel</code>并与之关联,直到<code>Channel</code>关闭.在<code>Channel</code>整个生命周期中,<code>ChannelPipeline</code>都是唯一与之绑定的,<br>既不能 <code>新增pipeline</code>也不能<code>分离pipeline</code>.  </p>
</li>
<li><p>根据事件的类型,事件将会被 <code>ChannelInboundHandler</code>或者<code>ChannelOutboundHandler</code>处理.<code>ChannelHandler</code>之间通过上下文对象<code>ChannelHandlerContext</code>交互.</p>
</li>
<li><p><code>ChannelHandlerContext</code>可以让<code>ChannelHandler</code>之间进行交互,也可以动态的修改 <code>ChannelPipeline</code>中 handler的顺序.</p>
</li>
<li><p>入站口总是 <code>处理入站事件</code>的 <code>ChannelInboundHandler</code>(即链表的head总是指向<code>能够</code>处理入站事件的处理器),出站口总是 <code>处理出站事件</code>的<code>ChannelOutboundHandler</code>(即<br>链表的tail总是指向<code>能够</code>处理出站事件的处理器)</p>
</li>
<li><p><code>ChannelHandler</code>在<code>ChannelPipeline</code>执行顺序是根据<code>handler</code>被加入到双向链表中的顺序而决定的</p>
<blockquote>
<p>一个处理器,可能同时实现 <code>ChannelInboundHandler</code> 和 <code>ChannelOutboundHandler</code>.在<code>Netty</code>中事件流经pipeline的时候通过标志位判断当前处理器能不能处理该事件,直到找到一个<br>能够处理该事件的handler为止.</p>
</blockquote>
</li>
</ul>
<h4 id="5-4-3-1-获取pipeline"><a href="#5-4-3-1-获取pipeline" class="headerlink" title="5.4.3.1 获取pipeline:"></a>5.4.3.1 获取pipeline:</h4><ul>
<li>通过Channel获取</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java">bootstrap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>clientGroup<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token comment">// 这里实现的是中途断线重连,断线换成netty术语就是channel不活跃了</span>
<span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ch.pipeline就是获取pipeline</span>
        ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInboundHandlerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// channel在运行过程中中断,就会触发这个(channelInactive)方法,然后通过这个方法去重新连接</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelInactive</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
                ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token function">doConnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>通过ChannelHandlerContext获取: </li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handlerAdded</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token class-name">Channel</span> curChannel <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token comment">// 获取pipeline</span>
    <span class="token class-name">ChannelPipeline</span> pipeline <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-4-3-2-处理ChannelPipeline中的handler"><a href="#5-4-3-2-处理ChannelPipeline中的handler" class="headerlink" title="5.4.3.2 处理ChannelPipeline中的handler:"></a>5.4.3.2 处理ChannelPipeline中的handler:</h4><ol>
<li><code>ChannelPipeline</code>的修改,实际上是修改双向链表上的handler,<code>ChannelPipeline</code>提供了一些对handler进行crud的方法:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E4%BF%AE%E6%94%B9pipeline%E4%B8%AD%E7%9A%84handler.png" alt="修改pipeline中ChannelHandler">  </li>
</ol>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ChannelPipeline</span> pipeline <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token comment">// 通过channel或者channelHandlerContext可以获取pipeline</span>
<span class="token class-name">FirstHandler</span> firstHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FirstHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"handler1"</span><span class="token punctuation">,</span> firstHandler<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加入</span>
pipeline<span class="token punctuation">.</span><span class="token function">addFirst</span><span class="token punctuation">(</span><span class="token string">"handler2"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SecondHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 加入
pipeline<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token string">"handler3"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ThirdHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 加入
        <span class="token comment">// 此时pipeline中的顺序为 handler2 -&gt; handler1 -&gt; handler3</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
pipeline<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">"handler3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pipeline<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>firstHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>
pipeline<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"handler2"</span><span class="token punctuation">,</span> <span class="token string">"handler4"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ForthHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 此时pipeline中仅剩 handler4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>由于整个pipeline中的channelHandler都是由与channel绑定的eventLoop来执行的,所以如果要在handler中使用阻塞api,为了不降低整体的I/O性能,在<code>添加handler</code>的时候,<br>可以使用pipeline中带有EventExecutorGroup的add()方法,<code>将handler交给ExecutorGroup中的线程去执行而不是有eventLoop线程执行</code>.</p>
<ol start="2">
<li>访问handler:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/%E8%AE%BF%E9%97%AEhandler.png" alt="访问handler">  </li>
</ol>
</blockquote>
<h4 id="5-4-3-3-事件的传递"><a href="#5-4-3-3-事件的传递" class="headerlink" title="5.4.3.3 事件的传递:"></a>5.4.3.3 事件的传递:</h4><p><code>入站操作</code>:  实际上就是通知pipeline中下一个handler调用对应的接口:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/ChannelPipeline%E4%BC%A0%E9%80%92%E4%BA%8B%E4%BB%B6.png" alt="访问handler"></p>
<blockquote>
<p>调用channel或者pipeline对象的上述方法,会将整个事件沿着pipeline进行传播,但是通过handlerContext中的上述方法只会将事件传递给pipeline中下一个能够处理该事件的handler.</p>
</blockquote>
<p><code>出站操作</code>:  许多方法会造成底层套接字上发生一些列的动作<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/pipeline%E7%9A%84%E5%87%BA%E7%AB%99%E6%93%8D%E4%BD%9C.png" alt="访问handler"></p>
<h3 id="5-4-4-ChannelHandlerContext"><a href="#5-4-4-ChannelHandlerContext" class="headerlink" title="5.4.4 ChannelHandlerContext:"></a>5.4.4 ChannelHandlerContext:</h3><p><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/context%E4%B8%8Ehandler%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="访问handler"></p>
<ul>
<li><p><code>ChannelHandlerContext</code>代表 <code>handler</code> 和 <code>pipeline</code>之间的关联关系,只要有 <code>handler</code>分配到<code>pipeline</code>中来,就创建一个<code>context</code>与<code>handler关联</code>.</p>
</li>
<li><p><code>ChannelHandlerContext</code>主要作用是 用来与<code>context</code>关联的<code>handler</code>和其他<code>同一个pipeline中的handler</code>之间的交互 — 将消息传递给下一个能够处理该消息的handler</p>
</li>
<li><p><code>ChannelHandlerContext</code>与<code>handler</code>的关联关系是永远不会改变的,缓存Context的引用是线程安全的.</p>
</li>
<li><p><code>ChannelHandlerContext</code>常用方法总结:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/context%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.png" alt="context常用方法"></p>
</li>
<li><p><code>ChannelHandlerContext</code>与其他用同名方法的组件相比,产生的事件流更短,可以利用这个特性来获取最大的性能,<code>特性使用场景如下:</code></p>
<ul>
<li>为了减少将事件传经对它不感兴趣的handler所带来的开销</li>
<li>为了避免将事件传经那些可能会对他感兴趣的handler</li>
</ul>
</li>
<li><p><code>ChannelHandlerContext</code>只能于一个handler绑定,但是handler可以绑定多个context实例.</p>
<ul>
<li>正确示例: </li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@sharable</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SharableHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> meg<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        ctx<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>         
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>错误示例:</li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@sharable</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SharableHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> meg<span class="token punctuation">)</span><span class="token punctuation">{</span> 
        <span class="token comment">// 对共享资源不保证线程安全的修改操作,会导致问题</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
        ctx<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>         
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>handler必须添加@Shareble注解,并且handler必须要是线程安全的.</p>
</blockquote>
</li>
<li><p><code>ChannelHandlerContext</code>特殊用法:<br>保存<code>ChannelHandlerContext</code>在其他channel中使用或者以供稍后使用,完成一些特殊的操作</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WriteHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelHandlerAdapter</span> <span class="token punctuation">{</span> 
    <span class="token keyword">private</span> <span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handlerAdded</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>ctx <span class="token operator">=</span> ctx<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ctx<span class="token punctuation">.</span><span class="token function">writeAndFlush</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h3 id="5-4-5-异常处理"><a href="#5-4-5-异常处理" class="headerlink" title="5.4.5 异常处理:"></a>5.4.5 异常处理:</h3><h4 id="5-4-5-1-入站异常处理"><a href="#5-4-5-1-入站异常处理" class="headerlink" title="5.4.5.1 入站异常处理:"></a>5.4.5.1 入站异常处理:</h4><p>如果在处理入站事件的过程中,发生了异常,那么异常将会从当前handler开始在pipeline中的<code>InboundHandler</code>传递下去.</p>
<ul>
<li><p>实现异常处理: 通过重写exceptionCaught方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EchoServerHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exceptionCaught</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        cause<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ctx<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>注意事项:  </p>
<ol>
<li>默认的exceptionCaught()方法只是简单的将当前异常转发给了pipeline中的handler</li>
<li>如果异常到达了pipeline的尾部仍然没有处理,netty会在日志这种记录该异常为未处理异常, <code>通常为了所有异常都会被处理,pipeline的最后都会存在一个实现了示例代码的handler</code></li>
<li>通过重写exceptionCaught()来自定义自己的异常处理方法.  </li>
</ol>
</li>
</ul>
<h4 id="5-4-5-2-出站异常处理"><a href="#5-4-5-2-出站异常处理" class="headerlink" title="5.4.5.2 出站异常处理:"></a>5.4.5.2 出站异常处理:</h4><p>通过异步通知机制,来处理出站异常:  </p>
<ul>
<li><p>每个出站操作都会返回一个ChannelFuture.注册到ChannelFuture的ChannelFutureListener将在操作完成的时候通知该操作是否成功</p>
</li>
<li><p>几乎所有的ChannelOutboundHandler上的方法都会传入一个ChannelPromise的实例.channelPromise是channelFuture的子类,可以用于异步通知也可以用于立即通知的可写方法</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ChannelPromise</span> <span class="token function">setSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ChannelPromise</span> <span class="token function">setFailure</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> cause<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
<li><p>处理异常示例:<br>方法1: 通过向出站操作返回的ChannelFuture中添加具体的监听器</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ChannelFuture</span> future <span class="token operator">=</span> channel<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>someMessage<span class="token punctuation">)</span>
future<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChanelFutureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span><span class="token class-name">ChannelFuture</span> f<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            f<span class="token punctuation">.</span><span class="token function">cause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            f<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>     
    <span class="token punctuation">}</span>     
<span class="token punctuation">}</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><font color="red"><strong>启动重连的示例</strong></font></p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 注意这里一定不要调用sync()</span>
<span class="token class-name">ChannelFuture</span> connectFuture <span class="token operator">=</span> bootstrap<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InetSocketAddress</span><span class="token punctuation">(</span>remoteHost<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 添加链接事件的监听器,当连接事件触发的时候就会调用监听器里面的operationComplete方法</span>
connectFuture<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ChannelFutureListener</span><span class="token punctuation">)</span> future <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>future<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" 连接成功........"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">" 连接失败,正在尝试重连 ..... 当前为 第 %s 次重连"</span><span class="token punctuation">,</span>retryTime<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        future<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">doConnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>方法2: 给出站操作的参数 promise添加listener.</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OutboundExceptionHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelOutboundHandlerAdapter</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        promise<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelFutureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationComplete</span><span class="token punctuation">(</span><span class="token class-name">ChannelFuture</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>f<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    f<span class="token punctuation">.</span><span class="token function">cause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    f<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> 
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>两种方法如何选择: 不同出站事件的细节异常处理使用<code>方法一</code>更好, <code>方法二</code>更适合于一般的异常处理</p>
</blockquote>
</li>
</ul>
<h2 id="5-5-EventLoopGroup和EventLoop"><a href="#5-5-EventLoopGroup和EventLoop" class="headerlink" title="5.5 EventLoopGroup和EventLoop:"></a>5.5 EventLoopGroup和EventLoop:</h2><p><strong>继承结构</strong><br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/NioEventLoop%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" alt="NioEventLoop继承结构">  </p>
<h3 id="5-5-1-EventLoop"><a href="#5-5-1-EventLoop" class="headerlink" title="5.5.1 EventLoop:"></a>5.5.1 EventLoop:</h3><h4 id="5-5-1-1-概述"><a href="#5-5-1-1-概述" class="headerlink" title="5.5.1.1 概述:"></a>5.5.1.1 概述:</h4><p>运行任务来处理在连接的生命周期内发生的事件是任何网络框架的基本功能.这种功能在编程上的构造称为<code>事件循环</code>,Netty使用<code>EventLoop</code>表示.<br>事件循环的大致思路:  </p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 只要线程没有被关闭,就一直循环执行</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>terminated<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 阻塞获取就绪事件</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> readyEvents <span class="token operator">=</span> <span class="token function">blockUntilEventsReady</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 遍历就绪事件,逐一执行</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Runnable</span> event <span class="token operator">:</span> readEvents<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ev<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>在Netty所提供的线程模型中 <code>EventLoop</code> 将由一个永远不会改变的 线程 驱动(即由这个线程来处理<code>EventLoop</code>中就绪的事件).   </li>
<li>任务可以直接提交给<code>EventLoop的实现类</code>,根据具体需求直接直接执行或者调度执行.  <code>EventLoop</code>继承了JUC中的延迟任务线程池<code>ScheduledExecutorService</code>,但是<br>只定义了一个用来返回 <code>EventLoop</code>属于哪一个<code>EventLoopGroup</code>的方法(<code>parent()</code>)</li>
<li>根据配置和cpu核心数量不同,可能会创建多个EventLoop实例来优化资源的使用率,当个 <code>EventLoop</code>可以被分配给多个 <code>Channel</code>.  </li>
</ol>
<h4 id="5-5-1-2-I-O事件处理"><a href="#5-5-1-2-I-O事件处理" class="headerlink" title="5.5.1.2 I/O事件处理:"></a>5.5.1.2 I/O事件处理:</h4><ol>
<li><p>Netty3 中的I/O事件处理:</p>
<ul>
<li>Netty3 中使用的线程模型只保证了入站事件会在I/O线程(Netty4中的<code>EventLoop</code>)中执行.但是出站事件都是由调用线程处理,该线程可以能是<code>EventLoop</code>或者其他线程,这样一来<br>handler中执行的代码就有可能被多个线程并发执行,就需要在handler中处理线程安全问题.<br>比如: 在不同的线程中调用Channel.write(),同一个Channel中同时触发了出站事件.</li>
<li>Netty3 模型中如果出站事件触发了入站事件,可能造成一次额外的线程上下文切换.<br>比如: Channel.write()方法造成异常的时候,需要生成并触发一个exceptionCaught事件.在Netty3 模型中 exceptionCaught是一个入站事件,需要在调用线程中执行,然后将事件<br>交给I/O线程处理,造成依次不必要的线程上下文切换.</li>
</ul>
</li>
<li><p>Netty4 中的I/O事件处理:  </p>
<ul>
<li>所有的I/O操作和事件都交给 驱动<code>EventLoop</code>永远不会改变的线程处理.解决了 <code>handler需要注意线程安全的问题</code> 和 <code>不必要的线程切换</code></li>
</ul>
</li>
</ol>
<h4 id="5-5-1-3-I-O事件处理"><a href="#5-5-1-3-I-O事件处理" class="headerlink" title="5.5.1.3 I/O事件处理:"></a>5.5.1.3 I/O事件处理:</h4><ol>
<li><p>JDK的任务调度API:  通过 <code>ScheduledExecutorService</code>来完成</p>
</li>
<li><p><code>EventLoop</code>来调度任务:  </p>
<ul>
<li>延迟多少时间后执行一次:  </li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Channel</span> ch <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">// 60 秒之后执行一次,之后不再执行</span>
<span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"60 seconds later"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>定时任务:  </li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Channel</span> ch <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">// 60秒后,执行第一次,之后每60秒执行一次.</span>
<span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span>
    <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Run every 60 seconds"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit<span class="token punctuation">.</span>Seconds</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>任务的取消: 通过future来取消或者检查任务的执行状态  </li>
</ul>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ScheduledFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Some other code that runs...</span>
<span class="token comment">// 任务的取消</span>
<span class="token keyword">boolean</span> mayInterruptIfRunning <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
future<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span>mayInterruptIfRunning<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>说明:</p>
<ol>
<li>netty的任务调度是否立即执行是取决于调用任务的线程是否是 与<code>EventLoop</code>绑定的线程,即<code>负责处理</code>该channel事件的线程.如果是那么将会立即执行,如果不是那么将会把任务放入延时队列中,<br>在 <code>EventLoop</code> 下次处理它的事件的时候,会去处理这些任务.<code>保证了任务不会被多个线程同时执行</code>.  </li>
<li><code>EventLoop</code>的任务队列,是 <code>EventLoop独有的</code>,独立于其他EventLoop.</li>
<li>调度任务执行的逻辑:<br><img src="/Netty/netty%E5%AE%9E%E6%88%98/5_Netty%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/eventLoop%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%9A%84%E9%80%BB%E8%BE%91.png" alt="调度任务执行逻辑"></li>
</ol>
</li>
</ol>
<h3 id="5-5-2-EventLoopGroup"><a href="#5-5-2-EventLoopGroup" class="headerlink" title="5.5.2 EventLoopGroup:"></a>5.5.2 EventLoopGroup:</h3><p>从上面的继承结构图中可以看出 <code>EventLoopGroup</code>实际上就是一个 <code>ScheduledExecutorService</code> 延时任务线程池.<br><code>EventLoopGroup</code>主要功能:  </p>
<ol>
<li>作为一个线程池管理 <code>EventLoop实例</code></li>
<li>将channel注册到eventLoop的selector上</li>
<li></li>
</ol>
<h2 id="5-6-Future和Promise"><a href="#5-6-Future和Promise" class="headerlink" title="5.6 Future和Promise:"></a>5.6 Future和Promise:</h2><p>TODO</p>

                
            </div>
            <!-- 文章底部下划线 -->
<!--            <hr/>-->

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/netty/">
                                    <span class="chip bg-color">netty</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/hello-world/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="Hello World">
                        
                        <span class="card-title">Hello World</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-08-29
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            pounds
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/Netty/netty%E5%AE%9E%E6%88%98/4_Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="4 Netty线程模型">
                        
                        <span class="card-title">4 Netty线程模型</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-08-29
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/netty%E5%AE%9E%E6%88%98/" class="post-category">
                                    netty实战
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/netty/">
                        <span class="chip bg-color">netty</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE' || selection.getRangeAt(0).commonAncestorContainer.nodeName === 'CODE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: pounds<br />'
            + '文章作者: pounds<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021</span>
            
            <span id="year">2021</span>
            <br>
            <a href="/about" target="_blank">pounds</a>
            <br>
            <span>心有猛虎 | 细嗅蔷薇</span>
<!--            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>-->
<!--            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>-->
<!--            <br>-->
<!--            -->
<!--            -->
<!--            -->
<!--                -->
<!--            -->
<!--            -->
<!--                <span id="busuanzi_container_site_pv">-->
<!--                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;-->
<!--                    <span id="busuanzi_value_site_pv" class="white-color"></span>-->
<!--            </span>-->
<!--            -->
<!--            -->
<!--                <span id="busuanzi_container_site_uv">-->
<!--                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;-->
<!--                    <span id="busuanzi_value_site_uv" class="white-color"></span>-->
<!--            </span>-->
<!--            -->
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/pounds018" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1003937793@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1003937793" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1003937793" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
